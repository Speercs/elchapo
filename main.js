'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
var encode$1 = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
var decode$1 = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

var base64 = {
	encode: encode$1,
	decode: decode$1
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
var encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
var decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

var base64Vlq = {
	encode: encode,
	decode: decode
};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var util = createCommonjsModule(function (module, exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;
});
util.getArg;
util.urlParse;
util.urlGenerate;
util.normalize;
util.join;
util.isAbsolute;
util.relative;
util.toSetString;
util.fromSetString;
util.compareByOriginalPositions;
util.compareByGeneratedPositionsDeflated;
util.compareByGeneratedPositionsInflated;
util.parseSourceMapInput;
util.computeSourceURL;

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */


var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet$1() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet$1.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet$1();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet$1.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet$1.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet$1.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet$1.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet$1.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet$1.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

var ArraySet_1 = ArraySet$1;

var arraySet = {
	ArraySet: ArraySet_1
};

var binarySearch = createCommonjsModule(function (module, exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};
});
binarySearch.GREATEST_LOWER_BOUND;
binarySearch.LEAST_UPPER_BOUND;
binarySearch.search;

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
var quickSort_1 = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

var quickSort$1 = {
	quickSort: quickSort_1
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */



var ArraySet = arraySet.ArraySet;

var quickSort = quickSort$1.quickSort;

function SourceMapConsumer$1(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer$1.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer$1.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer$1.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer$1.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer$1.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer$1.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer$1.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer$1.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer$1.GENERATED_ORDER = 1;
SourceMapConsumer$1.ORIGINAL_ORDER = 2;

SourceMapConsumer$1.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer$1.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer$1.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer$1.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer$1.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer$1.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer$1.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

var SourceMapConsumer_1 = SourceMapConsumer$1;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$1;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64Vlq.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer$1.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer$1.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer$1(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$1;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

var sourceMapConsumer = {
	SourceMapConsumer: SourceMapConsumer_1,
	BasicSourceMapConsumer: BasicSourceMapConsumer_1,
	IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
};

var SourceMapConsumer = sourceMapConsumer.SourceMapConsumer;

class ErrorMapper {
    static get consumer() {
        if (this._consumer == null) {
            this._consumer = new SourceMapConsumer(require("main.js.map"));
        }
        return this._consumer;
    }
    /**
     * Generates a stack trace using a source map generate original symbol names.
     *
     * WARNING - EXTREMELY high CPU cost for first call after reset - >30 CPU! Use sparingly!
     * (Consecutive calls after a reset are more reasonable, ~0.1 CPU/ea)
     *
     * @param {Error | string} error The error or original stack trace
     * @returns {string} The source-mapped stack trace
     */
    static sourceMappedStackTrace(error) {
        const stack = error instanceof Error ? error.stack : error;
        if (Object.prototype.hasOwnProperty.call(this.cache, stack)) {
            return this.cache[stack];
        }
        // eslint-disable-next-line no-useless-escape
        const re = /^\s+at\s+(.+?\s+)?\(?([0-z._\-\\\/]+):(\d+):(\d+)\)?$/gm;
        let match;
        let outStack = error.toString();
        while ((match = re.exec(stack))) {
            if (match[2] === "main") {
                const pos = this.consumer.originalPositionFor({
                    column: parseInt(match[4], 10),
                    line: parseInt(match[3], 10)
                });
                if (pos.line != null) {
                    if (pos.name) {
                        outStack += `\n    at ${pos.name} (${pos.source}:${pos.line}:${pos.column})`;
                    }
                    else {
                        if (match[1]) {
                            // no original source file name known - use file name from given trace
                            outStack += `\n    at ${match[1]} (${pos.source}:${pos.line}:${pos.column})`;
                        }
                        else {
                            // no original source file name known or in given trace - omit name
                            outStack += `\n    at ${pos.source}:${pos.line}:${pos.column}`;
                        }
                    }
                }
                else {
                    // no known position
                    break;
                }
            }
            else {
                // no more parseable lines
                break;
            }
        }
        this.cache[stack] = outStack;
        return outStack;
    }
    static wrapLoop(loop) {
        return () => {
            try {
                loop();
            }
            catch (e) {
                if (e instanceof Error) {
                    if ("sim" in Game.rooms) {
                        const message = `Source maps don't work in the simulator - displaying original error`;
                        console.log(`<span style='color:red'>${message}<br>${_.escape(e.stack)}</span>`);
                    }
                    else {
                        console.log(`<span style='color:red'>${_.escape(this.sourceMappedStackTrace(e))}</span>`);
                    }
                }
                else {
                    // can't handle it
                    throw e;
                }
            }
        };
    }
}
// Cache.ts previously mapped traces to improve performance
ErrorMapper.cache = {};

const SIGNATURE = "nop";
const ENEMIES = ["o4kapuk", "wtfrank", "wtai", "FeTiD", "SBense", "echemoo", "liaohuo"];
const FRIENDLIES = ["xuyd", "XianDengDuoQi", "6g3y", "superbitch"];
const BLACKLIST_ROOMS = [];
const MAX_EXPANSION_RANGE = 14;
/**
 * Power Bank
 */
const POWER_BANK_AVOID_USERNAMES = ["TgDgNU", "6g3y", "Tigga"];
const POWER_BANK_COMPETITOR_USERNAMES = ["Tigga", "1buyu", "SBense", "Morningtea"]; // todo automate, maybe set a new room prop with last time some miner died and make it 200k ticks to cleanup
/**
 * Powerlvl target room, home room
 */
const GCL_POWERLEVEL_ROOMS = {
    E54S51: ["E55S51"],
    E41S28: ["E42S28"],
    E43S28: ["E42S28"],
    E55S42: ["E55S43"],
    E36S42: ["E35S42"]
};
/**
 * Transfers out all storages and winds down operations
 */
const ABANDONING_ROOMS = [];
/**
 * Will focus on gcl up to lvl
 */
const ROOM_COUNT_GOAL = 60;
/**
 * Stronghold
 */
const STRONGHLD_4_MAX_ROOM_WALLS = 1000;

const MASS_RANGED_ATTACK_DECAY = {
    0: 1,
    1: 1,
    2: 0.4,
    3: 0.1
};

var RoomTypeEnum;
(function (RoomTypeEnum) {
    RoomTypeEnum[RoomTypeEnum["CROSSROAD"] = 0] = "CROSSROAD";
    RoomTypeEnum[RoomTypeEnum["HIGHWAY"] = 1] = "HIGHWAY";
    RoomTypeEnum[RoomTypeEnum["CENTER"] = 2] = "CENTER";
    RoomTypeEnum[RoomTypeEnum["SK"] = 3] = "SK";
    RoomTypeEnum[RoomTypeEnum["STANDART"] = 4] = "STANDART";
})(RoomTypeEnum || (RoomTypeEnum = {}));
var QuadGroupStage;
(function (QuadGroupStage) {
    QuadGroupStage["SPAWNING"] = "spawning";
    QuadGroupStage["BOOSTING"] = "boosting";
    QuadGroupStage["GROUP_TRAIN"] = "groupTrain";
    QuadGroupStage["TRAVELING"] = "traveling";
    QuadGroupStage["FORMING"] = "forming";
    QuadGroupStage["ENTERING_ROOM"] = "enteringRoom";
    QuadGroupStage["ATTACKING"] = "attacking";
    QuadGroupStage["RETREATING"] = "retreating";
})(QuadGroupStage || (QuadGroupStage = {}));
var DuoGroupStage;
(function (DuoGroupStage) {
    DuoGroupStage["SPAWNING"] = "spawning";
    DuoGroupStage["BOOSTING"] = "boosting";
    DuoGroupStage["WORKING"] = "working";
    DuoGroupStage["RETREATING"] = "retreating";
})(DuoGroupStage || (DuoGroupStage = {}));
var ResourceType$1;
(function (ResourceType) {
    ResourceType["ENERGY"] = "energy";
    ResourceType["POWER"] = "power";
    ResourceType["MINERAL"] = "mineral";
    ResourceType["BOOST"] = "boost";
    ResourceType["T3BOOST"] = "t3boost";
    ResourceType["COMODITY"] = "comodity";
    ResourceType["COMODITY_BAR"] = "comodityBar";
    ResourceType["COMPOUND"] = "compound";
    ResourceType["OTHER"] = "other";
})(ResourceType$1 || (ResourceType$1 = {}));
var CreepIntent;
(function (CreepIntent) {
    CreepIntent[CreepIntent["HEAL"] = 0] = "HEAL";
    CreepIntent[CreepIntent["RANGED_HEAL"] = 1] = "RANGED_HEAL";
    CreepIntent[CreepIntent["RANGED_ATTACK"] = 2] = "RANGED_ATTACK";
})(CreepIntent || (CreepIntent = {}));

function skRoomsInSector(roomName) {
    const SK_ROOM_COORDINATES = [
        { x: 6, y: 4 },
        { x: 5, y: 4 },
        { x: 4, y: 4 },
        { x: 4, y: 5 },
        { x: 4, y: 6 },
        { x: 5, y: 6 },
        { x: 6, y: 6 },
        { x: 6, y: 5 }
    ];
    return SK_ROOM_COORDINATES.map(offset => roomName.replace(/([WE].?)([0-9])([SN].?)([0-9])/g, `$1${offset.x}$3${offset.y}`));
}

var KEYS;
(function (KEYS) {
    KEYS[KEYS["UPDATED_AT"] = 1] = "UPDATED_AT";
    KEYS[KEYS["NAME"] = 2] = "NAME";
    KEYS[KEYS["TYPE"] = 3] = "TYPE";
    KEYS[KEYS["OWNER_USERNAME"] = 4] = "OWNER_USERNAME";
    KEYS[KEYS["CONTROLLER_LEVEL"] = 5] = "CONTROLLER_LEVEL";
    KEYS[KEYS["RESERVATION_USERNAME"] = 6] = "RESERVATION_USERNAME";
    KEYS[KEYS["RESERVATION_ENDS_AT"] = 7] = "RESERVATION_ENDS_AT";
    KEYS[KEYS["IS_MINE"] = 8] = "IS_MINE";
    KEYS[KEYS["TOWER_COUNT"] = 9] = "TOWER_COUNT";
    KEYS[KEYS["SIGNATURE_OWNER"] = 10] = "SIGNATURE_OWNER";
    KEYS[KEYS["HOSTILE_CREEP_COUNT"] = 12] = "HOSTILE_CREEP_COUNT";
    KEYS[KEYS["SAFE_MODE_ENDS_AT"] = 13] = "SAFE_MODE_ENDS_AT";
    KEYS[KEYS["SOURCE_COUNT"] = 14] = "SOURCE_COUNT";
    KEYS[KEYS["MINERAL_TYPE"] = 15] = "MINERAL_TYPE";
    KEYS[KEYS["TERRAIN_WALLS_COUNT"] = 16] = "TERRAIN_WALLS_COUNT";
    KEYS[KEYS["TERRAIN_SWAMPS_COUNT"] = 17] = "TERRAIN_SWAMPS_COUNT";
    KEYS[KEYS["LAYOUT"] = 20] = "LAYOUT";
    KEYS[KEYS["SAFE_MODE_COOLDOWN_ENDS_AT"] = 21] = "SAFE_MODE_COOLDOWN_ENDS_AT";
    KEYS[KEYS["STATUS"] = 23] = "STATUS";
    KEYS[KEYS["STATUS_UPDATED_AT"] = 24] = "STATUS_UPDATED_AT";
    KEYS[KEYS["RESOURCES_CREDIT_VALUE"] = 25] = "RESOURCES_CREDIT_VALUE";
    KEYS[KEYS["LAB_OUTPUT_RESOURCE"] = 26] = "LAB_OUTPUT_RESOURCE";
    KEYS[KEYS["RECENT_KILLS"] = 27] = "RECENT_KILLS";
    KEYS[KEYS["RECENT_DEATHS"] = 28] = "RECENT_DEATHS";
    KEYS[KEYS["INCREASED_SPAWN_UNTIL"] = 30] = "INCREASED_SPAWN_UNTIL";
    KEYS[KEYS["CENTER_DISTANCES"] = 31] = "CENTER_DISTANCES";
    KEYS[KEYS["HOSTILE_ATTACK_POWER"] = 32] = "HOSTILE_ATTACK_POWER";
    KEYS[KEYS["HOSTILE_RANGED_ATTACK_POWER"] = 33] = "HOSTILE_RANGED_ATTACK_POWER";
    KEYS[KEYS["HOSTILE_HEAL_POWER"] = 34] = "HOSTILE_HEAL_POWER";
    KEYS[KEYS["NPC_ATTACK_POWER"] = 35] = "NPC_ATTACK_POWER";
    KEYS[KEYS["NPC_RANGED_ATTACK_POWER"] = 36] = "NPC_RANGED_ATTACK_POWER";
    KEYS[KEYS["NPC_HEAL_POWER"] = 37] = "NPC_HEAL_POWER";
    KEYS[KEYS["MY_ATTACK_POWER"] = 38] = "MY_ATTACK_POWER";
    KEYS[KEYS["MY_RANGED_ATTACK_POWER"] = 39] = "MY_RANGED_ATTACK_POWER";
    KEYS[KEYS["MY_HEAL_POWER"] = 40] = "MY_HEAL_POWER";
    KEYS[KEYS["SECTOR_NAME"] = 41] = "SECTOR_NAME";
    KEYS[KEYS["SOURCES"] = 42] = "SOURCES";
    KEYS[KEYS["SOURCES_ID"] = 43] = "SOURCES_ID";
    KEYS[KEYS["SOURCES_DISTANCE"] = 44] = "SOURCES_DISTANCE";
    KEYS[KEYS["SOURCES_MINING_POS"] = 45] = "SOURCES_MINING_POS";
    KEYS[KEYS["SOURCES_UPDATED_AT"] = 46] = "SOURCES_UPDATED_AT";
    KEYS[KEYS["HITS"] = 47] = "HITS";
    KEYS[KEYS["HITS_STRUCTURE"] = 48] = "HITS_STRUCTURE";
    KEYS[KEYS["HITS_DEFENCE_BUILDING_COUNT"] = 49] = "HITS_DEFENCE_BUILDING_COUNT";
    KEYS[KEYS["HITS_DEFENCE_BUILDING_AVERAGE_HITS"] = 50] = "HITS_DEFENCE_BUILDING_AVERAGE_HITS";
    KEYS[KEYS["HITS_UPDATED_AT"] = 51] = "HITS_UPDATED_AT";
    KEYS[KEYS["RESOURCES_UPDATED_AT"] = 52] = "RESOURCES_UPDATED_AT";
    KEYS[KEYS["WAS_ATTACKED_AT"] = 53] = "WAS_ATTACKED_AT";
    KEYS[KEYS["HOSTILE_DISMANTLE_POWER"] = 54] = "HOSTILE_DISMANTLE_POWER";
    KEYS[KEYS["RESOURCES_VALUABLE_HAULT_COUNT"] = 55] = "RESOURCES_VALUABLE_HAULT_COUNT";
})(KEYS || (KEYS = {}));
class RoomMemoryObject {
    constructor(_roomName) {
        this._roomName = _roomName;
        if (Memory.roomsV2 === undefined) {
            Memory.roomsV2 = {};
        }
        if (!Memory.roomsV2[_roomName]) {
            Memory.roomsV2[_roomName] = {};
        }
        this.mem = Memory.roomsV2[_roomName];
    }
    get roomName() {
        return this._roomName;
    }
    get updatedAt() {
        return this.mem[KEYS.UPDATED_AT] || 0;
    }
    set updatedAt(time) {
        this.mem[KEYS.UPDATED_AT] = time;
    }
    get name() {
        return this.mem[KEYS.NAME];
    }
    set name(name) {
        this.mem[KEYS.NAME] = name;
    }
    get type() {
        return this.mem[KEYS.TYPE];
    }
    set type(type) {
        this.mem[KEYS.TYPE] = type;
    }
    get wasAttackedAt() {
        return this.mem[KEYS.WAS_ATTACKED_AT];
    }
    set wasAttackedAt(wasAttackedAt) {
        this.mem[KEYS.WAS_ATTACKED_AT] = wasAttackedAt;
    }
    get ownerUsername() {
        return this.mem[KEYS.OWNER_USERNAME];
    }
    set ownerUsername(ownerUsername) {
        this.mem[KEYS.OWNER_USERNAME] = ownerUsername;
    }
    get controllerLevel() {
        return this.mem[KEYS.CONTROLLER_LEVEL];
    }
    set controllerLevel(controllerLevel) {
        this.mem[KEYS.CONTROLLER_LEVEL] = controllerLevel;
    }
    get reservationUsername() {
        return this.mem[KEYS.RESERVATION_USERNAME];
    }
    set reservationUsername(reservationUsername) {
        this.mem[KEYS.RESERVATION_USERNAME] = reservationUsername;
    }
    get reservationEndsAt() {
        return this.mem[KEYS.RESERVATION_ENDS_AT];
    }
    set reservationEndsAt(reservationEndsAt) {
        this.mem[KEYS.RESERVATION_ENDS_AT] = reservationEndsAt;
    }
    get isMine() {
        return this.mem[KEYS.IS_MINE];
    }
    set isMine(isMine) {
        this.mem[KEYS.IS_MINE] = isMine;
    }
    get towerCount() {
        return this.mem[KEYS.TOWER_COUNT];
    }
    set towerCount(towerCount) {
        this.mem[KEYS.TOWER_COUNT] = towerCount;
    }
    get signatureOwner() {
        return this.mem[KEYS.SIGNATURE_OWNER];
    }
    set signatureOwner(signatureOwner) {
        this.mem[KEYS.SIGNATURE_OWNER] = signatureOwner;
    }
    get hostileCreepCount() {
        return this.mem[KEYS.HOSTILE_CREEP_COUNT];
    }
    set hostileCreepCount(hostileCreepCount) {
        this.mem[KEYS.HOSTILE_CREEP_COUNT] = hostileCreepCount;
    }
    get safeModeEndsAt() {
        return this.mem[KEYS.SAFE_MODE_ENDS_AT];
    }
    set safeModeEndsAt(safeModeEndsAt) {
        this.mem[KEYS.SAFE_MODE_ENDS_AT] = safeModeEndsAt;
    }
    get sourceCount() {
        return this.mem[KEYS.SOURCE_COUNT];
    }
    set sourceCount(sourceCount) {
        this.mem[KEYS.SOURCE_COUNT] = sourceCount;
    }
    get mineralType() {
        return this.mem[KEYS.MINERAL_TYPE];
    }
    set mineralType(mineralType) {
        this.mem[KEYS.MINERAL_TYPE] = mineralType;
    }
    get terrainWallsCount() {
        return this.mem[KEYS.TERRAIN_WALLS_COUNT];
    }
    set terrainWallsCount(terrainWallsCount) {
        this.mem[KEYS.TERRAIN_WALLS_COUNT] = terrainWallsCount;
    }
    get terrainSwampsCount() {
        return this.mem[KEYS.TERRAIN_SWAMPS_COUNT];
    }
    set terrainSwampsCount(terrainSwampsCount) {
        this.mem[KEYS.TERRAIN_SWAMPS_COUNT] = terrainSwampsCount;
    }
    get layout() {
        return this.mem[KEYS.LAYOUT];
    }
    set layout(layout) {
        this.mem[KEYS.LAYOUT] = layout;
    }
    get safeModeCooldownEndsAt() {
        return this.mem[KEYS.SAFE_MODE_COOLDOWN_ENDS_AT];
    }
    set safeModeCooldownEndsAt(safeModeCooldownEndsAt) {
        this.mem[KEYS.SAFE_MODE_COOLDOWN_ENDS_AT] = safeModeCooldownEndsAt;
    }
    get status() {
        return this.mem[KEYS.STATUS];
    }
    set status(statusValue) {
        this.mem[KEYS.STATUS] = statusValue;
    }
    get statusUpdatedAt() {
        return this.mem[KEYS.STATUS_UPDATED_AT];
    }
    set statusUpdatedAt(statusUpdatedAt) {
        this.mem[KEYS.STATUS_UPDATED_AT] = statusUpdatedAt;
    }
    get resourcesCreditValue() {
        return this.mem[KEYS.RESOURCES_CREDIT_VALUE];
    }
    set resourcesCreditValue(resourcesCreditValue) {
        this.mem[KEYS.RESOURCES_CREDIT_VALUE] = resourcesCreditValue;
    }
    get resourcesValuableHaulCount() {
        return this.mem[KEYS.RESOURCES_VALUABLE_HAULT_COUNT];
    }
    set resourcesValuableHaulCount(resourcesValuableHaulCount) {
        this.mem[KEYS.RESOURCES_VALUABLE_HAULT_COUNT] = resourcesValuableHaulCount;
    }
    get resourcesUpdatedAt() {
        return this.mem[KEYS.RESOURCES_UPDATED_AT];
    }
    set resourcesUpdatedAt(resourcesUpdatedAt) {
        this.mem[KEYS.RESOURCES_UPDATED_AT] = resourcesUpdatedAt;
    }
    get labOutputResource() {
        return this.mem[KEYS.LAB_OUTPUT_RESOURCE];
    }
    set labOutputResource(labOutputResource) {
        this.mem[KEYS.LAB_OUTPUT_RESOURCE] = labOutputResource;
    }
    get recentKills() {
        return this.mem[KEYS.RECENT_KILLS];
    }
    set recentKills(recentKills) {
        this.mem[KEYS.RECENT_KILLS] = recentKills;
    }
    get recentDeaths() {
        return this.mem[KEYS.RECENT_DEATHS];
    }
    set recentDeaths(recentDeaths) {
        this.mem[KEYS.RECENT_DEATHS] = recentDeaths;
    }
    get increasedSpawnUntil() {
        return this.mem[KEYS.INCREASED_SPAWN_UNTIL];
    }
    set increasedSpawnUntil(increasedSpawnUntill) {
        this.mem[KEYS.INCREASED_SPAWN_UNTIL] = increasedSpawnUntill;
    }
    get centerDistances() {
        return this.mem[KEYS.CENTER_DISTANCES];
    }
    set centerDistances(centerDistances) {
        this.mem[KEYS.CENTER_DISTANCES] = centerDistances;
    }
    get hostileAttackPower() {
        return this.mem[KEYS.HOSTILE_ATTACK_POWER];
    }
    set hostileAttackPower(hostileAttackPower) {
        this.mem[KEYS.HOSTILE_ATTACK_POWER] = hostileAttackPower;
    }
    get hostileRangedAttackPower() {
        return this.mem[KEYS.HOSTILE_RANGED_ATTACK_POWER];
    }
    set hostileRangedAttackPower(hostileRangedAttackPower) {
        this.mem[KEYS.HOSTILE_RANGED_ATTACK_POWER] = hostileRangedAttackPower;
    }
    get hostileHealPower() {
        return this.mem[KEYS.HOSTILE_HEAL_POWER];
    }
    set hostileHealPower(hostileHealPower) {
        this.mem[KEYS.HOSTILE_HEAL_POWER] = hostileHealPower;
    }
    get hostileDismantlePower() {
        return this.mem[KEYS.HOSTILE_DISMANTLE_POWER];
    }
    set hostileDismantlePower(hostileDismantlePower) {
        this.mem[KEYS.HOSTILE_DISMANTLE_POWER] = hostileDismantlePower;
    }
    get npcAttackPower() {
        return this.mem[KEYS.NPC_ATTACK_POWER];
    }
    set npcAttackPower(npcAttackPower) {
        this.mem[KEYS.NPC_ATTACK_POWER] = npcAttackPower;
    }
    get npcRangedAttackPower() {
        return this.mem[KEYS.NPC_RANGED_ATTACK_POWER];
    }
    set npcRangedAttackPower(npcRangedAttackPower) {
        this.mem[KEYS.NPC_RANGED_ATTACK_POWER] = npcRangedAttackPower;
    }
    get npcHealPower() {
        return this.mem[KEYS.NPC_HEAL_POWER];
    }
    set npcHealPower(npcHealPower) {
        this.mem[KEYS.NPC_HEAL_POWER] = npcHealPower;
    }
    get myAttackPower() {
        return this.mem[KEYS.MY_ATTACK_POWER];
    }
    set myAttackPower(myAttackPower) {
        this.mem[KEYS.MY_ATTACK_POWER] = myAttackPower;
    }
    get myRangedAttackPower() {
        return this.mem[KEYS.MY_RANGED_ATTACK_POWER];
    }
    set myRangedAttackPower(myRangedAttackPower) {
        this.mem[KEYS.MY_RANGED_ATTACK_POWER] = myRangedAttackPower;
    }
    get myHealPower() {
        return this.mem[KEYS.MY_HEAL_POWER];
    }
    set myHealPower(myHealPower) {
        this.mem[KEYS.MY_HEAL_POWER] = myHealPower;
    }
    get sectorName() {
        return this.mem[KEYS.SECTOR_NAME];
    }
    set sectorName(sectorName) {
        this.mem[KEYS.SECTOR_NAME] = sectorName;
    }
    get hitsDefenceBuildingCount() {
        return this.mem[KEYS.HITS_DEFENCE_BUILDING_COUNT];
    }
    set hitsDefenceBuildingCount(hitsDefenceBuildingCount) {
        this.mem[KEYS.HITS_DEFENCE_BUILDING_COUNT] = hitsDefenceBuildingCount;
    }
    get hitsDefenceBuildingAverageHits() {
        return this.mem[KEYS.HITS_DEFENCE_BUILDING_AVERAGE_HITS];
    }
    set hitsDefenceBuildingAverageHits(hitsDefenceBuildingAverageHits) {
        this.mem[KEYS.HITS_DEFENCE_BUILDING_AVERAGE_HITS] = hitsDefenceBuildingAverageHits;
    }
    get hitsUpdatedAt() {
        return this.mem[KEYS.HITS_UPDATED_AT];
    }
    set hitsUpdatedAt(hitsUpdatedAt) {
        this.mem[KEYS.HITS_UPDATED_AT] = hitsUpdatedAt;
    }
    get sources() {
        return this.mem[KEYS.SOURCES];
    }
    set sources(sources) {
        this.mem[KEYS.SOURCES] = sources;
    }
    isInSafeMode() {
        return (this.safeModeEndsAt || 0) > Game.time;
    }
}

const USERNAME = {
    ME: "elchapo",
    INVADER: "Invader",
    SOURCE_KEEPER: "Source Keeper",
    POWER_BANK: "Power Bank",
    SCREEPS: "Screeps",
    PUBLIC: "Public"
};

class RoomModel {
    constructor(roomName) {
        this.roomName = roomName;
        this.roomMemoryV2 = new RoomMemoryObject(roomName);
    }
    get sectorName() {
        return this.roomMemoryV2.sectorName;
    }
    get pvpDeaths() {
        var _a;
        return ((_a = this.roomMemoryV2) === null || _a === void 0 ? void 0 : _a.recentDeaths) || 0;
    }
    get terrainWallsCount() {
        var _a;
        return (_a = this.roomMemoryV2) === null || _a === void 0 ? void 0 : _a.terrainWallsCount;
    }
    get hitsDefencesAvg() {
        var _a;
        return ((_a = this.roomMemoryV2) === null || _a === void 0 ? void 0 : _a.hitsDefenceBuildingAverageHits) || 0;
    }
    get safeModeCooldownEndsAt() {
        return this.roomMemoryV2.safeModeCooldownEndsAt || 0;
    }
    get room() {
        return Game.rooms[this.roomName];
    }
    get isReservedNotByMe() {
        return !!this.reservedUsername && this.reservedUsername !== USERNAME.ME;
    }
    get isNewbieRoom() {
        return (!this.room ||
            this.room.level < 4 ||
            !this.room.storage ||
            this.room.storage.store.energy < 20000 ||
            this.room.energyCapacityAvailable < 1300);
    }
    get isSafeToMine() {
        return ((!this.hostileAttackPower &&
            !this.hostileRangedAttackPower &&
            !this.npcAttackPower &&
            !this.npcRangedAttackPower) ||
            this.updatedAt < Game.time - 300);
    }
    get sectionHasInvaders() {
        const roomNames = skRoomsInSector(this.roomName);
        return !!roomNames.find(roomName => { var _a; return (_a = Memory.strongholds[roomName]) === null || _a === void 0 ? void 0 : _a.isAlive; });
    }
    get isMine() {
        return !!this.roomMemoryV2.isMine;
    }
    get type() {
        return this.roomMemoryV2.type;
    }
    get towerCount() {
        return this.roomMemoryV2.towerCount || 0;
    }
    get activeTowerCount() {
        return this.roomMemoryV2.towerCount || 0;
    }
    get hostileCreepCount() {
        return this.roomMemoryV2.hostileCreepCount || 0;
    }
    get invadeCoreLevel() {
        var _a;
        return (_a = Memory.strongholds[this.roomName]) === null || _a === void 0 ? void 0 : _a.level;
    }
    get isInSafeMode() {
        return (this.roomMemoryV2.safeModeEndsAt || 0) > Game.time;
    }
    get level() {
        return this.roomMemoryV2.controllerLevel || 0;
    }
    get ownerUsername() {
        return this.roomMemoryV2.ownerUsername || null;
    }
    hostilePower(...types) {
        let power = 0;
        types.forEach(type => {
            var _a, _b, _c;
            switch (type) {
                case ATTACK:
                    power += ((_a = this.room) === null || _a === void 0 ? void 0 : _a.hostileAttackPower) || this.roomMemoryV2.hostileAttackPower || 0;
                    break;
                case RANGED_ATTACK:
                    power += ((_b = this.room) === null || _b === void 0 ? void 0 : _b.hostileRangedAttackPower) || this.roomMemoryV2.hostileRangedAttackPower || 0;
                    break;
                case HEAL:
                    power += ((_c = this.room) === null || _c === void 0 ? void 0 : _c.hostileHealPower) || this.roomMemoryV2.hostileHealPower || 0;
                    break;
            }
        });
        return power;
    }
    myPower(...types) {
        let power = 0;
        types.forEach(type => {
            var _a, _b, _c;
            switch (type) {
                case ATTACK:
                    power += ((_a = this.room) === null || _a === void 0 ? void 0 : _a.myAttackPower) || 0;
                    break;
                case RANGED_ATTACK:
                    power += ((_b = this.room) === null || _b === void 0 ? void 0 : _b.myRangedAttackPower) || 0;
                    break;
                case HEAL:
                    power += ((_c = this.room) === null || _c === void 0 ? void 0 : _c.myHealPower) || 0;
                    break;
            }
        });
        return power;
    }
    npcPower(...types) {
        let power = 0;
        types.forEach(type => {
            var _a, _b, _c;
            switch (type) {
                case ATTACK:
                    power += ((_a = this.room) === null || _a === void 0 ? void 0 : _a.npcAttackPower) || this.roomMemoryV2.npcAttackPower || 0;
                    break;
                case RANGED_ATTACK:
                    power += ((_b = this.room) === null || _b === void 0 ? void 0 : _b.npcRangedAttackPower) || this.roomMemoryV2.npcRangedAttackPower || 0;
                    break;
                case HEAL:
                    power += ((_c = this.room) === null || _c === void 0 ? void 0 : _c.npcHealPower) || this.roomMemoryV2.npcHealPower || 0;
                    break;
            }
        });
        return power;
    }
    get hostileAttackPower() {
        var _a;
        return ((_a = this.room) === null || _a === void 0 ? void 0 : _a.hostileAttackPower) || this.roomMemoryV2.hostileAttackPower || 0;
    }
    get hostileHealPower() {
        var _a;
        return ((_a = this.room) === null || _a === void 0 ? void 0 : _a.hostileHealPower) || this.roomMemoryV2.hostileHealPower || 0;
    }
    get hostileRangedAttackPower() {
        var _a;
        return ((_a = this.room) === null || _a === void 0 ? void 0 : _a.hostileRangedAttackPower) || this.roomMemoryV2.hostileRangedAttackPower || 0;
    }
    get npcAttackPower() {
        var _a;
        return ((_a = this.room) === null || _a === void 0 ? void 0 : _a.npcAttackPower) || this.roomMemoryV2.npcAttackPower || 0;
    }
    get npcHealPower() {
        var _a;
        return ((_a = this.room) === null || _a === void 0 ? void 0 : _a.npcHealPower) || this.roomMemoryV2.npcHealPower || 0;
    }
    get npcRangedAttackPower() {
        var _a;
        return ((_a = this.room) === null || _a === void 0 ? void 0 : _a.npcRangedAttackPower) || this.roomMemoryV2.npcRangedAttackPower || 0;
    }
    get reservedUsername() {
        var _a, _b, _c;
        return ((_c = (_b = (_a = this.room) === null || _a === void 0 ? void 0 : _a.controller) === null || _b === void 0 ? void 0 : _b.reservation) === null || _c === void 0 ? void 0 : _c.username) || this.roomMemoryV2.reservationUsername;
    }
    get reservedEndsAt() {
        var _a, _b, _c;
        if ((_c = (_b = (_a = this.room) === null || _a === void 0 ? void 0 : _a.controller) === null || _b === void 0 ? void 0 : _b.reservation) === null || _c === void 0 ? void 0 : _c.ticksToEnd) {
            return Game.time + this.room.controller.reservation.ticksToEnd;
        }
        return this.roomMemoryV2.reservationEndsAt;
    }
    get updatedAt() {
        return this.roomMemoryV2.updatedAt || 0;
    }
    get sourceCount() {
        return this.roomMemoryV2.sourceCount;
    }
    get mineralType() {
        return this.roomMemoryV2.mineralType;
    }
    get canAttackStructures() {
        var _a, _b, _c, _d;
        if (this.room) {
            const ownerUsername = (_b = (_a = this.room.controller) === null || _a === void 0 ? void 0 : _a.owner) === null || _b === void 0 ? void 0 : _b.username;
            const reservationUsername = (_d = (_c = this.room.controller) === null || _c === void 0 ? void 0 : _c.reservation) === null || _d === void 0 ? void 0 : _d.username;
            return ((ownerUsername !== undefined && ownerUsername !== USERNAME.ME) ||
                (reservationUsername !== undefined && reservationUsername !== USERNAME.ME));
        }
        else {
            return ((this.ownerUsername && this.ownerUsername !== USERNAME.ME) ||
                (this.reservedUsername !== undefined && this.reservedUsername !== USERNAME.ME));
        }
    }
    /**
     * checks weather we should and is safe to be mined
     */
    get canBeMined() {
        if (!this.shouldBeMined) {
            return false;
        }
        // check if no hostile powers, check if sk and has defenders
        return this.shouldBeMined; // and calculate cpu per room if less then xx and sk
    }
    /**
     * checks weather we should mine it
     */
    get shouldBeMined() {
        const cpuPerRoom = Game.cpu.limit / Object.values(Game.rooms).filter(room => room.my).length;
        if (this.sourceCount === 0) {
            return false;
        }
        if (this.sourceCount === 1 && cpuPerRoom < 10) {
            return false;
        }
        if (this.sourceCount === 2 && cpuPerRoom < 8) {
            return false;
        }
        if (this.sourceCount === 3 && cpuPerRoom < 6) {
            return false;
        }
        return true;
    }
    static get(roomName) {
        if (!this.roomModels[roomName]) {
            this.roomModels[roomName] = new RoomModel(roomName);
        }
        return this.roomModels[roomName];
    }
    static init() {
        this.roomModels = {};
    }
}
RoomModel.roomModels = {};

const CacheKeys = {
    roomObstacles(roomName) {
        return `rooms.${roomName}.obstacles`;
    },
    roomRoads(roomName) {
        return `rooms.${roomName}.roads`;
    },
    roomPortals(roomName) {
        return `roms.${roomName}.portals`;
    },
    roomPathDistance(fromRoomName, toRoomName) {
        return `roms.${fromRoomName}.distance.${toRoomName}`;
    },
    roomMatrix(roomName) {
        return `rooms.${roomName}.matrix`;
    },
    isActive(id) {
        return `structures.${id}.isActive`;
    },
    roomQuadMatrix(roomName) {
        return `rooms.quad.${roomName}.matrix`;
    }
};

class Cache {
    static get(key) {
        var _a;
        return (_a = this._cache[key]) === null || _a === void 0 ? void 0 : _a.value;
    }
    static unset(key) {
        delete this._cache[key];
    }
    static remember(params) {
        if (params.forceUpdate ||
            !this._cache[params.key] ||
            this._cache[params.key].updateAt < Game.time ||
            this._cache[params.key].value === undefined) {
            this._cache[params.key] = {
                updateAt: Game.time + params.updatesIn,
                deleteAt: Game.time + params.expiresIn,
                value: params.value()
            };
        }
        return this._cache[params.key].value;
    }
    static init() {
        this.clearExpired();
        this.cacheRoomObstacles();
        this.cacheRoadPositions();
        this.cachePortals();
        this.cacheRoomMatrix();
    }
    static cacheRoomMatrix() {
        Object.values(Game.rooms).forEach(room => {
            const logs = room.getEventLog();
            this.remember({
                key: CacheKeys.roomMatrix(room.name),
                expiresIn: 20000,
                updatesIn: 10000,
                value: () => room.matrix(),
                forceUpdate: logs.filter(l => l.event === EVENT_OBJECT_DESTROYED).length > 0
            });
        });
    }
    static cachePortals() {
        // Object.values(Game.rooms).forEach(room => {
        //   this.remember<CacheTypes.RoomPortals>({
        //     key: CacheKeys.roomRoads(room.name),
        //     expiresIn: 10_000,
        //     updatesIn: 1_000,
        //     value: () => room.portals()
        //   });
        // });
    }
    static cacheRoadPositions() {
        // Object.values(Game.rooms).forEach(room => {
        //   this.remember<CacheTypes.RoomRoads>({
        //     key: CacheKeys.roomRoads(room.name),
        //     expiresIn: 5_000,
        //     updatesIn: 1_000,
        //     value: () => room.roadPositions()
        //   });
        // });
    }
    static cacheRoomObstacles() {
        // Object.values(Game.rooms).forEach(room => {
        //   const logs = room.getEventLog();
        //
        //   this.remember<CacheTypes.RoomObstacles>({
        //     key: CacheKeys.roomObstacles(room.name),
        //     expiresIn: 5_000,
        //     updatesIn: 100,
        //     value: () => room.obstaclePositions(),
        //     forceUpdate: logs.filter(l => l.event === EVENT_OBJECT_DESTROYED).length > 0
        //   });
        // });
    }
    static clearExpired() {
        for (const key in this._cache) {
            if (this._cache[key].deleteAt < Game.time) {
                delete this._cache[key];
            }
        }
    }
}
Cache._cache = {};

class Log {
    static room(room, ...messages) {
        const roomName = room instanceof Room ? room.name : room;
        const roomHtml = `<a href="https://screeps.com/a/#!/room/shard2/${roomName}">${roomName}</a>&nbsp;<small>(<a href="https://screeps.com/a/#!/history/shard2/${roomName}?t=${Game.time}">${Game.time}</a>)</small>`;
        console.log(roomHtml, messages.join(" "));
    }
    static objectType(obj) {
        if (obj instanceof Creep) {
            return `<span style="color: #0086ce;">creep <small>(${obj.id})</small></span>`;
        }
        if (obj instanceof PowerCreep) {
            return `<span style="color: #0052ce;">creep <small>(${obj.id})</small></span>`;
        }
        if (obj instanceof Source) {
            return `<span style="color: #ceb300;">source <small>(${obj.id})</small></span>`;
        }
        return `<span style="color: #07ce00;">${"structureType" in obj ? obj.structureType : "unknown"} <small>(${obj.id})</small></span>`;
    }
    static object(obj, ...messages) {
        if (obj.room) {
            this.room(obj.room, this.objectType(obj), ...messages);
        }
        else {
            console.log([this.objectType(obj), ...messages].join(" "));
        }
        const message = {
            message: messages.join(" "),
            endsAt: Game.time + 10
        };
        this.recentObjectLogs[obj.id]
            ? this.recentObjectLogs[obj.id].push(message)
            : (this.recentObjectLogs[obj.id] = [message]);
    }
    static deleteEnded() {
        for (const objId in this.recentObjectLogs) {
            this.recentObjectLogs[objId] = this.recentObjectLogs[objId].filter(log => log.endsAt > Game.time);
        }
    }
    static deleteEmptyObjectMessages() {
        for (const objId in this.recentObjectLogs) {
            if (this.recentObjectLogs[objId].length === 0) {
                delete this.recentObjectLogs[objId];
            }
        }
    }
    static drawObjectMessages() {
        for (const objId in this.recentObjectLogs) {
            const obj = Game.getObjectById(objId);
            if (!obj) {
                continue;
            }
            const messages = this.recentObjectLogs[objId];
            const visual = new RoomVisual(obj.pos.roomName);
            const displayHorizontal = obj.pos.x > 25 ? LEFT : RIGHT;
            const displayVertical = obj.pos.y > 25 ? TOP : BOTTOM;
            visual.line(obj.pos.x, obj.pos.y, obj.pos.x + (displayHorizontal === RIGHT ? 1 : -1), obj.pos.y + (displayVertical === TOP ? -1 : 1), {
                color: "#eeeeee",
                opacity: 0.5,
                width: 0.1
            });
            messages.forEach((message, index) => {
                visual
                    // .text(message.message, obj.pos.x + 1, obj.pos.y - 1 + index, {
                    //   // Fake message, used to align background (to make black border)
                    //   color: "black",
                    //   opacity: 0.9,
                    //   align: "left",
                    //   font: "bold 0.6 Arial",
                    //   backgroundColor: "black",
                    //   backgroundPadding: 0.3
                    // })
                    .text(message.message, obj.pos.x + (displayHorizontal === RIGHT ? 1 : -1), obj.pos.y + (displayVertical === TOP ? -1 : 1) + index, {
                    // Real message
                    color: "black",
                    opacity: 0.5,
                    align: displayHorizontal === LEFT ? "right" : "left",
                    font: "bold 0.6 Arial",
                    backgroundColor: "#eeeeee",
                    backgroundPadding: 0.2
                });
            });
            // new RoomVisual(obj.pos.roomName).text(message, obj.pos.x, General.between(0, 49, obj.pos.y - 1), {
            //   color: "#000",
            //   backgroundColor: "#fff",
            //   opacity: 0.5,
            //   align: "center"
            // });
        }
    }
    static exit() {
        this.deleteEnded();
        this.deleteEmptyObjectMessages();
        this.drawObjectMessages();
        // this.drawObjectMessages();
        // delete expired things
        // draw new things
    }
    static clearConsole() {
        console.log("<script>angular.element(document.getElementsByClassName('fa fa-trash ng-scope')[0].parentNode).scope().Console.clear()</script>");
    }
}
Log.recentObjectLogs = {};

const getCreepCpuTextColor = function (cpu) {
    if (cpu < 0.1) {
        return "#000";
    }
    return "#fff";
};
const getCreepCpuColor = function (cpu) {
    if (cpu < 0.1) {
        return "#fff";
    }
    if (cpu < 0.4) {
        return "#157a00";
    }
    if (cpu < 0.6) {
        return "#004ee3";
    }
    return "#a40101";
};
class General {
    constructor() {
        this.liveDebug = false;
    }
    static uniqueId() {
        const newId = (Memory.lastUniqueId || 0) + 1;
        Memory.lastUniqueId = newId;
        return newId;
    }
    static visualCreepCpu(creep, callback) {
        var _a, _b;
        const start = Game.cpu.getUsed();
        try {
            callback();
        }
        catch (e) {
            Log.object(creep, e);
        }
        const end = Game.cpu.getUsed();
        const cpuUsed = end - start;
        (_a = creep.room) === null || _a === void 0 ? void 0 : _a.visual.circle(creep.pos.x, creep.pos.y, {
            radius: 0.75,
            fill: "transparent",
            stroke: getCreepCpuColor(cpuUsed),
            strokeWidth: 0.2,
            opacity: 0.3
            // color: getCreepCpuTextColor(cpuUsed)
        });
        if (cpuUsed > 0.6) {
            (_b = creep.room) === null || _b === void 0 ? void 0 : _b.visual.text(cpuUsed.toFixed(2), creep.pos.x, creep.pos.y - 0.75 + 0.1, {
                font: 0.2,
                // stroke: getCreepCpuColor(cpuUsed),
                align: "center",
                color: getCreepCpuTextColor(cpuUsed)
            });
        }
    }
    static interval(interval, callback) {
        if (Game.time % interval !== 0)
            return;
        callback();
    }
    static get myRooms() {
        return Object.values(Game.rooms).filter(r => { var _a; return (_a = r.controller) === null || _a === void 0 ? void 0 : _a.my; });
    }
    static withingRoomRange(n) {
        return Math.min(49, Math.max(0, n));
    }
    static isWithinRoom(pos) {
        return pos.y <= 49 && pos.x <= 49 && pos.y >= 0 && pos.x >= 0;
    }
    static get myCompleteRoomCount() {
        if (!Memory.completeRoomCount || Memory.completeRoomCount.at < Game.time - 20000) {
            Memory.completeRoomCount = {
                v: Object.values(Game.rooms)
                    .filter(r => r.my)
                    .filter(r => r.level >= 8).length,
                at: Game.time
            };
        }
        return Memory.completeRoomCount.v;
    }
    static squareCoordinatesAround(centerX, centerY, range) {
        const coordinates = [];
        for (let i = -range; i <= range; i++) {
            if (this.isWithinRoom({ x: centerX + i, y: centerY - range })) {
                coordinates.push({ x: centerX + i, y: centerY - range });
            }
            if (this.isWithinRoom({ x: centerX + i, y: centerY + range })) {
                coordinates.push({ x: centerX + i, y: centerY + range });
            }
            if (Math.abs(i) !== range) {
                if (this.isWithinRoom({ x: centerX - range, y: centerY + i })) {
                    coordinates.push({ x: centerX - range, y: centerY + i });
                }
                if (this.isWithinRoom({ x: centerX + range, y: centerY + i })) {
                    coordinates.push({ x: centerX + range, y: centerY + i });
                }
            }
        }
        return coordinates;
    }
    static squareQuadCoordinatesAround(centerX, centerY, range) {
        const coordinates = [];
        for (let x = -range - 1; x <= range; x++) {
            for (let y = -range - 1; y <= range; y++) {
                if (this.isWithinRoom({ x: centerX + x, y: centerY + y })) {
                    coordinates.push({ x: centerX + x, y: centerY + y });
                }
            }
        }
        return coordinates;
    }
    static squarePositions(roomName, centerX, centerY, range) {
        const coordinates = [];
        for (let i = -range; i <= range; i++) {
            if (this.isWithinRoom({ x: centerX + i, y: centerY - range })) {
                coordinates.push(new RoomPosition(centerX + i, centerY - range, roomName));
            }
            if (this.isWithinRoom({ x: centerX + i, y: centerY + range })) {
                coordinates.push(new RoomPosition(centerX + i, centerY + range, roomName));
            }
            if (Math.abs(i) !== range) {
                if (this.isWithinRoom({ x: centerX - range, y: centerY + i })) {
                    coordinates.push(new RoomPosition(centerX - range, centerY + i, roomName));
                }
                if (this.isWithinRoom({ x: centerX + range, y: centerY + i })) {
                    coordinates.push(new RoomPosition(centerX + range, centerY + i, roomName));
                }
            }
        }
        return coordinates;
    }
    static quadSquareCoordinates(centerX, centerY, range) {
        const coordinates = [];
        for (let i = -range; i <= range; i++) {
            coordinates.push({ x: this.withingRoomRange(centerX + i), y: this.withingRoomRange(centerY - range - 1) });
            coordinates.push({ x: this.withingRoomRange(centerX + i - 1), y: this.withingRoomRange(centerY - range - 1) });
            coordinates.push({ x: this.withingRoomRange(centerX + i), y: this.withingRoomRange(centerY + range) });
            coordinates.push({ x: this.withingRoomRange(centerX + i - 1), y: this.withingRoomRange(centerY + range) });
            if (Math.abs(i) !== range) {
                coordinates.push({ x: this.withingRoomRange(centerX - range - 1), y: this.withingRoomRange(centerY + i) });
                coordinates.push({ x: this.withingRoomRange(centerX + range), y: this.withingRoomRange(centerY + i) });
                coordinates.push({ x: this.withingRoomRange(centerX - range - 1), y: this.withingRoomRange(centerY + i - 1) });
                coordinates.push({ x: this.withingRoomRange(centerX + range), y: this.withingRoomRange(centerY + i - 1) });
            }
        }
        return coordinates;
    }
    static squareCoordinatesFilled(roomName, centerX, centerY, range) {
        const coordinates = [new RoomPosition(centerX, centerY, roomName)];
        for (let i = 1; i <= range; i++) {
            coordinates.push(...this.squarePositions(roomName, centerX, centerY, i));
        }
        return coordinates;
    }
    static randomIntFromRange(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
    static towerDamage(pos1, pos2) {
        let distance = pos1.getRangeTo(pos2);
        let damage = TOWER_POWER_ATTACK;
        if (distance > TOWER_OPTIMAL_RANGE) {
            if (distance > TOWER_FALLOFF_RANGE) {
                distance = TOWER_FALLOFF_RANGE;
            }
            damage -=
                (damage * TOWER_FALLOFF * (distance - TOWER_OPTIMAL_RANGE)) / (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
        }
        return Math.floor(damage);
    }
    static between(min, max, theNumber) {
        if (theNumber > max) {
            return max;
        }
        if (theNumber < min) {
            return min;
        }
        return theNumber;
    }
    static cpuLeft() {
        return Game.cpu.tickLimit - Game.cpu.getUsed();
    }
    static random(chance, callback) {
        if (Math.random() > chance) {
            return;
        }
        callback();
    }
    static farmingGcl() {
        return Game.gcl.level < 60;
    }
    static focusingOnSkRooms() {
        return Game.gcl.level < 30;
    }
    static expansionWithSupport() {
        return this.myCompleteRoomCount >= 3;
    }
}

class Rooms {
    static model(roomName) {
        if (!this.roomModels[roomName]) {
            this.roomModels[roomName] = new RoomModel(roomName);
        }
        return this.roomModels[roomName];
    }
    static get visible() {
        return Object.values(Game.rooms);
    }
    static get myRooms() {
        if (this._myRooms === undefined) {
            this._myRooms = this.visible.filter(r => r.my);
        }
        return this._myRooms;
    }
    static get estimatedCpuPerRoom() {
        return Game.cpu.limit / Rooms.myRooms.length;
    }
    static get remoteMiningRooms() {
        const rooms = [];
        this.myRooms.forEach(homeRoom => {
            if (homeRoom.terminal && homeRoom.level < 8) {
                return;
            }
            if (homeRoom.isSiegeBase) {
                return;
            }
            if (!homeRoom.controller) {
                return;
            }
            if (homeRoom.isAbandoning) {
                return;
            }
            if (homeRoom.level === 8) {
                if (!homeRoom.myCenterPowerSpawn) {
                    return;
                }
                if (homeRoom.myActiveSpawns.length < 3) {
                    return;
                }
            }
            Object.values(Game.map.describeExits(homeRoom.name)).forEach(targetRoomName => {
                if (!targetRoomName) {
                    return;
                }
                const targetRoomModel = new RoomModel(targetRoomName);
                const homeRoomModel = new RoomModel(homeRoom.name);
                if (!targetRoomModel.shouldBeMined) {
                    return;
                }
                if (targetRoomModel.type !== RoomTypeEnum.STANDART) {
                    return;
                }
                if (targetRoomModel.ownerUsername) {
                    return;
                }
                if (targetRoomModel.reservedUsername &&
                    targetRoomModel.reservedUsername !== USERNAME.ME &&
                    targetRoomModel.reservedUsername !== USERNAME.INVADER) {
                    return;
                }
                rooms.push({ targetRoomModel, homeRoomModel });
                Object.values(Game.map.describeExits(targetRoomName)).forEach(targetRoomName2 => {
                    if (!targetRoomName2) {
                        return;
                    }
                    const targetRoomModel2 = new RoomModel(targetRoomName2);
                    if (!targetRoomModel2.shouldBeMined) {
                        return;
                    }
                    if (targetRoomModel2.type !== RoomTypeEnum.STANDART) {
                        return;
                    }
                    if (targetRoomModel2.ownerUsername) {
                        return;
                    }
                    if (targetRoomModel2.reservedUsername &&
                        targetRoomModel2.reservedUsername !== USERNAME.ME &&
                        targetRoomModel2.reservedUsername !== USERNAME.INVADER) {
                        return;
                    }
                    rooms.push({ targetRoomModel: targetRoomModel2, homeRoomModel });
                });
            });
        });
        return rooms;
    }
    static get skMiningRooms() {
        const rooms = [];
        this.myRooms.forEach(homeRoom => {
            Object.values(Game.map.describeExits(homeRoom.name)).forEach(targetRoomName => {
                if (!targetRoomName) {
                    return;
                }
                const targetRoomModel = new RoomModel(targetRoomName);
                const homeRoomModel = new RoomModel(homeRoom.name);
                if (targetRoomModel.type !== RoomTypeEnum.SK) {
                    return;
                }
                const stronghold = Memory.strongholds[targetRoomModel.roomName];
                if (stronghold && stronghold.isAlive) {
                    return;
                }
                if (stronghold && stronghold.startsAt && stronghold.startsAt > Game.time - CREEP_LIFE_TIME + 300) {
                    return;
                }
                rooms.push({ targetRoomModel, homeRoomModel });
            });
        });
        return rooms;
    }
    static matrix(roomName) {
        var _a;
        return (Cache.get(CacheKeys.roomMatrix(roomName)) || ((_a = Game.rooms[roomName]) === null || _a === void 0 ? void 0 : _a.matrix()) ||
            new PathFinder.CostMatrix()).clone();
    }
    static matrixReset(roomName) {
        Cache.unset(CacheKeys.roomMatrix(roomName));
        Cache.unset(CacheKeys.roomQuadMatrix(roomName));
    }
    static init() {
        this._myRooms = undefined;
        General.interval(5, () => this.unclaimRooms());
        General.interval(100, () => this.clearEndedUnclaimRooms());
    }
    static myRandomRoom(key) {
        const index = this.myRandomRoomIndex[key] || 0;
        let room = this.myRooms[index];
        if (room) {
            this.myRandomRoomIndex[key] = index + 1;
            return room;
        }
        room = this.myRooms[0];
        this.myRandomRoomIndex[key] = 0;
        return room;
    }
    static addUnclaimRoomIntent(roomName, ticks = 10000) {
        if (!Memory.unclaimRoomIntents) {
            Memory.unclaimRoomIntents = {};
        }
        if (Memory.unclaimRoomIntents[roomName]) {
            return;
        }
        Memory.unclaimRoomIntents[roomName] = {
            roomName,
            endsAt: Game.time + ticks
        };
    }
    static clearEndedUnclaimRooms() {
        if (!Memory.unclaimRoomIntents) {
            return;
        }
        for (const roomName in Memory.unclaimRoomIntents) {
            if (Memory.unclaimRoomIntents[roomName].endsAt > Game.time) {
                continue;
            }
            delete Memory.unclaimRoomIntents[roomName];
        }
    }
    static unclaimRooms() {
        var _a;
        if (!Memory.unclaimRoomIntents) {
            return;
        }
        for (const roomName in Memory.unclaimRoomIntents) {
            const room = Game.rooms[roomName];
            if (!room) {
                continue;
            }
            if (!room.controller) {
                continue;
            }
            if (room.controller.level > 1) {
                console.log("avoiding unclaiming room cause level is more then 1");
                continue;
            }
            if (((_a = room.controller.owner) === null || _a === void 0 ? void 0 : _a.username) !== USERNAME.ME) {
                continue;
            }
            if (room.find(FIND_HOSTILE_CREEPS).length > 0) {
                continue;
            }
            Log.room(room, "unclaiming room");
            room
                .find(FIND_STRUCTURES, {
                filter: s => s.hits &&
                    (s.structureType !== STRUCTURE_STORAGE || s.isWorthless) &&
                    (s.structureType !== STRUCTURE_TERMINAL || s.isWorthless) &&
                    s.structureType !== STRUCTURE_ROAD &&
                    s.structureType !== STRUCTURE_CONTAINER &&
                    (!(s instanceof OwnedStructure) || !s.my)
            })
                .forEach(s => s.destroy());
            const res = room.controller.unclaim();
            if (res === OK) {
                room.mem.safeModeCooldownEndsAt = Game.time + SAFE_MODE_COOLDOWN;
                room.mem.hitsDefenceBuildingCount = 0;
                room.mem.hitsDefenceBuildingAverageHits = 0;
                room.mem.hitsUpdatedAt = Game.time;
                Rooms.matrixReset(room.name);
                Memory.unclaimRoomIntents[roomName].endsAt = Game.time + 600;
            }
        }
    }
    static quadMatrix(roomName) {
        return (Cache.remember({
            key: CacheKeys.roomQuadMatrix(roomName),
            updatesIn: 100,
            expiresIn: 200,
            value: () => {
                const matrix = new PathFinder.CostMatrix();
                const room = Game.rooms[roomName];
                if (!room) {
                    return undefined;
                }
                const terrain = room.getTerrain();
                const OFFSETS = [
                    { x: 0, y: 0 },
                    { x: 1, y: 0 },
                    { x: 0, y: 1 },
                    { x: 1, y: 1 }
                ];
                const teoricalQuadPositions = function (leadX, leadY) {
                    const positions = [];
                    OFFSETS.forEach(o => {
                        const newX = leadX + o.x;
                        const newY = leadY + o.y;
                        if (newX < 0 || newX > 49) {
                            return;
                        }
                        if (newY < 0 || newY > 49) {
                            return;
                        }
                        positions.push({ x: newX, y: newY });
                    });
                    return positions;
                };
                const positionWouldHitSwamp = function (x, y) {
                    return !!teoricalQuadPositions(x, y).find(p => terrain.get(p.x, p.y) === TERRAIN_MASK_SWAMP);
                };
                const positionNotMovable = function (x, y) {
                    if (terrain.get(x, y) === TERRAIN_MASK_WALL) {
                        return true;
                    }
                    const findUnpassableObject = room.lookAt(x, y).find(look => {
                        if (look.structure && OBSTACLE_OBJECT_TYPES.includes(look.structure.structureType)) {
                            return true;
                        }
                        if (look.structure instanceof StructureRampart && !look.structure.my) {
                            return true;
                        }
                        return false;
                    });
                    return !!findUnpassableObject;
                };
                const quadWouldHitNotMovableObject = function (x, y) {
                    return teoricalQuadPositions(x, y).some(p => positionNotMovable(p.x, p.y));
                };
                for (let x = 0; x <= 49; x++) {
                    for (let y = 0; y <= 49; y++) {
                        if (positionNotMovable(x, y)) {
                            matrix.set(x, y, 255);
                            room.visual.circle(x, y, { radius: 0.3, fill: "#f00" });
                        }
                        else if (quadWouldHitNotMovableObject(x, y)) {
                            matrix.set(x, y, 255);
                            room.visual.circle(x, y, { radius: 0.3, fill: "#ff5900" });
                        }
                        else if (x < 1 || y < 1 || x > 47 || y > 47) {
                            matrix.set(x, y, 20);
                            room.visual.circle(x, y, { radius: 0.3, fill: "#0f0" });
                        }
                        else if (positionWouldHitSwamp(x, y)) {
                            matrix.set(x, y, 10);
                            // room.visual.circle(x, y, { radius: 0.3, fill: "#00f" });
                        }
                    }
                }
                return matrix;
            }
        }) || new PathFinder.CostMatrix()).clone();
    }
    static get memoryObjectRooms() {
        if (!this._allMemoryRoomObjectsLoaded) {
            const rooms = Memory.roomsV2 || {};
            for (const roomName in rooms) {
                this._allMemoryRoomObjects[roomName] = this.memory(roomName);
            }
            this._allMemoryRoomObjectsLoaded = true;
        }
        return this._allMemoryRoomObjects;
    }
    static get memoryObjectRoomValues() {
        return Object.values(this.memoryObjectRooms);
    }
    static memory(roomName) {
        if (this._allMemoryRoomObjects[roomName] === undefined) {
            this._allMemoryRoomObjects[roomName] = new RoomMemoryObject(roomName);
        }
        return this._allMemoryRoomObjects[roomName];
    }
    static whenVisible(roomName, callback) {
        if (!this.whenVisibleCallbacks[roomName]) {
            this.whenVisibleCallbacks[roomName] = [];
        }
        this.whenVisibleCallbacks[roomName].push(callback);
    }
    static runVisibleCallbacks(room) {
        if (!this.whenVisibleCallbacks[room.name]) {
            return;
        }
        this.whenVisibleCallbacks[room.name].forEach(callback => callback(room));
        delete this.whenVisibleCallbacks[room.name];
    }
}
Rooms.roomModels = {};
Rooms._myRooms = undefined;
Rooms._allMemoryRoomObjects = {};
Rooms._allMemoryRoomObjectsLoaded = false;
Rooms.myRandomRoomIndex = {};
Rooms.whenVisibleCallbacks = {};

const BLOCKLIST_ROOMS = ["E43S56", "E43S22"];
const ROUTE_CACHE_TIME = 30000;
const ROUTE_CACHE_UPDATE_TIME = 15000;
class Geo {
    static roomXYToName(x, y) {
        let roomName = "";
        if (x < 0) {
            roomName += "W" + String(-x - 1);
        }
        else {
            roomName += "E" + String(x);
        }
        if (y < 0) {
            roomName += "N" + String(-y - 1);
        }
        else {
            roomName += "S" + String(y);
        }
        return roomName;
    }
    static roomNameToXY(roomName) {
        let xx = parseInt(roomName.substr(1), 10);
        let verticalPos = 2;
        if (xx >= 100) {
            verticalPos = 4;
        }
        else if (xx >= 10) {
            verticalPos = 3;
        }
        let yy = parseInt(roomName.substr(verticalPos + 1), 10);
        const horizontalDir = roomName.charAt(0);
        const verticalDir = roomName.charAt(verticalPos);
        if (horizontalDir === "W" || horizontalDir === "w") {
            xx = -xx - 1;
        }
        if (verticalDir === "N" || verticalDir === "n") {
            yy = -yy - 1;
        }
        return [xx, yy];
    }
    static towersDamage(pos, towerPositions) {
        return _.sum(towerPositions, tower => {
            let r = pos.getRangeTo(tower);
            let amount = TOWER_POWER_ATTACK;
            if (r > TOWER_OPTIMAL_RANGE) {
                if (r > TOWER_FALLOFF_RANGE) {
                    r = TOWER_FALLOFF_RANGE;
                }
                amount -= (amount * TOWER_FALLOFF * (r - TOWER_OPTIMAL_RANGE)) / (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
            }
            return Math.floor(amount);
        });
    }
    static roomEdges(thickness = 1) {
        const positions = [];
        for (let off = 0; off <= 49; off++) {
            for (let thick = 0; thick < thickness; thick++) {
                positions.push({ x: off, y: 49 - thick });
                positions.push({ x: off, y: 0 + thick });
            }
        }
        for (let off = thickness; off <= 49 - thickness; off++) {
            for (let thick = 0; thick < thickness; thick++) {
                positions.push({ x: 49 - thick, y: off });
                positions.push({ x: 0 + thick, y: off });
            }
        }
        return positions;
    }
    static closestHomeRoomsByRange(targetRoomName, count = 1, options) {
        const targetRoomStatus = Game.map.getRoomStatus(targetRoomName).status;
        return Object.values(Game.rooms)
            .filter(room => {
            if (!room.my) {
                return false;
            }
            const roomStatus = Game.map.getRoomStatus(room.name).status;
            if (roomStatus !== targetRoomStatus) {
                return false;
            }
            if (options === null || options === void 0 ? void 0 : options.maxDistance) {
                if (Game.map.getRoomLinearDistance(room.name, targetRoomName) > options.maxDistance) {
                    return false;
                }
            }
            if (options) {
                if (options.minLevel && room.controller && room.controller.level < options.minLevel) {
                    return false;
                }
                if (options.isSiegeBase !== undefined && options.isSiegeBase !== room.isSiegeBase) {
                    return false;
                }
                if (options.storage) {
                    if (!room.storage) {
                        return false;
                    }
                    if (!options.storage(room.storage)) {
                        return false;
                    }
                }
                if (options.room) {
                    if (!options.room(room)) {
                        return false;
                    }
                }
            }
            if (room.name === targetRoomName) {
                return true;
            }
            const route = this.findRouteCached(room.name, targetRoomName);
            if (route.length === 0) {
                // console.log("length is null");
                return false;
            }
            if ((options === null || options === void 0 ? void 0 : options.maxDistance) && route.length - 2 > options.maxDistance) {
                return false;
            }
            return true;
        })
            .sort((a, b) => this.findRouteCached(a.name, targetRoomName).length - this.findRouteCached(b.name, targetRoomName).length)
            .slice(0, count);
    }
    static closestHomeRoomByRange(targetRoomName, options) {
        return this.closestHomeRoomsByRange(targetRoomName, 1, options)[0] || null;
    }
    static findRouteCached(fromRoomName, toRoomName) {
        if (!Memory.routes) {
            Memory.routes = {};
        }
        const routeKey = fromRoomName + toRoomName;
        const routeKeyReverse = toRoomName + fromRoomName;
        const cachedRoute = Memory.routes[routeKey] || Memory.routes[routeKeyReverse];
        if (cachedRoute &&
            (cachedRoute.createdAt > Game.time - ROUTE_CACHE_UPDATE_TIME || this.routesRecalculatedInTick > 10)) {
            return cachedRoute.rooms;
        }
        Memory.routes[routeKey] = {
            createdAt: Game.time,
            rooms: this.findRoute(fromRoomName, toRoomName)
        };
        return Memory.routes[routeKey].rooms;
    }
    static resetRoutesContaining(roomName) {
        if (!Memory.routes) {
            Memory.routes = {};
        }
        console.log("GEO", "resetting routes containing room", roomName);
        for (const key in Memory.routes) {
            if (!Memory.routes[key].rooms.includes(roomName)) {
                continue;
            }
            delete Memory.routes[key];
            console.log("GEO", "removing route", key);
        }
    }
    static findRoute(fromRoomName, toRoomName) {
        this.routesRecalculatedInTick++;
        const options = {
            highway: 1,
            standard: 1,
            crossroad: 1,
            sk: 2
        };
        const fromRoom = Rooms.memory(fromRoomName);
        const route = Game.map.findRoute(fromRoomName, toRoomName, {
            routeCallback: (roomName) => {
                if (roomName === fromRoomName || roomName === toRoomName) {
                    return 1;
                }
                if (BLOCKLIST_ROOMS.includes(roomName)) {
                    return Infinity;
                }
                const roomMem = Rooms.memory(roomName);
                if (roomMem.status === "closed") {
                    return Infinity;
                }
                if (roomMem.status !== fromRoom.status && (roomMem.status === "respawn" || fromRoom.status === "respawn")) {
                    return Infinity;
                }
                if (!BLACKLIST_ROOMS.includes(toRoomName) && BLACKLIST_ROOMS.includes(roomName)) {
                    return Infinity;
                }
                const wallsMultiplier = (roomMem.terrainWallsCount || 0) / (49 * 49) + 1;
                const swampMultiplier = (roomMem.terrainSwampsCount || 0) / (49 * 49) / 2 + 1;
                const terrainMultiplier = wallsMultiplier * swampMultiplier;
                if (roomMem.type === RoomTypeEnum.HIGHWAY) {
                    return options.highway * terrainMultiplier;
                }
                if (roomMem.type === RoomTypeEnum.CROSSROAD) {
                    return options.crossroad * terrainMultiplier;
                }
                if (roomMem.type === RoomTypeEnum.STANDART) {
                    const room = Game.rooms[roomName];
                    if (room && room.my) {
                        return options.standard * terrainMultiplier;
                    }
                    if (roomName !== fromRoomName &&
                        roomName !== toRoomName &&
                        (roomMem.towerCount || 0) >= 1 &&
                        roomMem.ownerUsername &&
                        roomMem.ownerUsername !== USERNAME.ME) {
                        return Infinity;
                    }
                    return options.standard * terrainMultiplier;
                }
                if (roomMem.type === RoomTypeEnum.SK) {
                    const stronhgold = Memory.strongholds[roomName];
                    if (stronhgold && stronhgold.isAlive) {
                        return Infinity;
                    }
                    return options.sk * terrainMultiplier;
                }
                return 1;
            }
        });
        if (route === ERR_NO_PATH) {
            console.log(`couldn't findRoute from ${fromRoomName} to ${toRoomName}`);
            return [];
        }
        route.forEach((r, index, arr) => {
            if (!arr[index + 1])
                return;
            const start = new RoomPosition(25, 25, r.room);
            const end = new RoomPosition(25, 25, arr[index + 1].room);
            Game.map.visual.line(start, end, { width: 6, color: "#fff" });
        });
        const simpleRoute = route.map(r => r.room);
        simpleRoute.push(toRoomName);
        simpleRoute.unshift(fromRoomName);
        return simpleRoute;
    }
    static getPathCost(pos1, pos2, range) {
        let route = [];
        if (pos1.roomName !== pos2.roomName) {
            route = Geo.findRouteCached(pos1.roomName, pos2.roomName);
        }
        const ret = PathFinder.search(pos1, { pos: pos2, range }, {
            maxRooms: 64,
            roomCallback(roomName) {
                if (route.length && roomName !== pos1.roomName && roomName !== pos2.roomName) {
                    if (!route.includes(roomName)) {
                        return false;
                    }
                }
                return Rooms.matrix(roomName);
            }
        });
        return ret.path.length;
    }
    static exit() {
        this.routesRecalculatedInTick = 0;
        General.interval(500, () => this.clearPaths());
    }
    static clearPaths() {
        if (!Memory.routes) {
            return;
        }
        for (const routeKey in Memory.routes) {
            if (Memory.routes[routeKey].createdAt > Game.time - ROUTE_CACHE_TIME) {
                continue;
            }
            delete Memory.routes[routeKey];
        }
    }
    static globalRoomPosition(roomName, x, y) {
        const roomCoordinates = this.roomNameToXY(roomName);
        if (x >= 50) {
            x -= 50;
            roomCoordinates[0] += 1;
        }
        else if (x < 0) {
            x += 50;
            roomCoordinates[0] -= 1;
        }
        if (y >= 50) {
            y -= 50;
            roomCoordinates[1] += 1;
        }
        else if (y < 0) {
            y += 50;
            roomCoordinates[1] -= 1;
        }
        return new RoomPosition(x, y, this.roomXYToName(roomCoordinates[0], roomCoordinates[1]));
    }
    static findRoomsInRange(name, range) {
        const rooms = [];
        const [centerX, centerY] = this.roomNameToXY(name);
        for (let x = -range; x < range; x++) {
            for (let y = -range; y < range; y++) {
                const roomName = this.roomXYToName(centerX + x, centerY + y);
                const memory = Rooms.memory(roomName);
                if (memory) {
                    rooms.push(memory);
                }
            }
        }
        return rooms;
    }
    static resetRoutesContainingBlacklisted() {
        BLACKLIST_ROOMS.forEach(roomName => this.resetRoutesContaining(roomName));
    }
}
Geo.routesRecalculatedInTick = 0;

class WorldPosition {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    static fromRoomPosition(pos) {
        let { x, y } = pos;
        // @ts-ignore
        const [name, h, wx, v, wy] = /^([WE])([0-9]+)([NS])([0-9]+)$/.exec(pos.roomName);
        if (h === "W") {
            x = ~x;
        }
        if (v === "N") {
            y = ~y;
        }
        // @ts-ignore
        return new WorldPosition(50 * wx + x, 50 * wy + y);
    }
    static fromWorldXY(worldX, worldY) {
        return new WorldPosition(worldX, worldY);
    }
    getRangeTo(point) {
        return Math.max(Math.abs(this.x - point.x), Math.abs(this.y - point.y));
    }
    get pos() {
        if (this._roomPosition === undefined) {
            this._roomPosition = new RoomPosition(this.x % 50, this.y % 50, this.roomName);
        }
        return this._roomPosition;
    }
    get roomName() {
        return WorldPosition.getRoomName(this.x, this.y);
    }
    static getRoomName(worldX, worldY) {
        const x = Math.floor(worldX / 50);
        const y = Math.floor(worldY / 50);
        let roomName = "";
        if (x < 0) {
            roomName += "W" + String(-x - 1);
        }
        else {
            roomName += "E" + String(x);
        }
        if (y < 0) {
            roomName += "N" + String(-y - 1);
        }
        else {
            roomName += "S" + String(y);
        }
        return roomName;
    }
    get roomType() {
        const parsed = this.roomName.match(/\d+/g);
        if (!parsed) {
            console.log("failed to parse", this.roomName, "is not a room name");
            return RoomTypeEnum.STANDART;
        }
        const [EW, NS] = parsed;
        if (Number(EW) % 10 === 0 && Number(NS) % 10 === 0) {
            return RoomTypeEnum.CROSSROAD;
        }
        else if (Number(EW) % 10 === 0 || Number(NS) % 10 === 0) {
            return RoomTypeEnum.HIGHWAY;
        }
        else if (Number(EW) % 5 === 0 && Number(NS) % 5 === 0) {
            return RoomTypeEnum.CENTER;
        }
        else if (Math.abs(5 - (Number(EW) % 10)) <= 1 && Math.abs(5 - (Number(NS) % 10)) <= 1) {
            return RoomTypeEnum.SK;
        }
        else {
            return RoomTypeEnum.STANDART;
        }
    }
    getOffset(xOffset, yOffset) {
        return WorldPosition.fromWorldXY(this.x + xOffset, this.y + yOffset);
    }
}

class Constructor {
    /**
     * Checks wather room can build more Structures of type
     */
    static roomCanBuildMore(room, structure, amount = 1) {
        var _a;
        const level = ((_a = room.controller) === null || _a === void 0 ? void 0 : _a.level) || 0;
        const maxStructures = CONTROLLER_STRUCTURES[structure][level] || 0;
        const currentBuildings = room.find(FIND_STRUCTURES).filter(s => s.structureType === structure);
        const currentConstructions = room.find(FIND_CONSTRUCTION_SITES).filter(s => s.structureType === structure);
        const currenlyInUseCount = currentBuildings.length + currentConstructions.length;
        return maxStructures - currenlyInUseCount >= amount;
    }
    /**
     * Checks weather can have more construction sites
     */
    static canBuildMore(amount = 1) {
        return MAX_CONSTRUCTION_SITES - Constructor.totalCurrentConstruction() > amount;
    }
    static createConstructionSite(room, newX, newY, structure) {
        const response = room.createConstructionSite(newX, newY, structure);
        if (response === OK) {
            Constructor.addPendingConstructionSite(structure);
        }
        return response === OK;
    }
    static totalCurrentConstruction() {
        return Object.keys(Game.constructionSites).length + Constructor.pendingConstructionSites;
    }
    static addPendingConstructionSite(structure) {
        if (Game.time === Constructor.tick) {
            Constructor.pendingConstructionSites++;
            Constructor.pendingConstructionTypes[structure] = (Constructor.pendingConstructionTypes[structure] || 0) + 1;
        }
        else {
            Constructor.tick = Game.time;
            Constructor.pendingConstructionSites = 0;
            Constructor.pendingConstructionTypes = {
                [structure]: 1
            };
        }
    }
}
Constructor.tick = 0;
Constructor.pendingConstructionSites = 0;
Constructor.pendingConstructionTypes = {};

class TickCache {
    static init() {
        this.data = {};
    }
    static cache(options) {
        if (this.data[options.key] === undefined) {
            this.data[options.key] = options.callback();
        }
        // @ts-ignore
        return this.data[options.key];
    }
}
TickCache.data = {};

const STRUCTURES_BLOCKING_PATH = [
    STRUCTURE_SPAWN,
    STRUCTURE_WALL,
    STRUCTURE_EXTENSION,
    STRUCTURE_LINK,
    STRUCTURE_STORAGE,
    STRUCTURE_TOWER,
    STRUCTURE_OBSERVER,
    STRUCTURE_POWER_SPAWN,
    STRUCTURE_LAB,
    STRUCTURE_TERMINAL,
    STRUCTURE_NUKER,
    STRUCTURE_FACTORY,
    STRUCTURE_INVADER_CORE
];
RoomPosition.prototype.getOpenSpots = function (range) {
    const room = Game.rooms[this.roomName];
    if (!room) {
        return [];
    }
    const terrain = room.getTerrain();
    return General.squareCoordinatesAround(this.x, this.y, range)
        .map(p => new RoomPosition(p.x, p.y, this.roomName))
        .filter(pos => {
        if (terrain.get(pos.x, pos.y) === TERRAIN_MASK_WALL) {
            return false;
        }
        const structures = pos.lookFor(LOOK_STRUCTURES);
        for (const structure of structures) {
            if (structure instanceof StructureContainer) {
                continue;
            }
            if (structure instanceof StructureRoad) {
                continue;
            }
            if (structure instanceof StructureRampart && structure.my) {
                continue;
            }
            return false;
        }
        return true;
    });
};
RoomPosition.prototype.quadCoordinatesAround = function (range) {
    return General.squareQuadCoordinatesAround(this.x, this.y, range).map(p => ({ x: p.x, y: p.y }));
};
RoomPosition.prototype.isPosReachable = function (pos) {
    const path = this.findPathTo(pos, { maxRooms: 1, ignoreCreeps: false, plainCost: 1, swampCost: 1 });
    if (path.length === 0) {
        return false;
    }
    const lastStep = path[path.length - 1];
    if (!lastStep) {
        return false;
    }
    return pos.isNearTo(lastStep.x, lastStep.y);
};
RoomPosition.prototype.createRoadConstructionsFrom = function (from, opts) {
    if (!Constructor.canBuildMore()) {
        return;
    }
    const route = Geo.findRouteCached(from.roomName, this.roomName);
    if (route.length === 0) {
        return;
    }
    const pathFinder = PathFinder.search(this, from, {
        swampCost: 6,
        plainCost: 3,
        maxOps: 20000,
        roomCallback: (roomName) => {
            if (!route.includes(roomName)) {
                return false;
            }
            const roomModel = RoomModel.get(roomName);
            if (roomName !== this.roomName && roomName !== from.roomName) {
                if (roomModel.ownerUsername && roomModel.ownerUsername !== USERNAME.ME) {
                    return false;
                }
            }
            const room = Game.rooms[roomName];
            if (!room) {
                return false;
            }
            const matrix = room.matrix({
                storageCost: 1
            });
            matrix.set(this.x, this.y, 1);
            room.find(FIND_STRUCTURES).forEach(s => {
                if (s.structureType === STRUCTURE_CONTAINER) {
                    matrix.set(s.pos.x, s.pos.y, 20);
                }
                if (s.structureType === STRUCTURE_KEEPER_LAIR) {
                    const terrain = room.getTerrain();
                    General.squareCoordinatesFilled(s.pos.roomName, s.pos.x, s.pos.y, 2).forEach(p => {
                        if (terrain.get(p.x, p.y) === TERRAIN_MASK_WALL) {
                            return;
                        }
                        matrix.set(p.x, p.y, 5);
                    });
                }
            });
            room.find(FIND_MY_CONSTRUCTION_SITES).forEach(s => {
                if (s.structureType === STRUCTURE_CONTAINER) {
                    matrix.set(s.pos.x, s.pos.y, 20);
                }
                if (s.structureType === STRUCTURE_ROAD) {
                    matrix.set(s.pos.x, s.pos.y, 1);
                }
            });
            if (opts === null || opts === void 0 ? void 0 : opts.costCallback) {
                opts.costCallback(room, matrix);
            }
            return matrix;
        }
    });
    if (pathFinder.incomplete) {
        Log.room(this.roomName, "Cant build remote roads, path incomplete", route.join(", "));
        return;
    }
    if (opts === null || opts === void 0 ? void 0 : opts.containerOnPos) {
        const room = Game.rooms[this.roomName];
        if (room) {
            Constructor.createConstructionSite(room, this.x, this.y, (opts === null || opts === void 0 ? void 0 : opts.structureType) || STRUCTURE_CONTAINER);
        }
    }
    pathFinder.path.forEach((pos, index, paths) => {
        const posRoom = Game.rooms[pos.roomName];
        if (!posRoom) {
            return;
        }
        if (index === 0 && !(opts === null || opts === void 0 ? void 0 : opts.containerOnPos)) {
            if ((opts === null || opts === void 0 ? void 0 : opts.structureType) !== null) {
                Constructor.createConstructionSite(posRoom, pos.x, pos.y, (opts === null || opts === void 0 ? void 0 : opts.structureType) || STRUCTURE_CONTAINER);
            }
            Game.rooms[pos.roomName].visual.circle(pos.x, pos.y, { fill: "#fff", radius: 0.4 });
            return;
        }
        if (index === paths.length - 1) {
            return;
        }
        const room = Game.rooms[pos.roomName];
        if (!room) {
            return;
        }
        if (pos.road) {
            return;
        }
        Game.rooms[pos.roomName].visual.circle(pos.x, pos.y, { fill: "#fff", radius: 0.1 });
        Constructor.createConstructionSite(posRoom, pos.x, pos.y, STRUCTURE_ROAD);
    });
};
Object.defineProperty(RoomPosition.prototype, "openSpotsRange2", {
    get() {
        const roomPosition = this;
        if (roomPosition._openSpotsRange2 === undefined) {
            roomPosition._openSpotsRange2 = roomPosition.getOpenSpots(2);
        }
        return roomPosition._openSpotsRange2;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(RoomPosition.prototype, "openSpots", {
    get() {
        const roomPosition = this;
        if (roomPosition._openSpots === undefined) {
            const offsets = [
                [-1, -1],
                [-1, 0],
                [-1, 1],
                [0, -1],
                [0, 0],
                [0, 1],
                [1, -1],
                [1, 0],
                [1, 1]
            ];
            roomPosition._openSpots = offsets
                .filter(([xOffset, yOffset]) => roomPosition.x + xOffset > 0 &&
                roomPosition.x + xOffset < 49 &&
                roomPosition.y + yOffset > 0 &&
                roomPosition.y + yOffset < 49)
                .map(([xOffset, yOffset]) => new RoomPosition(roomPosition.x + xOffset, roomPosition.y + yOffset, roomPosition.roomName))
                .filter(pos => pos.lookFor(LOOK_TERRAIN).filter(terrain => terrain === "wall").length === 0)
                .filter(pos => {
                const structures = pos.lookFor(LOOK_STRUCTURES);
                for (const structure of structures) {
                    if (structure instanceof StructureController) {
                        continue;
                    }
                    if (structure instanceof StructureContainer) {
                        continue;
                    }
                    if (structure instanceof StructureRoad) {
                        continue;
                    }
                    if (structure instanceof StructureRampart && structure.my) {
                        continue;
                    }
                    return false;
                }
                return true;
            });
        }
        return roomPosition._openSpots;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(RoomPosition.prototype, "wpos", {
    get() {
        const roomPosition = this;
        if (roomPosition._wpos === undefined) {
            roomPosition._wpos = WorldPosition.fromRoomPosition(roomPosition);
        }
        return roomPosition._wpos;
    },
    configurable: true,
    enumerable: false
});
Object.defineProperty(RoomPosition.prototype, "hasRampart", {
    get() {
        const roomPosition = this;
        if (roomPosition._hasRampart === undefined) {
            roomPosition._hasRampart =
                roomPosition.lookFor(LOOK_STRUCTURES).filter(s => s.structureType === STRUCTURE_RAMPART).length > 0;
        }
        return roomPosition._hasRampart;
    },
    configurable: true,
    enumerable: false
});
Object.defineProperty(RoomPosition.prototype, "creep", {
    get() {
        const roomPosition = this;
        if (roomPosition._creep === undefined) {
            roomPosition._creep = roomPosition.lookFor(LOOK_CREEPS)[0] || null;
        }
        return roomPosition._creep;
    },
    configurable: true,
    enumerable: false
});
Object.defineProperty(RoomPosition.prototype, "hasCreep", {
    get() {
        const roomPosition = this;
        if (roomPosition._hasCreep === undefined) {
            roomPosition._hasCreep = !!roomPosition.creep;
        }
        return roomPosition._hasCreep;
    },
    configurable: true,
    enumerable: false
});
Object.defineProperty(RoomPosition.prototype, "isRoomEdge", {
    get() {
        const roomPosition = this;
        if (roomPosition._isRoomEdge === undefined) {
            roomPosition._isRoomEdge =
                roomPosition.x === 49 || roomPosition.x === 0 || roomPosition.y === 49 || roomPosition.y === 0;
        }
        return roomPosition._isRoomEdge;
    },
    configurable: true,
    enumerable: false
});
Object.defineProperty(RoomPosition.prototype, "hasPortal", {
    get() {
        const roomPosition = this;
        if (roomPosition._hasPortal === undefined) {
            roomPosition._hasPortal =
                roomPosition.lookFor(LOOK_STRUCTURES).filter(s => s.structureType === STRUCTURE_PORTAL).length > 0;
        }
        return roomPosition._hasPortal;
    },
    configurable: true,
    enumerable: false
});
Object.defineProperty(RoomPosition.prototype, "hasImpassableStructure", {
    get() {
        const roomPosition = this;
        if (roomPosition._hasImpassableStructure === undefined) {
            roomPosition._hasImpassableStructure =
                roomPosition.lookFor(LOOK_STRUCTURES).filter(s => {
                    if (STRUCTURES_BLOCKING_PATH.includes(s.structureType)) {
                        return true;
                    }
                    return s instanceof StructureRampart && !s.my && !s.isPublic;
                }).length > 0;
        }
        return roomPosition._hasImpassableStructure;
    },
    configurable: true,
    enumerable: false
});
RoomPosition.prototype.getPreciseRangeTo = function (target) {
    const pos = target instanceof RoomPosition ? target : target.pos;
    const y = this.y - pos.y;
    const x = this.x - pos.x;
    return Math.sqrt(x * x + y * y);
};
Object.defineProperty(RoomPosition.prototype, "road", {
    get() {
        const roomPosition = this;
        if (roomPosition._road === undefined) {
            roomPosition._road = (roomPosition.lookFor(LOOK_STRUCTURES).filter(s => s.structureType === STRUCTURE_ROAD)[0] ||
                null);
        }
        return roomPosition._road;
    },
    configurable: true,
    enumerable: false
});
Object.defineProperty(RoomPosition.prototype, "rampart", {
    get() {
        const roomPosition = this;
        if (roomPosition._rampart === undefined) {
            roomPosition._rampart = (roomPosition
                .lookFor(LOOK_STRUCTURES)
                .filter(s => s.structureType === STRUCTURE_RAMPART)[0] || null);
        }
        return roomPosition._rampart;
    },
    configurable: true,
    enumerable: false
});
Object.defineProperty(RoomPosition.prototype, "construction", {
    get() {
        const roomPosition = this;
        if (roomPosition._construction === undefined) {
            roomPosition._construction = roomPosition.lookFor(LOOK_CONSTRUCTION_SITES)[0] || null;
        }
        return roomPosition._construction;
    },
    configurable: true,
    enumerable: false
});
RoomPosition.prototype.inRangeToEdge = function (range) {
    return this.x >= 49 - range || this.x <= 0 + range || this.y >= 49 - range || this.y <= 0 + range;
};
RoomPosition.prototype.isEqualToWithEdges = function (pos) {
    return this.isEqualTo(pos) || ((this.isRoomEdge || pos.isRoomEdge) && this.wpos.getRangeTo(pos.wpos) <= 1);
};
RoomPosition.prototype.getQuadDirectionTo = function (pos) {
    const dx = pos.wpos.x - this.wpos.x;
    const dy = pos.wpos.y - this.wpos.y;
    const adx = Math.abs(dx) + 0.5;
    const ady = Math.abs(dy) + 0.5;
    if (adx >= ady) {
        if (dx > 0) {
            return RIGHT;
        }
        else {
            return LEFT;
        }
    }
    else {
        if (dy > 0) {
            return BOTTOM;
        }
        else {
            return TOP;
        }
    }
};
Object.defineProperty(RoomPosition.prototype, "hasStructureObstacle", {
    get() {
        const roomPosition = this;
        return TickCache.cache({
            key: `RoomPosition.${roomPosition.roomName}.${roomPosition.x}.${roomPosition.y}.hasStructureObstacle`,
            callback: () => {
                return (roomPosition
                    .lookFor(LOOK_STRUCTURES)
                    .filter(s => OBSTACLE_OBJECT_TYPES.includes(s.structureType)).length > 0);
            }
        });
    },
    configurable: true,
    enumerable: false
});

class Traveler {
    constructor(creep, target, opts) {
        this.creep = creep;
        this.target = target;
        this.options = Object.assign({ range: 1, costRoad: 1, costPlain: 2, costSwamp: 10, costRoomSk: 2, costRoomStandart: 1, costRoomHighway: 1, ignoreCreeps: true, ignoreHostiles: true, freshPath: false, obstacles: [], logIncomplete: false, withoutRoute: false, cache: false }, opts);
    }
    get creepTravel() {
        return Traveler.creepTravels[this.creep.name];
    }
    set creepTravel(value) {
        Traveler.creepTravels[this.creep.name] = value;
    }
    resetIfHostileClose() {
        if (!this.creepTravel) {
            return;
        }
        if (this.options.ignoreHostiles) {
            return;
        }
        const hostiles = this.creep.pos.findInRange(FIND_HOSTILE_CREEPS, 5, {
            filter: c => c.rangedAttackPower + c.attackPower > 0
        });
        if (hostiles.length === 0) {
            return;
        }
        this.resetCreepTravel();
    }
    resetCreepTravel() {
        // this.creep.say("(*)");
        this.creepTravel = undefined;
    }
    resetIfTargetChanged() {
        if (!this.creepTravel)
            return;
        if (this.creepTravel.targetPos.isEqualTo(this.target.pos)) {
            return;
        }
        this.resetCreepTravel();
    }
    move() {
        if (this.creep.pos.inRangeTo(this.target.pos, this.options.range)) {
            return false;
        }
        this.touchCreepTravel();
        if ("fatigue" in this.creep && this.creep.fatigue > 0) {
            new RoomVisual(this.creep.pos.roomName).circle(this.creep.pos, {
                radius: 0.45,
                fill: "transparent",
                stroke: "aqua",
                strokeWidth: 0.15,
                opacity: 0.3
            });
            return true;
        }
        // if option and enemy close - repath
        // if option add matrix to path
        this.resetIfTargetChanged();
        this.resetIfHostileClose();
        const res = this.handleNextPointPortal() || this.handleStuck() || this.moveFromMemory() || this.createNewPathAndMove();
        // if (this.creepTravel?.pathFinder.path) {
        //   for (let i = 0; i < this.creepTravel.pathFinder.path.length; i++) {
        //     const prev = this.creepTravel.pathFinder.path[i - 1];
        //     const next = this.creepTravel.pathFinder.path[i];
        //
        //     if (!prev || !next || prev.roomName !== next.roomName) continue;
        //
        //     new RoomVisual(prev.roomName).line(prev, next, { color: "#fff" });
        //   }
        // }
        return res;
    }
    handleNextPointPortal() {
        if (!this.nextPathFinderPosition) {
            return false;
        }
        if (this.nextPathFinderPosition.isEqualTo(this.target.pos)) {
            return false;
        }
        if (this.nextPathFinderPosition.lookFor(LOOK_STRUCTURES).filter(s => s.structureType === STRUCTURE_PORTAL).length ===
            0) {
            return false;
        }
        this.creepTravel = this.createCreepTravel();
        console.log("traveler ignoring accidental portal", this.creep.pos.roomName);
        return true;
    }
    get nextPathFinderPosition() {
        var _a;
        if (!this.creepTravel)
            return;
        const currentIndex = this.creepTravel.pathFinder.path.findIndex(p => p.isEqualTo(this.creep.pos));
        const nextIndex = currentIndex >= 0 ? currentIndex + 1 : 0;
        if (!((_a = this.creepTravel.pathFinder.path[nextIndex]) === null || _a === void 0 ? void 0 : _a.isNearTo(this.creep.pos))) {
            return;
        }
        return this.creepTravel.pathFinder.path[nextIndex];
    }
    isPosEqual(pos1, pos2) {
        if (pos1.isEqualTo(pos2)) {
            return true;
        }
        const pos1Exists = Game.map.describeExits(pos1.roomName);
        if (Object.values(pos1Exists).find(roomName => roomName === pos2.roomName)) {
            if (pos1.y === pos2.y && ((pos1.x === 0 && pos2.x === 49) || (pos1.x === 49 && pos2.x === 0))) {
                return true;
            }
            if (pos1.x === pos2.x && ((pos1.y === 0 && pos2.y === 49) || (pos1.y === 49 && pos2.y === 0))) {
                return true;
            }
        }
        return false;
    }
    handleStuck() {
        var _a;
        if (!this.creepTravel)
            return false;
        if (this.creepTravel.pathFinder.incomplete)
            return false;
        if (this.creepTravel.pathFinder.path.length === 0)
            return false;
        if (this.creepTravel.stuckCount <= 0)
            return false;
        if (this.creepTravel.stuckCount > 4) {
            console.log(`stuck at ${String((_a = this.creep.room) === null || _a === void 0 ? void 0 : _a.name)} for ${this.creepTravel.stuckCount}`);
        }
        new RoomVisual(this.creep.pos.roomName).circle(this.creep.pos, {
            radius: 0.45,
            fill: "transparent",
            stroke: "magenta",
            strokeWidth: 0.15,
            opacity: this.creepTravel.stuckCount * 0.2
        });
        if (this.creepTravel.stuckCount >= 3) {
            this.options.ignoreCreeps = false;
            this.creepTravel = this.createCreepTravel();
            // this.creep.say(`*(*)`);
            return true;
        }
        if (this.creepTravel.stuckCount >= 1) {
            const nextPos = this.nextPathFinderPosition;
            if (nextPos) {
                const structureBlocking = nextPos
                    .lookFor(LOOK_STRUCTURES)
                    .filter(i => STRUCTURES_BLOCKING_PATH.includes(i.structureType));
                if (structureBlocking.length > 0) {
                    Cache.unset(CacheKeys.roomMatrix(this.creep.pos.roomName));
                    return true;
                }
                const creepBlocking = nextPos.lookFor(LOOK_CREEPS)[0] || nextPos.lookFor(LOOK_POWER_CREEPS)[0];
                const blockingCreepTravel = creepBlocking ? Traveler.creepTravels[creepBlocking.name] : undefined;
                if (creepBlocking &&
                    creepBlocking.my &&
                    !creepBlocking.memory.stationary &&
                    !creepBlocking.fatigue &&
                    (!blockingCreepTravel || blockingCreepTravel.updatedAt < Game.time - 2) &&
                    // && !creepBlocking.moving
                    creepBlocking.memory.quad === undefined &&
                    creepBlocking.memory.duoId === undefined) {
                    new RoomVisual(nextPos.roomName).line(this.creep.pos, nextPos, {
                        width: 0.5,
                        color: "magenta",
                        opacity: this.creepTravel.stuckCount * 0.2
                    });
                    this.creep.moveTo(creepBlocking.pos, { ignoreCreeps: true });
                    creepBlocking.moveTo(this.creep.pos, { ignoreCreeps: true });
                    return true;
                }
                const structuresBlocking = nextPos
                    .lookFor(LOOK_STRUCTURES)
                    .filter(s => OBSTACLE_OBJECT_TYPES.includes(s.structureType));
                if (structuresBlocking.length > 0) {
                    Cache.unset(CacheKeys.roomMatrix(nextPos.roomName));
                    this.resetCreepTravel();
                    return true;
                }
            }
        }
        return false;
    }
    touchCreepTravel() {
        if (!this.creepTravel)
            return;
        if (this.creepTravel.lastPos && this.isPosEqual(this.creepTravel.lastPos, this.creep.pos)) {
            this.creepTravel.stuckCount++;
            // this.creep.say(`*${this.creepTravel.stuckCount}`);
        }
        else {
            this.creepTravel.stuckCount = 0;
        }
        if (!("fatigue" in this.creep) || this.creep.fatigue === 0) {
            this.creepTravel.lastPos = this.creep.pos;
        }
        this.creepTravel.updatedAt = Game.time;
    }
    createNewPathAndMove() {
        this.creepTravel = this.createCreepTravel();
        if (!this.creepTravel) {
            return false;
        }
        if (this.creepTravel.pathFinder.incomplete) {
            if (this.options.logIncomplete) {
                console.log("path incomplete", this.creep.pos.roomName, this.target.pos.roomName, this.creep.memory.role, this.creepTravel.pathFinder.cost, this.creepTravel.pathFinder.ops);
                // this.creep.say("✊");
            }
            return false;
        }
        if (this.creepTravel.pathFinder.path.length === 0) {
            return false;
        }
        this.creep.moveByPath(this.creepTravel.pathFinder.path);
        this.visualizePath();
        return true;
    }
    get retCacheKey() {
        return [
            this.creep.pos.roomName,
            this.creep.pos.x,
            this.creep.pos.y,
            this.target.pos.roomName,
            this.target.pos.x,
            this.target.pos.y,
            this.options.range
        ].join(".");
    }
    findPath(route) {
        return PathFinder.search(this.creep.pos, { pos: this.target.pos, range: this.options.range }, {
            plainCost: this.options.costPlain,
            swampCost: this.options.costSwamp,
            maxRooms: 64,
            maxOps: this.options.maxOps
                ? this.options.maxOps
                : (route
                    ? route.length + 2
                    : Game.map.getRoomLinearDistance(this.creep.pos.roomName, this.target.pos.roomName) * 2 + 2) * 2000,
            roomCallback: (roomName) => {
                var _a, _b;
                if (route) {
                    if (roomName !== this.creep.pos.roomName &&
                        roomName !== this.target.pos.roomName &&
                        !route.includes(roomName)) {
                        return false;
                    }
                }
                else {
                    if (roomName !== this.creep.pos.roomName &&
                        roomName !== this.target.pos.roomName &&
                        this.impassableRoom(roomName, this.creep.pos.roomName, this.target.pos.roomName)) {
                        return false;
                    }
                }
                // const roomModel = new RoomModel(roomName);
                const room = Game.rooms[roomName];
                const terrain = new Room.Terrain(roomName);
                const matrix = Rooms.matrix(roomName);
                this.options.obstacles.forEach(obstacle => {
                    if (obstacle.roomName === roomName) {
                        matrix.set(obstacle.x, obstacle.y, 255);
                    }
                });
                if (room) {
                    if (!this.options.ignoreHostiles &&
                        ((_a = this.creep.room) === null || _a === void 0 ? void 0 : _a.name) === roomName &&
                        (!room.my || !((_b = room.controller) === null || _b === void 0 ? void 0 : _b.safeMode))) {
                        room.find(FIND_HOSTILE_CREEPS).forEach(hostile => {
                            if (hostile.ticksToLive && hostile.ticksToLive > CREEP_LIFE_TIME) {
                                return;
                            }
                            if (hostile.owner.username === USERNAME.SOURCE_KEEPER) {
                                this.hostileMatrix(matrix, terrain, hostile.pos, 5, 2);
                            }
                            else if (hostile.rangedAttackPower) {
                                this.hostileMatrix(matrix, terrain, hostile.pos, 6);
                            }
                            else if (hostile.attackPower) {
                                this.hostileMatrix(matrix, terrain, hostile.pos, 4);
                            }
                        });
                    }
                    room.find(FIND_CREEPS).forEach(c => {
                        var _a;
                        if (((_a = c === null || c === void 0 ? void 0 : c.memory) === null || _a === void 0 ? void 0 : _a.quad) !== undefined) {
                            matrix.set(c.pos.x, c.pos.y, 254);
                        }
                        else if (!this.options.ignoreCreeps) {
                            matrix.set(c.pos.x, c.pos.y, 254);
                        }
                        else if (c.my && c.memory.stationary) {
                            matrix.set(c.pos.x, c.pos.y, 254);
                        }
                    });
                    // room
                    //   .find(FIND_MY_CONSTRUCTION_SITES, {
                    //     filter: s => (OBSTACLE_OBJECT_TYPES as unknown as string).includes(s.structureType as string)
                    //   })
                    //   .forEach(c => matrix.set(c.pos.x, c.pos.y, 255));
                }
                if (this.options.roomCallback) {
                    this.options.roomCallback(room, matrix);
                }
                return matrix;
            }
        });
    }
    impassableRoom(roomName, fromRoomName, toRoomName) {
        if (roomName === fromRoomName || roomName === toRoomName) {
            return false;
        }
        const fromRoomStatus = Game.map.getRoomStatus(fromRoomName);
        const toRoomStatus = Game.map.getRoomStatus(toRoomName);
        const roomStatus = Game.map.getRoomStatus(roomName);
        if (roomStatus.status !== fromRoomStatus.status) {
            return true;
        }
        if (fromRoomStatus.status !== toRoomStatus.status) {
            return true;
        }
        const roomModel = new RoomModel(roomName);
        if (roomModel.activeTowerCount > 0 && roomModel.ownerUsername !== USERNAME.ME) {
            return true;
        }
        return false;
    }
    hostileMatrix(matrix, terrain, pos, range, multiplier = 1) {
        matrix.set(pos.x, pos.y, 255);
        General.squareCoordinatesFilled(pos.roomName, pos.x, pos.y, range).forEach((p, index) => {
            if (p.x === 0 || p.y === 0) {
                return;
            }
            if (p.x === 49 || p.y === 49) {
                return;
            }
            const mask = terrain.get(p.x, p.y);
            if (mask === TERRAIN_MASK_WALL) {
                return;
            }
            const currentMatrix = matrix.get(p.x, p.y) || 1;
            const newMatrix = mask === TERRAIN_MASK_SWAMP ? currentMatrix + 20 * multiplier : currentMatrix + 10 * multiplier;
            matrix.set(p.x, p.y, newMatrix);
            new RoomVisual(pos.roomName).text(String(newMatrix), p.x, p.y, { align: "center" });
        });
    }
    createCreepTravel() {
        const pathFinder = this.getPathFinder();
        return {
            pathFinder,
            targetPos: this.target.pos,
            targetRange: this.options.range,
            stuckCount: 0,
            createdAt: Game.time,
            updatedAt: Game.time
        };
    }
    getPathFinder() {
        // if (this.options.cache) {
        //   const key = this.retCacheKey;
        //
        //   const path = Traveler.cachedPaths[this.retCacheKey];
        //
        //   if (path) {
        //     path.createdAt = Game.time;
        //     path.used += 1;
        //
        //     console.log("reused path", key, path.used);
        //
        //     return path.ret;
        //   }
        // }
        const ret = this.options.withoutRoute
            ? this.findPath()
            : this.findPath(Geo.findRouteCached(this.creep.pos.roomName, this.target.pos.roomName));
        // if (this.options.cache) {
        //   const key = this.retCacheKey;
        //   Traveler.cachedPaths[key] = { createdAt: Game.time, ret, used: 1 };
        //   console.log("created path", key);
        // }
        return ret;
    }
    swapIdleCreep() {
        if (!this.options.ignoreCreeps)
            return false;
        const nextPos = this.nextPathFinderPosition;
        if (!nextPos)
            return false;
        const nextCreep = nextPos.lookFor(LOOK_CREEPS)[0] || nextPos.lookFor(LOOK_POWER_CREEPS)[0];
        if (!nextCreep) {
            return false;
        }
        if (!nextCreep.memory || nextCreep.memory.stationary) {
            return false;
        }
        if (nextCreep.fatigue > 0) {
            return false;
        }
        if (nextCreep.memory.duoId) {
            return false;
        }
        if (nextCreep.memory.quad) {
            return false;
        }
        const nextCreepTravel = Traveler.creepTravels[nextCreep.name];
        if (nextCreepTravel && nextCreepTravel.updatedAt >= Game.time - 2)
            return false;
        nextCreep.moveTo(this.creep);
        // this.creep.say("<->");
        return true;
    }
    moveFromMemory() {
        if (this.options.freshPath) {
            return false;
        }
        if (!this.creepTravel) {
            return false;
        }
        if (this.creepTravel.pathFinder.incomplete) {
            return false;
        }
        this.visualizePath();
        const res = this.creep.moveByPath(this.creepTravel.pathFinder.path);
        if (res === OK) {
            this.swapIdleCreep();
        }
        return res !== ERR_NOT_FOUND && res !== ERR_INVALID_ARGS;
    }
    visualizePath() {
        var _a, _b;
        let passed = false;
        if (!this.creepTravel) {
            return;
        }
        // [...this.creepTravel.pathFinder.path].reverse().forEach((pos, index, arr) => {
        //   if (passed) {
        //     return;
        //   }
        //
        //   if (pos.isEqualTo(this.creep.pos)) {
        //     passed = true;
        //
        //     return;
        //   }
        //
        //   const previousPos = arr[index - 1];
        //
        //   if (!previousPos) {
        //     return;
        //   }
        //
        //   if (previousPos.roomName !== this.creep.room?.name) {
        //     return;
        //   }
        //
        //   if (pos.roomName !== this.creep.room?.name) {
        //     return;
        //   }
        //
        //   new RoomVisual(pos.roomName).line(previousPos, pos, { color: this.creep.Misc.color || "#fff", opacity: 0.3 });
        // });
        const roomName = (_a = this.creep.room) === null || _a === void 0 ? void 0 : _a.name;
        if (!roomName) {
            return;
        }
        const roomsPath = [];
        [...this.creepTravel.pathFinder.path]
            .reverse()
            .filter(p => p.roomName === roomName)
            .forEach(pos => {
            if (passed) {
                return;
            }
            if (pos.isEqualTo(this.creep.pos)) {
                passed = true;
                return;
            }
            roomsPath.push([pos.x, pos.y]);
        });
        new RoomVisual((_b = this.creep.room) === null || _b === void 0 ? void 0 : _b.name).poly(roomsPath, {
            stroke: this.creep.memory.color || "#fff",
            opacity: 0.3
        });
    }
    static init() {
        General.interval(500, () => this.cleanupExpiredPaths());
    }
    static cleanupExpiredPaths() {
        for (const key in this.cachedPaths) {
            if (this.cachedPaths[key].createdAt > Game.time - 3000) {
                continue;
            }
            delete this.cachedPaths[key];
        }
    }
}
Traveler.creepTravels = {};
Traveler.cachedPaths = {};

const RESOURCE_BODY = {
    [RESOURCE_UTRIUM_HYDRIDE]: ATTACK,
    [RESOURCE_UTRIUM_OXIDE]: WORK,
    [RESOURCE_KEANIUM_HYDRIDE]: CARRY,
    [RESOURCE_KEANIUM_OXIDE]: RANGED_ATTACK,
    [RESOURCE_LEMERGIUM_HYDRIDE]: WORK,
    [RESOURCE_LEMERGIUM_OXIDE]: HEAL,
    [RESOURCE_ZYNTHIUM_HYDRIDE]: WORK,
    [RESOURCE_ZYNTHIUM_OXIDE]: MOVE,
    [RESOURCE_GHODIUM_HYDRIDE]: WORK,
    [RESOURCE_GHODIUM_OXIDE]: TOUGH,
    [RESOURCE_UTRIUM_ACID]: ATTACK,
    [RESOURCE_UTRIUM_ALKALIDE]: WORK,
    [RESOURCE_KEANIUM_ACID]: CARRY,
    [RESOURCE_KEANIUM_ALKALIDE]: RANGED_ATTACK,
    [RESOURCE_LEMERGIUM_ACID]: WORK,
    [RESOURCE_LEMERGIUM_ALKALIDE]: HEAL,
    [RESOURCE_ZYNTHIUM_ACID]: WORK,
    [RESOURCE_ZYNTHIUM_ALKALIDE]: MOVE,
    [RESOURCE_GHODIUM_ACID]: WORK,
    [RESOURCE_GHODIUM_ALKALIDE]: TOUGH,
    [RESOURCE_CATALYZED_UTRIUM_ACID]: ATTACK,
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: WORK,
    [RESOURCE_CATALYZED_KEANIUM_ACID]: CARRY,
    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: RANGED_ATTACK,
    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: WORK,
    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: HEAL,
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: WORK,
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: MOVE,
    [RESOURCE_CATALYZED_GHODIUM_ACID]: WORK,
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: TOUGH
};
const BOOST_DESCRIPTIONS = {
    [RESOURCE_UTRIUM_HYDRIDE]: "+100% attack effectiveness",
    [RESOURCE_UTRIUM_OXIDE]: "+200% harvest effectiveness",
    [RESOURCE_KEANIUM_HYDRIDE]: "+50 capacity",
    [RESOURCE_KEANIUM_OXIDE]: "+100% rangedAttack and rangedMassAttack effectiveness",
    [RESOURCE_LEMERGIUM_HYDRIDE]: "+50% repair and build effectiveness without increasing the energy cost",
    [RESOURCE_LEMERGIUM_OXIDE]: "+100% heal and rangedHeal effectiveness",
    [RESOURCE_ZYNTHIUM_HYDRIDE]: "+100% dismantle effectiveness",
    [RESOURCE_ZYNTHIUM_OXIDE]: "+100% fatigue decrease speed",
    [RESOURCE_GHODIUM_HYDRIDE]: "+50% upgradeController effectiveness without increasing the energy cost",
    [RESOURCE_GHODIUM_OXIDE]: "-30% damage taken",
    [RESOURCE_UTRIUM_ACID]: "+200% attack effectiveness",
    [RESOURCE_UTRIUM_ALKALIDE]: "+400% harvest effectiveness",
    [RESOURCE_KEANIUM_ACID]: "+100 capacity",
    [RESOURCE_KEANIUM_ALKALIDE]: "+200% rangedAttack and rangedMassAttack effectiveness",
    [RESOURCE_LEMERGIUM_ACID]: "+80% repair and build effectiveness without increasing the energy cost",
    [RESOURCE_LEMERGIUM_ALKALIDE]: "+200% heal and rangedHeal effectiveness",
    [RESOURCE_ZYNTHIUM_ACID]: "+200% dismantle effectiveness",
    [RESOURCE_ZYNTHIUM_ALKALIDE]: "+200% fatigue decrease speed",
    [RESOURCE_GHODIUM_ACID]: "+80% upgradeController effectiveness without increasing the energy cost",
    [RESOURCE_GHODIUM_ALKALIDE]: "-50% damage taken",
    [RESOURCE_CATALYZED_UTRIUM_ACID]: "+300% attack effectiveness",
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: "+600% harvest effectiveness",
    [RESOURCE_CATALYZED_KEANIUM_ACID]: "+150 capacity",
    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: "+300% rangedAttack and rangedMassAttack effectiveness",
    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: "+100% repair and build effectiveness without increasing the energy cost",
    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: "+300% heal and rangedHeal effectiveness",
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: "+300% dismantle effectiveness",
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: "+300% fatigue decrease speed",
    [RESOURCE_CATALYZED_GHODIUM_ACID]: "+100% upgradeController effectiveness without increasing the energy cost",
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: "-70% damage taken"
};
const RESOURCE_COLORS = {
    H: "#989898",
    O: "#989898",
    U: "#48C5E5",
    L: "#24D490",
    K: "#9269EC",
    Z: "#D9B478",
    X: "#F26D6F",
    energy: "#FEE476",
    battery: "#FEE476",
    power: "#F1243A",
    reductant: "#989898",
    oxidant: "#989898",
    utrium_bar: "#48C5E5",
    lemergium_bar: "#24D490",
    keanium_bar: "#9269EC",
    zynthium_bar: "#D9B478",
    purifier: "#F26D6F",
    OH: "#B4B4B4",
    ZK: "#B4B4B4",
    UL: "#B4B4B4",
    G: "#FFFFFF",
    ghodium_melt: "#FFFFFF",
    composite: "#FFFFFF",
    crystal: "#FFFFFF",
    liquid: "#FFFFFF",
    UH: "#50D7F9",
    UO: "#50D7F9",
    KH: "#A071FF",
    KO: "#A071FF",
    LH: "#00F4A2",
    LO: "#00F4A2",
    ZH: "#FDD388",
    ZO: "#FDD388",
    GH: "#FFFFFF",
    GO: "#FFFFFF",
    UH2O: "#50D7F9",
    UHO2: "#50D7F9",
    KH2O: "#A071FF",
    KHO2: "#A071FF",
    LH2O: "#00F4A2",
    LHO2: "#00F4A2",
    ZH2O: "#FDD388",
    ZHO2: "#FDD388",
    GH2O: "#FFFFFF",
    GHO2: "#FFFFFF",
    XUH2O: "#50D7F9",
    XUHO2: "#50D7F9",
    XKH2O: "#A071FF",
    XKHO2: "#A071FF",
    XLH2O: "#00F4A2",
    XLHO2: "#00F4A2",
    XZH2O: "#FDD388",
    XZHO2: "#FDD388",
    XGH2O: "#FFFFFF",
    XGHO2: "#FFFFFF",
    metal: "#956F5C",
    alloy: "#956F5C",
    tube: "#956F5C",
    fixtures: "#956F5C",
    frame: "#956F5C",
    hydraulics: "#956F5C",
    machine: "#956F5C",
    biomass: "#84B012",
    cell: "#84B012",
    phlegm: "#84B012",
    tissue: "#84B012",
    muscle: "#84B012",
    organoid: "#84B012",
    organism: "#84B012",
    silicon: "#4DA7E5",
    wire: "#4DA7E5",
    switch: "#4DA7E5",
    transistor: "#4DA7E5",
    microchip: "#4DA7E5",
    circuit: "#4DA7E5",
    device: "#4DA7E5",
    mist: "#DA6BF5",
    condensate: "#DA6BF5",
    concentrate: "#DA6BF5",
    extract: "#DA6BF5",
    spirit: "#DA6BF5",
    emanation: "#DA6BF5",
    essence: "#DA6BF5",
    ops: "#fff",
    [SUBSCRIPTION_TOKEN]: "#fff",
    [CPU_UNLOCK]: "#fff",
    [PIXEL]: "#fff",
    [ACCESS_KEY]: "#fff"
};
/**
 * 3 - best, 1 - worst
 */
const BOOST_ALIAS = {
    ATTACK_3: RESOURCE_CATALYZED_UTRIUM_ACID,
    ATTACK_2: RESOURCE_UTRIUM_ACID,
    ATTACK_1: RESOURCE_UTRIUM_HYDRIDE,
    HARVEST_3: RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
    HARVEST_2: RESOURCE_UTRIUM_ALKALIDE,
    HARVEST_1: RESOURCE_UTRIUM_OXIDE,
    CARRY_3: RESOURCE_CATALYZED_KEANIUM_ACID,
    CARRY_2: RESOURCE_KEANIUM_ACID,
    CARRY_1: RESOURCE_KEANIUM_HYDRIDE,
    RANGED_ATTACK_3: RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
    RANGED_ATTACK_2: RESOURCE_KEANIUM_ALKALIDE,
    RANGED_ATTACK_1: RESOURCE_KEANIUM_OXIDE,
    REPAIR_BUILD_3: RESOURCE_CATALYZED_LEMERGIUM_ACID,
    REPAIR_BUILD_2: RESOURCE_LEMERGIUM_ACID,
    REPAIR_BUILD_1: RESOURCE_LEMERGIUM_HYDRIDE,
    HEAL_3: RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
    HEAL_2: RESOURCE_LEMERGIUM_ALKALIDE,
    HEAL_1: RESOURCE_LEMERGIUM_OXIDE,
    DISMANTLE_3: RESOURCE_CATALYZED_ZYNTHIUM_ACID,
    DISMANTLE_2: RESOURCE_ZYNTHIUM_ACID,
    DISMANTLE_1: RESOURCE_ZYNTHIUM_HYDRIDE,
    MOVE_3: RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
    MOVE_2: RESOURCE_ZYNTHIUM_ALKALIDE,
    MOVE_1: RESOURCE_ZYNTHIUM_OXIDE,
    UPGRADE_3: RESOURCE_CATALYZED_GHODIUM_ACID,
    UPGRADE_2: RESOURCE_GHODIUM_ACID,
    UPGRADE_1: RESOURCE_GHODIUM_HYDRIDE,
    TOUGH_3: RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
    TOUGH_2: RESOURCE_GHODIUM_ALKALIDE,
    TOUGH_1: RESOURCE_GHODIUM_OXIDE
};
const BOOST_REACTIONS = {
    [RESOURCE_HYDROXIDE]: [RESOURCE_OXYGEN, RESOURCE_HYDROGEN],
    [RESOURCE_LEMERGIUM_HYDRIDE]: [RESOURCE_LEMERGIUM, RESOURCE_HYDROGEN],
    [RESOURCE_KEANIUM_HYDRIDE]: [RESOURCE_KEANIUM, RESOURCE_HYDROGEN],
    [RESOURCE_UTRIUM_HYDRIDE]: [RESOURCE_UTRIUM, RESOURCE_HYDROGEN],
    [RESOURCE_ZYNTHIUM_HYDRIDE]: [RESOURCE_ZYNTHIUM, RESOURCE_HYDROGEN],
    [RESOURCE_GHODIUM_HYDRIDE]: [RESOURCE_GHODIUM, RESOURCE_HYDROGEN],
    [RESOURCE_LEMERGIUM_OXIDE]: [RESOURCE_LEMERGIUM, RESOURCE_OXYGEN],
    [RESOURCE_KEANIUM_OXIDE]: [RESOURCE_KEANIUM, RESOURCE_OXYGEN],
    [RESOURCE_UTRIUM_OXIDE]: [RESOURCE_UTRIUM, RESOURCE_OXYGEN],
    [RESOURCE_ZYNTHIUM_OXIDE]: [RESOURCE_ZYNTHIUM, RESOURCE_OXYGEN],
    [RESOURCE_GHODIUM_OXIDE]: [RESOURCE_GHODIUM, RESOURCE_OXYGEN],
    [RESOURCE_ZYNTHIUM_KEANITE]: [RESOURCE_KEANIUM, RESOURCE_ZYNTHIUM],
    [RESOURCE_UTRIUM_LEMERGITE]: [RESOURCE_UTRIUM, RESOURCE_LEMERGIUM],
    [RESOURCE_UTRIUM_ACID]: [RESOURCE_UTRIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_UTRIUM_ALKALIDE]: [RESOURCE_UTRIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_ZYNTHIUM_ACID]: [RESOURCE_ZYNTHIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_ZYNTHIUM_ALKALIDE]: [RESOURCE_ZYNTHIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_KEANIUM_ACID]: [RESOURCE_KEANIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_KEANIUM_ALKALIDE]: [RESOURCE_KEANIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_LEMERGIUM_ACID]: [RESOURCE_LEMERGIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_LEMERGIUM_ALKALIDE]: [RESOURCE_LEMERGIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_GHODIUM_ACID]: [RESOURCE_GHODIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_GHODIUM_ALKALIDE]: [RESOURCE_GHODIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_CATALYZED_UTRIUM_ACID]: [RESOURCE_UTRIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: [RESOURCE_UTRIUM_ALKALIDE, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: [RESOURCE_LEMERGIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: [RESOURCE_LEMERGIUM_ALKALIDE, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_KEANIUM_ACID]: [RESOURCE_KEANIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: [RESOURCE_KEANIUM_ALKALIDE, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: [RESOURCE_ZYNTHIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: [RESOURCE_ZYNTHIUM_ALKALIDE, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_GHODIUM_ACID]: [RESOURCE_GHODIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: [RESOURCE_GHODIUM_ALKALIDE, RESOURCE_CATALYST],
    [RESOURCE_GHODIUM]: [RESOURCE_UTRIUM_LEMERGITE, RESOURCE_ZYNTHIUM_KEANITE]
};
const RESOURCE_BARS = [
    RESOURCE_UTRIUM_BAR,
    RESOURCE_LEMERGIUM_BAR,
    RESOURCE_ZYNTHIUM_BAR,
    RESOURCE_KEANIUM_BAR,
    RESOURCE_GHODIUM_MELT,
    RESOURCE_OXIDANT,
    RESOURCE_REDUCTANT,
    RESOURCE_PURIFIER,
    RESOURCE_BATTERY
];
const RESOURCE_BAR_DECOMPRESS_OUTCOMES = {
    [RESOURCE_UTRIUM_BAR]: RESOURCE_UTRIUM,
    [RESOURCE_LEMERGIUM_BAR]: RESOURCE_LEMERGIUM,
    [RESOURCE_ZYNTHIUM_BAR]: RESOURCE_ZYNTHIUM,
    [RESOURCE_KEANIUM_BAR]: RESOURCE_KEANIUM,
    [RESOURCE_GHODIUM_MELT]: RESOURCE_GHODIUM,
    [RESOURCE_OXIDANT]: RESOURCE_OXYGEN,
    [RESOURCE_REDUCTANT]: RESOURCE_HYDROGEN,
    [RESOURCE_PURIFIER]: RESOURCE_CATALYST,
    [RESOURCE_BATTERY]: RESOURCE_ENERGY
};
const RESOURCE_MINERALS = [
    RESOURCE_UTRIUM,
    RESOURCE_LEMERGIUM,
    RESOURCE_ZYNTHIUM,
    RESOURCE_KEANIUM,
    RESOURCE_OXYGEN,
    RESOURCE_HYDROGEN,
    RESOURCE_CATALYST
];
const RESOURCE_COMPOUNDS = [
    RESOURCE_HYDROXIDE,
    RESOURCE_ZYNTHIUM_KEANITE,
    RESOURCE_UTRIUM_LEMERGITE,
    RESOURCE_GHODIUM
];
const RESOURCE_BOOSTS = [
    RESOURCE_UTRIUM_HYDRIDE,
    RESOURCE_UTRIUM_OXIDE,
    RESOURCE_KEANIUM_HYDRIDE,
    RESOURCE_KEANIUM_OXIDE,
    RESOURCE_LEMERGIUM_HYDRIDE,
    RESOURCE_LEMERGIUM_OXIDE,
    RESOURCE_ZYNTHIUM_HYDRIDE,
    RESOURCE_ZYNTHIUM_OXIDE,
    RESOURCE_GHODIUM_HYDRIDE,
    RESOURCE_GHODIUM_OXIDE,
    RESOURCE_UTRIUM_ACID,
    RESOURCE_UTRIUM_ALKALIDE,
    RESOURCE_KEANIUM_ACID,
    RESOURCE_KEANIUM_ALKALIDE,
    RESOURCE_LEMERGIUM_ACID,
    RESOURCE_LEMERGIUM_ALKALIDE,
    RESOURCE_ZYNTHIUM_ACID,
    RESOURCE_ZYNTHIUM_ALKALIDE,
    RESOURCE_GHODIUM_ACID,
    RESOURCE_GHODIUM_ALKALIDE,
    RESOURCE_CATALYZED_UTRIUM_ACID,
    RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
    RESOURCE_CATALYZED_KEANIUM_ACID,
    RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
    RESOURCE_CATALYZED_LEMERGIUM_ACID,
    RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
    RESOURCE_CATALYZED_ZYNTHIUM_ACID,
    RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
    RESOURCE_CATALYZED_GHODIUM_ACID,
    RESOURCE_CATALYZED_GHODIUM_ALKALIDE
];
const RESOURCE_COMODITIES = [
    RESOURCE_UTRIUM_BAR,
    RESOURCE_LEMERGIUM_BAR,
    RESOURCE_ZYNTHIUM_BAR,
    RESOURCE_KEANIUM_BAR,
    RESOURCE_GHODIUM_MELT,
    RESOURCE_OXIDANT,
    RESOURCE_REDUCTANT,
    RESOURCE_PURIFIER,
    RESOURCE_BATTERY,
    RESOURCE_SILICON,
    RESOURCE_METAL,
    RESOURCE_BIOMASS,
    RESOURCE_MIST,
    RESOURCE_COMPOSITE,
    RESOURCE_CRYSTAL,
    RESOURCE_LIQUID,
    RESOURCE_WIRE,
    RESOURCE_SWITCH,
    RESOURCE_TRANSISTOR,
    RESOURCE_MICROCHIP,
    RESOURCE_CIRCUIT,
    RESOURCE_DEVICE,
    RESOURCE_CELL,
    RESOURCE_PHLEGM,
    RESOURCE_TISSUE,
    RESOURCE_MUSCLE,
    RESOURCE_ORGANOID,
    RESOURCE_ORGANISM,
    RESOURCE_ALLOY,
    RESOURCE_TUBE,
    RESOURCE_FIXTURES,
    RESOURCE_FRAME,
    RESOURCE_HYDRAULICS,
    RESOURCE_MACHINE,
    RESOURCE_CONDENSATE,
    RESOURCE_CONCENTRATE,
    RESOURCE_EXTRACT,
    RESOURCE_SPIRIT,
    RESOURCE_EMANATION,
    RESOURCE_ESSENCE
];

var ResourceType;
(function (ResourceType) {
    ResourceType["ENERGY"] = "energy";
    ResourceType["POWER"] = "power";
    ResourceType["MINERAL"] = "mineral";
    ResourceType["T3BOOST"] = "t3boost";
    ResourceType["T2BOOST"] = "t2boost";
    ResourceType["T1BOOST"] = "t1boost";
    ResourceType["COMODITY"] = "comodity";
    ResourceType["COMODITY_BAR"] = "comodityBar";
    ResourceType["COMPOUND"] = "compound";
    ResourceType["OTHER"] = "other";
})(ResourceType || (ResourceType = {}));
const BASE_STORE = {
    [RESOURCE_ENERGY]: 0,
    [RESOURCE_POWER]: 0,
    [RESOURCE_OPS]: 0,
    [RESOURCE_UTRIUM]: 0,
    [RESOURCE_LEMERGIUM]: 0,
    [RESOURCE_KEANIUM]: 0,
    [RESOURCE_ZYNTHIUM]: 0,
    [RESOURCE_OXYGEN]: 0,
    [RESOURCE_HYDROGEN]: 0,
    [RESOURCE_CATALYST]: 0,
    [RESOURCE_HYDROXIDE]: 0,
    [RESOURCE_ZYNTHIUM_KEANITE]: 0,
    [RESOURCE_UTRIUM_LEMERGITE]: 0,
    [RESOURCE_GHODIUM]: 0,
    [RESOURCE_UTRIUM_HYDRIDE]: 0,
    [RESOURCE_UTRIUM_OXIDE]: 0,
    [RESOURCE_KEANIUM_HYDRIDE]: 0,
    [RESOURCE_KEANIUM_OXIDE]: 0,
    [RESOURCE_LEMERGIUM_HYDRIDE]: 0,
    [RESOURCE_LEMERGIUM_OXIDE]: 0,
    [RESOURCE_ZYNTHIUM_HYDRIDE]: 0,
    [RESOURCE_ZYNTHIUM_OXIDE]: 0,
    [RESOURCE_GHODIUM_HYDRIDE]: 0,
    [RESOURCE_GHODIUM_OXIDE]: 0,
    [RESOURCE_UTRIUM_ACID]: 0,
    [RESOURCE_UTRIUM_ALKALIDE]: 0,
    [RESOURCE_KEANIUM_ACID]: 0,
    [RESOURCE_KEANIUM_ALKALIDE]: 0,
    [RESOURCE_LEMERGIUM_ACID]: 0,
    [RESOURCE_LEMERGIUM_ALKALIDE]: 0,
    [RESOURCE_ZYNTHIUM_ACID]: 0,
    [RESOURCE_ZYNTHIUM_ALKALIDE]: 0,
    [RESOURCE_GHODIUM_ACID]: 0,
    [RESOURCE_GHODIUM_ALKALIDE]: 0,
    [RESOURCE_CATALYZED_UTRIUM_ACID]: 0,
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: 0,
    [RESOURCE_CATALYZED_KEANIUM_ACID]: 0,
    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: 0,
    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: 0,
    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: 0,
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: 0,
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: 0,
    [RESOURCE_CATALYZED_GHODIUM_ACID]: 0,
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: 0,
    [RESOURCE_MIST]: 0,
    [RESOURCE_BIOMASS]: 0,
    [RESOURCE_METAL]: 0,
    [RESOURCE_SILICON]: 0,
    [RESOURCE_UTRIUM_BAR]: 0,
    [RESOURCE_LEMERGIUM_BAR]: 0,
    [RESOURCE_ZYNTHIUM_BAR]: 0,
    [RESOURCE_KEANIUM_BAR]: 0,
    [RESOURCE_GHODIUM_MELT]: 0,
    [RESOURCE_OXIDANT]: 0,
    [RESOURCE_REDUCTANT]: 0,
    [RESOURCE_PURIFIER]: 0,
    [RESOURCE_BATTERY]: 0,
    [RESOURCE_COMPOSITE]: 0,
    [RESOURCE_CRYSTAL]: 0,
    [RESOURCE_LIQUID]: 0,
    [RESOURCE_WIRE]: 0,
    [RESOURCE_SWITCH]: 0,
    [RESOURCE_TRANSISTOR]: 0,
    [RESOURCE_MICROCHIP]: 0,
    [RESOURCE_CIRCUIT]: 0,
    [RESOURCE_DEVICE]: 0,
    [RESOURCE_CELL]: 0,
    [RESOURCE_PHLEGM]: 0,
    [RESOURCE_TISSUE]: 0,
    [RESOURCE_MUSCLE]: 0,
    [RESOURCE_ORGANOID]: 0,
    [RESOURCE_ORGANISM]: 0,
    [RESOURCE_ALLOY]: 0,
    [RESOURCE_TUBE]: 0,
    [RESOURCE_FIXTURES]: 0,
    [RESOURCE_FRAME]: 0,
    [RESOURCE_HYDRAULICS]: 0,
    [RESOURCE_MACHINE]: 0,
    [RESOURCE_CONDENSATE]: 0,
    [RESOURCE_CONCENTRATE]: 0,
    [RESOURCE_EXTRACT]: 0,
    [RESOURCE_SPIRIT]: 0,
    [RESOURCE_EMANATION]: 0,
    [RESOURCE_ESSENCE]: 0
};
const RESOURCE_GROUP_MINERALS = [
    RESOURCE_HYDROGEN,
    RESOURCE_OXYGEN,
    RESOURCE_UTRIUM,
    RESOURCE_LEMERGIUM,
    RESOURCE_KEANIUM,
    RESOURCE_ZYNTHIUM,
    RESOURCE_CATALYST
];
const RESOURCE_GROUP_TIER_1_BOOSTS = [
    RESOURCE_CATALYZED_UTRIUM_ACID,
    RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
    RESOURCE_CATALYZED_KEANIUM_ACID,
    RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
    RESOURCE_CATALYZED_LEMERGIUM_ACID,
    RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
    RESOURCE_CATALYZED_ZYNTHIUM_ACID,
    RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
    RESOURCE_CATALYZED_GHODIUM_ACID,
    RESOURCE_CATALYZED_GHODIUM_ALKALIDE
];
const RESOURCE_GROUP_TIER_2_BOOSTS = [
    RESOURCE_UTRIUM_ACID,
    RESOURCE_UTRIUM_ALKALIDE,
    RESOURCE_KEANIUM_ACID,
    RESOURCE_KEANIUM_ALKALIDE,
    RESOURCE_LEMERGIUM_ACID,
    RESOURCE_LEMERGIUM_ALKALIDE,
    RESOURCE_ZYNTHIUM_ACID,
    RESOURCE_ZYNTHIUM_ALKALIDE,
    RESOURCE_GHODIUM_ACID,
    RESOURCE_GHODIUM_ALKALIDE
];
const RESOURCE_GROUP_TIER_3_BOOSTS = [
    RESOURCE_UTRIUM_HYDRIDE,
    RESOURCE_UTRIUM_OXIDE,
    RESOURCE_KEANIUM_HYDRIDE,
    RESOURCE_KEANIUM_OXIDE,
    RESOURCE_LEMERGIUM_HYDRIDE,
    RESOURCE_LEMERGIUM_OXIDE,
    RESOURCE_ZYNTHIUM_HYDRIDE,
    RESOURCE_ZYNTHIUM_OXIDE,
    RESOURCE_GHODIUM_HYDRIDE,
    RESOURCE_GHODIUM_OXIDE
];
const RESOURCE_GROUP_COMPOUNDS = [
    RESOURCE_HYDROXIDE,
    RESOURCE_ZYNTHIUM_KEANITE,
    RESOURCE_UTRIUM_LEMERGITE,
    RESOURCE_GHODIUM
];
const RESOURCE_GROUP_COMODITIES = [
    RESOURCE_UTRIUM_BAR,
    RESOURCE_LEMERGIUM_BAR,
    RESOURCE_ZYNTHIUM_BAR,
    RESOURCE_KEANIUM_BAR,
    RESOURCE_GHODIUM_MELT,
    RESOURCE_OXIDANT,
    RESOURCE_REDUCTANT,
    RESOURCE_PURIFIER,
    RESOURCE_BATTERY,
    RESOURCE_COMPOSITE,
    RESOURCE_CRYSTAL,
    RESOURCE_LIQUID,
    RESOURCE_WIRE,
    RESOURCE_SWITCH,
    RESOURCE_TRANSISTOR,
    RESOURCE_MICROCHIP,
    RESOURCE_CIRCUIT,
    RESOURCE_DEVICE,
    RESOURCE_CELL,
    RESOURCE_PHLEGM,
    RESOURCE_TISSUE,
    RESOURCE_MUSCLE,
    RESOURCE_ORGANOID,
    RESOURCE_ORGANISM,
    RESOURCE_ALLOY,
    RESOURCE_TUBE,
    RESOURCE_FIXTURES,
    RESOURCE_FRAME,
    RESOURCE_HYDRAULICS,
    RESOURCE_MACHINE,
    RESOURCE_CONDENSATE,
    RESOURCE_CONCENTRATE,
    RESOURCE_EXTRACT,
    RESOURCE_SPIRIT,
    RESOURCE_EMANATION,
    RESOURCE_ESSENCE
];
class Resources {
    static get resourceValues() {
        if (Memory.resourceValues === undefined || Memory.resourceValues.updatedAt < Game.time - 200000) {
            const values = Object.assign({}, BASE_STORE);
            for (const resource in values) {
                const orderHistory = Game.market.getHistory(resource);
                if (typeof orderHistory === "object" && Object.keys(orderHistory).length === 0) {
                    const cheapestInMarket = Game.market
                        .getAllOrders({
                        type: ORDER_SELL,
                        resourceType: resource
                    })
                        .filter(o => o.remainingAmount > 0)
                        .sort((a, b) => a.price - b.price)[0];
                    values[resource] = cheapestInMarket.price || 0;
                }
                else {
                    values[resource] = orderHistory.reduce((avgPrice, history, currentIndex) => {
                        if (avgPrice === 0) {
                            return history.avgPrice;
                        }
                        const previousHistory = orderHistory[currentIndex - 1];
                        if (!previousHistory) {
                            return avgPrice;
                        }
                        return ((history.avgPrice * history.volume + previousHistory.avgPrice * previousHistory.volume) /
                            (history.volume + previousHistory.volume));
                    }, 0);
                }
            }
            Memory.resourceValues = {
                updatedAt: Game.time,
                values
            };
        }
        return Memory.resourceValues.values;
    }
    static mostValuableResource(store) {
        const resources = Object.keys(store);
        return resources.sort((a, b) => (this.resourceValues[b] || 0) - (this.resourceValues[a] || 0))[0] || null;
    }
    static firstStoreResource(store, options) {
        let resources = Object.keys(store);
        if (options === null || options === void 0 ? void 0 : options.except) {
            resources = resources.filter(r => !options.except.includes(r));
        }
        return resources[0] || null;
    }
    static resourceGroup(resource) {
        if (resource === RESOURCE_ENERGY) {
            return ResourceType.ENERGY;
        }
        else if (resource === RESOURCE_POWER) {
            return ResourceType.POWER;
        }
        else if (RESOURCE_GROUP_MINERALS.includes(resource)) {
            return ResourceType.MINERAL;
        }
        else if (RESOURCE_GROUP_TIER_3_BOOSTS.includes(resource)) {
            return ResourceType.T3BOOST;
        }
        else if (RESOURCE_GROUP_TIER_2_BOOSTS.includes(resource)) {
            return ResourceType.T2BOOST;
        }
        else if (RESOURCE_GROUP_TIER_1_BOOSTS.includes(resource)) {
            return ResourceType.T1BOOST;
        }
        else if (RESOURCE_GROUP_COMPOUNDS.includes(resource)) {
            return ResourceType.COMPOUND;
        }
        else if (RESOURCE_BARS.includes(resource)) {
            return ResourceType.COMODITY_BAR;
        }
        else if (RESOURCE_GROUP_COMODITIES.includes(resource)) {
            return ResourceType.COMODITY;
        }
        return ResourceType.OTHER;
    }
    static storeValue(store) {
        let value = 0;
        Object.keys(store).forEach(resource => {
            value += this.resourceValues[resource] * store[resource];
        });
        return value;
    }
    static storeValuableCount(store) {
        let value = 0;
        Object.keys(store).forEach(resource => {
            if (!this.isResourceValuable(resource)) {
                return;
            }
            value += store[resource];
        });
        return value;
    }
    static isResourceValuable(resource) {
        return this.resourceValues[resource] > this.resourceValues[RESOURCE_ENERGY] * 10;
    }
    static firstStoreBarResource(store) {
        for (const resource in store) {
            if (RESOURCE_BARS.includes(resource)) {
                return resource;
            }
        }
        return null;
    }
    static myAverageResources() {
        const resources = Object.assign({}, BASE_STORE);
        Rooms.myRooms
            .filter(r => r.level >= 8 && !r.isGclFarm)
            .forEach(room => {
            Object.keys(room.store).forEach(resource => {
                resources[resource] += room.store[resource];
            });
        });
        const roomCount = Rooms.myRooms.length;
        Object.keys(resources).forEach(resource => {
            resources[resource] /= roomCount;
        });
        return resources;
    }
}

Creep.prototype.getRemoteFlag = function () {
    if (this._getRemoteFlag === undefined) {
        this._getRemoteFlag = this.memory.remoteFlagName ? Game.flags[this.memory.remoteFlagName] || null : null;
    }
    return this._getRemoteFlag;
};
// Creep.prototype.boost = function (options?: { force?: boolean; minTicksToLive?: number }): boolean {
//   if (!this.Misc.boosts) {
//     return false;
//   }
//
//   if (!this.ticksToLive) {
//     return false;
//   }
//
//   if (options?.minTicksToLive && this.ticksToLive < options.minTicksToLive) {
//     return false;
//   }
//
//   if (!this.isInHomeRoom) {
//     return false;
//   }
//
//   const boostsMissing: MineralBoostConstant[] = this.Misc.boosts.filter(boost =>
//     this.body.find(b => !b.boost && b.type === RESOURCE_BODY[boost])
//   );
//
//   if (boostsMissing.length === 0) {
//     return false;
//   }
//
//   const lab = this.room
//     .find(FIND_MY_STRUCTURES)
//     .filter(
//       s =>
//         s.structureType === STRUCTURE_LAB &&
//         s.mineralType &&
//         s.mineralAmount > 30 &&
//         boostsMissing.includes(s.mineralType as MineralBoostConstant)
//     )
//     .sort((a, b) => this.pos.getRangeTo(a) - this.pos.getRangeTo(b))[0] as StructureLab | undefined;
//
//   if (!lab) {
//     return !!options?.force;
//   }
//
//   if (lab.boostCreep(this) === ERR_NOT_IN_RANGE) {
//     this.travel(lab);
//   }
//
//   return true;
// };
Creep.prototype.rangedBestAttack = function (attackCreeps = true) {
    var _a;
    if (!this.rangedAttackPower) {
        return false;
    }
    const safeToMassAttack = !this.room.storage ||
        this.room.storage.my ||
        !this.room.storage.pos.inRangeTo(this, 3) ||
        this.room.storage.pos.rampart ||
        this.room.storage.isWorthless;
    const manualTarget = this.pos
        .findInRange(FIND_STRUCTURES, 3)
        .find(s => s.pos.lookFor(LOOK_FLAGS).filter(f => f.color === COLOR_GREY && f.secondaryColor === COLOR_WHITE).length > 0);
    if (manualTarget) {
        this.rangedAttack(manualTarget);
        this.intents.push(CreepIntent.RANGED_ATTACK);
        return true;
    }
    if (attackCreeps) {
        const hostiles = this.pos.findInRange(FIND_HOSTILE_CREEPS, 3, {
            filter: c => !c.isUnderRampart
        });
        if (hostiles.length > 0) {
            const multiplier = hostiles.reduce((multi, creep) => multi + (MASS_RANGED_ATTACK_DECAY[this.pos.getRangeTo(creep)] || 0), 0);
            multiplier >= 1 && safeToMassAttack
                ? this.rangedMassAttack()
                : this.rangedAttack(hostiles.sort((a, b) => b.realDamageTaken(this.rangedAttackPower) -
                    b.healPower -
                    a.realDamageTaken(this.rangedAttackPower) -
                    a.healPower)[0]);
            this.intents.push(CreepIntent.RANGED_ATTACK);
            return true;
        }
        const powerHostiles = this.pos.findInRange(FIND_HOSTILE_POWER_CREEPS, 3, {
            filter: c => !c.isUnderRampart
        });
        if (powerHostiles.length > 0) {
            const multiplier = powerHostiles.reduce((multi, creep) => multi + (MASS_RANGED_ATTACK_DECAY[this.pos.getRangeTo(creep)] || 0), 0);
            multiplier >= 1 && safeToMassAttack
                ? this.rangedMassAttack()
                : this.rangedAttack(powerHostiles.sort((a, b) => a.hits - b.hits)[0]);
            return true;
        }
    }
    const structures = this.pos
        .findInRange(FIND_HOSTILE_STRUCTURES, 3)
        .filter(s => {
        var _a, _b, _c;
        return ((_a = s.owner) === null || _a === void 0 ? void 0 : _a.username) !== USERNAME.POWER_BANK &&
            ((_b = s.owner) === null || _b === void 0 ? void 0 : _b.username) !== USERNAME.PUBLIC &&
            ((_c = s.owner) === null || _c === void 0 ? void 0 : _c.username) !== USERNAME.SOURCE_KEEPER &&
            (s.structureType !== STRUCTURE_STORAGE || s.isWorthless) &&
            s.hits;
    });
    if (structures.length > 0) {
        const multiplier = structures
            .filter((value, index, self) => {
            return self.findIndex(v => v.pos.x === value.pos.x && v.pos.y === value.pos.y) === index && value.hits;
        })
            .reduce((multi, creep) => multi + (MASS_RANGED_ATTACK_DECAY[this.pos.getRangeTo(creep)] || 0), 0);
        multiplier >= 1 && safeToMassAttack
            ? this.rangedMassAttack()
            : this.rangedAttack(structures
                .filter(s => s.structureType === STRUCTURE_RAMPART ||
                s.pos.lookFor(LOOK_STRUCTURES).filter(ls => ls.structureType === STRUCTURE_RAMPART).length === 0)
                .sort((a, b) => a.hits - b.hits)[0]);
        this.intents.push(CreepIntent.RANGED_ATTACK);
        return true;
    }
    if (!((_a = this.room.controller) === null || _a === void 0 ? void 0 : _a.my)) {
        const walls = this.pos.findInRange(FIND_STRUCTURES, 3).filter(s => s.structureType === STRUCTURE_WALL);
        if (walls.length > 0) {
            this.rangedAttack(walls.sort((a, b) => a.hits - b.hits)[0]);
            this.intents.push(CreepIntent.RANGED_ATTACK);
            return true;
        }
    }
    return false;
};
Creep.prototype.bestAttack = function (targetPos) {
    if (!this.attackPower) {
        return false;
    }
    const hostileCreep = () => {
        return this.pos.findInRange(FIND_HOSTILE_CREEPS, 1).sort((a, b) => a.hits - b.hits)[0];
    };
    const hostilePowerCreep = () => {
        return this.pos.findInRange(FIND_HOSTILE_POWER_CREEPS, 1).sort((a, b) => a.hits - b.hits)[0];
    };
    const targetStructure = () => {
        var _a, _b;
        if (this.room.my) {
            return;
        }
        if (!targetPos) {
            return;
        }
        if (!this.pos.inRangeTo(targetPos, 1)) {
            return;
        }
        if ((_b = (_a = this.room.controller) === null || _a === void 0 ? void 0 : _a.reservation) === null || _b === void 0 ? void 0 : _b.username) {
            if (this.room.controller.reservation.username === USERNAME.ME) {
                return;
            }
            if (FRIENDLIES.includes(this.room.controller.reservation.username)) {
                return;
            }
        }
        return targetPos.lookFor(LOOK_STRUCTURES)[0];
    };
    const nonRampartStructure = () => {
        var _a, _b;
        if (this.room.my) {
            return;
        }
        if (this.room.mem.type !== RoomTypeEnum.STANDART) {
            return;
        }
        if ((_b = (_a = this.room.controller) === null || _a === void 0 ? void 0 : _a.reservation) === null || _b === void 0 ? void 0 : _b.username) {
            if (this.room.controller.reservation.username === USERNAME.ME) {
                return;
            }
            if (FRIENDLIES.includes(this.room.controller.reservation.username)) {
                return;
            }
        }
        return this.pos
            .findInRange(FIND_STRUCTURES, 1)
            .filter(s => !s.pos.rampart)
            .sort((a, b) => a.hits - b.hits)[0];
    };
    const structure = () => {
        var _a, _b;
        if (this.room.my) {
            return;
        }
        if (this.room.mem.type !== RoomTypeEnum.STANDART) {
            return;
        }
        if ((_b = (_a = this.room.controller) === null || _a === void 0 ? void 0 : _a.reservation) === null || _b === void 0 ? void 0 : _b.username) {
            if (this.room.controller.reservation.username === USERNAME.ME) {
                return;
            }
            if (FRIENDLIES.includes(this.room.controller.reservation.username)) {
                return;
            }
        }
        return this.pos.findInRange(FIND_STRUCTURES, 1).sort((a, b) => a.hits - b.hits)[0];
    };
    const hostile = hostileCreep() || hostilePowerCreep() || targetStructure() || nonRampartStructure() || structure();
    if (!hostile) {
        return false;
    }
    this.attack(hostile);
    return true;
};
Creep.prototype.idle = function () {
    if (!this.memory.idleUntill) {
        return false;
    }
    const remaining = this.memory.idleUntill - Game.time;
    if (remaining < 0) {
        return false;
    }
    this.say(`😴 ${remaining}`);
    return true;
};
Creep.prototype.elTransfer = function (params) {
    if (!params.resourceType) {
        params.resourceType = Object.keys(this.store)[0];
    }
    if (!params.resourceType) {
        return;
    }
    const distance = this.pos.getRangeTo(params.target);
    if (distance <= 1) {
        this.transfer(params.target, params.resourceType, params.amount);
        if (params.nextTick && !this._nextTickPlanned) {
            this._nextTickPlanned = true;
            params.nextTick();
        }
    }
    else {
        this.moveTo(params.target, params.travelOptions);
    }
};
Creep.prototype.elWithdraw = function (params) {
    if (!params.resourceType && "store" in params.target && params.target.store) {
        params.resourceType = Object.keys(params.target.store)[0];
    }
    if (!params.resourceType) {
        return;
    }
    const distance = this.pos.getRangeTo(params.target);
    if (distance <= 1) {
        this.withdraw(params.target, params.resourceType, params.amount);
        if (params.after) {
            params.after();
        }
    }
    else {
        this.moveTo(params.target, params.travelOptions);
    }
};
Object.defineProperty(Creep.prototype, "homeRoom", {
    get() {
        const creep = this;
        if (creep._homeRoom === undefined) {
            creep._homeRoom = creep.memory.homeRoom ? Game.rooms[creep.memory.homeRoom] || null : null;
        }
        return creep._homeRoom;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "homeRoomModel", {
    get() {
        const creep = this;
        if (creep._homeRoomModel === undefined) {
            creep._homeRoomModel = creep.memory.homeRoom ? RoomModel.get(creep.memory.homeRoom) : null;
        }
        return creep._homeRoomModel;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "targetRoomModel", {
    get() {
        const creep = this;
        if (creep._targetRoomModel === undefined) {
            creep._targetRoomModel = creep.memory.targetRoom ? RoomModel.get(creep.memory.targetRoom) : null;
        }
        return creep._targetRoomModel;
    },
    enumerable: false,
    configurable: true
});
Creep.prototype.getFirstResource = function () {
    if (this._getFirstResource === undefined) {
        this._getFirstResource = Object.keys(this.store)[0] || null;
    }
    return this._getFirstResource;
};
Creep.prototype.getLastResource = function () {
    if (this._getLastResource === undefined) {
        const resources = Object.keys(this.store);
        this._getLastResource = resources[resources.length - 1] || null;
    }
    return this._getLastResource;
};
Creep.prototype.isInvader = function () {
    var _a;
    if (this._isInvader === undefined) {
        this._isInvader = ((_a = this.owner) === null || _a === void 0 ? void 0 : _a.username) === "Invader";
    }
    return this._isInvader;
};
Creep.prototype.isBoosted = function (minParts = 1) {
    return this.body.filter(b => b.boost).length >= minParts;
};
Creep.prototype.isLootbox = function () {
    var _a;
    if (this._isLootbox === undefined) {
        this._isLootbox = ((_a = this.owner) === null || _a === void 0 ? void 0 : _a.username) === "Screeps";
    }
    return this._isLootbox;
};
Object.defineProperty(Creep.prototype, "source", {
    set(source) {
        const creep = this;
        creep.memory.sourceId = source ? source.id : undefined;
        creep._source = source;
    },
    get() {
        const creep = this;
        if (creep._source === undefined) {
            creep._source = creep.memory.sourceId ? Game.getObjectById(creep.memory.sourceId) || null : null;
        }
        return creep._source;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "mineral", {
    get() {
        const creep = this;
        if (creep._mineral === undefined) {
            creep._mineral = creep.memory.mineralId ? Game.getObjectById(creep.memory.mineralId) || null : null;
        }
        return creep._mineral;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "harvestPower", {
    get() {
        const creep = this;
        if (creep._harvestPower === undefined) {
            creep._harvestPower = creep.body.filter(b => b.type === WORK).length * 2;
        }
        return creep._harvestPower;
    },
    enumerable: false,
    configurable: true
});
Creep.prototype.unboost = function () {
    if (!this.body.find(b => b.boost)) {
        return false;
    }
    const lab = this.room
        .find(FIND_STRUCTURES)
        .find(s => s.structureType === STRUCTURE_LAB && s.cooldown === 0);
    if (!lab) {
        return false;
    }
    if (lab.unboostCreep(this) === ERR_NOT_IN_RANGE) {
        this.travel(lab);
    }
    return true;
};
Creep.prototype.recycleFinal = function (ticksUnder) {
    if (ticksUnder && this.ticksToLive && this.ticksToLive > ticksUnder) {
        return false;
    }
    if (!this.memory.recycling) {
        this.memory.recycling = true;
    }
    const moveToHomeRoom = () => {
        var _a;
        if ((_a = this.room.controller) === null || _a === void 0 ? void 0 : _a.my) {
            return false;
        }
        if (!this.memory.homeRoom) {
            Log.object(this, "missing home room in Misc");
            return false;
        }
        if (this.memory.homeRoom === this.room.name) {
            return false;
        }
        this.travelToRoom(this.memory.homeRoom, { ignoreHostiles: false });
        return true;
    };
    const storeResources = () => {
        if (this.store.getUsedCapacity() === 0) {
            return false;
        }
        const storage = this.room.storage || this.room.terminal;
        if (!storage || storage.room.level < 4) {
            return false;
        }
        const resource = Resources.firstStoreResource(this.store);
        if (!resource) {
            return false;
        }
        const distance = this.pos.getRangeTo(storage);
        if (distance > 1) {
            this.travel(storage);
        }
        else {
            this.transfer(storage, resource);
        }
        return true;
    };
    const unboost = () => {
        if (!this.ticksToLive) {
            return false;
        }
        if (this.ticksToLive > CREEP_LIFE_TIME / 2 + 50) {
            return false;
        }
        if (this.body.filter(b => b.boost).length === 0) {
            return false;
        }
        const lab = this.room.labs.filter(l => l.cachedIsActive()).sort((a, b) => a.cooldown - b.cooldown)[0];
        if (!lab) {
            return false;
        }
        if (lab.cooldown > this.ticksToLive) {
            return false;
        }
        const labContainer = lab.pos.findInRange(FIND_STRUCTURES, 1, {
            filter: s => s.structureType === STRUCTURE_CONTAINER
        })[0];
        const distance = this.pos.getRangeTo(lab);
        if (labContainer && this.pos.getRangeTo(labContainer) > 0) {
            this.travel(labContainer, { range: 0 });
        }
        else if (distance > 1) {
            this.travel(lab);
        }
        else if (lab.cooldown) {
            return true;
        }
        else {
            lab.unboostCreep(this);
        }
        return true;
    };
    const recycle = () => {
        if (!this.ticksToLive) {
            return false;
        }
        if (this.ticksToLive < 100) {
            this.die();
            return true;
        }
        const spawn = this.room.myActiveSpawns.sort((a, b) => { var _a, _b; return (((_a = a.spawning) === null || _a === void 0 ? void 0 : _a.remainingTime) || 0) - (((_b = b.spawning) === null || _b === void 0 ? void 0 : _b.remainingTime) || 0); })[0];
        if (!spawn) {
            return false;
        }
        if (spawn.spawning && spawn.pos.getRangeTo(this) <= 5) {
            if (spawn.spawning.remainingTime > this.ticksToLive) {
                return false;
            }
            this.idleAwayFrom([STRUCTURE_SPAWN, STRUCTURE_STORAGE, STRUCTURE_TERMINAL], 2);
            return true;
        }
        const container = spawn.pos.findInRange(FIND_STRUCTURES, 1, {
            filter: s => s.structureType === STRUCTURE_CONTAINER
        })[0];
        if (container) {
            if (!container.pos.isEqualTo(this)) {
                this.travel(container, { range: 0 });
            }
            else {
                spawn.recycleCreepSafe(this);
            }
        }
        else {
            const distance = this.pos.getRangeTo(spawn);
            if (distance > 1) {
                this.travel(spawn);
            }
            else if (spawn.spawning) {
                return true;
            }
            else {
                spawn.recycleCreepSafe(this);
            }
        }
        return true;
    };
    const suicide = () => {
        const storage = this.room.storage || this.room.terminal;
        if (storage) {
            const distance = this.pos.getRangeTo(storage);
            if (distance > 1) {
                this.travel(storage);
            }
            else {
                this.die();
            }
        }
        else {
            this.die();
        }
        return true;
    };
    const moveToCenter = () => {
        if (!this.room.center) {
            return false;
        }
        const distance = this.pos.getRangeTo(this.room.center);
        if (distance <= 3) {
            return false;
        }
        this.travel({ pos: this.room.center }, { range: 3 });
        return true;
    };
    return moveToHomeRoom() || storeResources() || unboost() || recycle() || moveToCenter() || suicide();
};
Creep.prototype.renew = function (upTo) {
    if (!this.ticksToLive) {
        return false;
    }
    if (this.ticksToLive > upTo) {
        return false;
    }
    if (this.body.filter(b => b.boost).length > 0) {
        return false;
    }
    const spawn = this.pos.findClosestByRange(FIND_MY_SPAWNS, {
        filter: s => !s.spawning && !s.actionPending
    });
    if (!spawn) {
        return true;
    }
    spawn.renewCreepV2(this);
    return true;
};
Creep.prototype.travel = function (target, opts) {
    if (this.pos.roomName !== target.pos.roomName) {
        Game.map.visual.line(this.pos, target.pos);
    }
    else {
        new RoomVisual(this.pos.roomName).line(this.pos, target.pos, {
            color: this.memory.color || "#fff",
            lineStyle: "dashed",
            opacity: 0.3
        });
    }
    const response = new Traveler(this, target, Object.assign({ costPlain: this.moveSpeed.plain, costSwamp: this.moveSpeed.swamp }, opts)).move();
    // const response = travel(this, target, {
    //   costPlain: this.moveSpeed.plain,
    //   costSwamp: this.moveSpeed.swamp,
    //   ...opts
    // });
    if (response) {
        this.intentCount++;
    }
    return response;
};
Creep.prototype.healMele = function () {
    if (!this.healPower) {
        return false;
    }
    const woundedMele = this.pos
        .findInRange(FIND_MY_CREEPS, 1)
        .filter(c => c.hitsMax !== c.hits)
        .sort((a, b) => a.hits - b.hits)[0];
    if (!woundedMele) {
        return false;
    }
    return this.heal(woundedMele) === OK;
};
Creep.prototype.prehealMele = function () {
    if (!this.healPower) {
        return false;
    }
    const highestPotentialDamageTakenAlly = this.pos.findInRange(FIND_MY_CREEPS, 1).sort((a, b) => b.expectedDamageTakenNextTick2({
        hostileCreeps: true,
        hostileTowers: true,
        npcCreeps: true,
        npcTowers: true,
        myCreeps: false,
        myTowers: false
    }) -
        a.expectedDamageTakenNextTick2({
            hostileCreeps: true,
            hostileTowers: true,
            npcCreeps: true,
            npcTowers: true,
            myCreeps: false,
            myTowers: false
        }))[0];
    if (!highestPotentialDamageTakenAlly) {
        return false;
    }
    if (highestPotentialDamageTakenAlly.expectedDamageTakenNextTick2({
        hostileCreeps: true,
        hostileTowers: true,
        npcCreeps: true,
        npcTowers: true,
        myCreeps: false,
        myTowers: false
    }) === 0) {
        return false;
    }
    return this.heal(highestPotentialDamageTakenAlly) === OK;
};
Creep.prototype.escapeAnyTargetRoomHostilesToHomeRoom = function () {
    if (!this.memory.targetRoom) {
        return false;
    }
    const roomModel = new RoomModel(this.memory.targetRoom);
    const hostilePower = roomModel.hostileAttackPower +
        roomModel.npcAttackPower +
        roomModel.hostileRangedAttackPower +
        roomModel.npcRangedAttackPower;
    if (hostilePower === 0) {
        return false;
    }
    if (!this.memory.homeRoom) {
        return false;
    }
    const homeRoomCenter = new RoomPosition(25, 25, this.memory.homeRoom);
    if (this.pos.getRangeTo(homeRoomCenter) > 20) {
        this.travel({ pos: homeRoomCenter }, {
            range: 15
        });
    }
    return true;
};
Creep.prototype.travelToWithinRoom = function (destination, range = 0) {
    if (this.pos.roomName !== destination.roomName) {
        console.log(`Fail, Creep ${String(this.memory.role)} in room ${this.pos.roomName} trying to move in ${destination.roomName} room`);
        return ERR_NO_PATH;
    }
    const distance = destination.getRangeTo(this.pos);
    if (distance <= range)
        return OK;
    return this.moveTo(destination, {
        maxRooms: 1,
        costCallback(roomName, costMatrix) {
            Geo.roomEdges().forEach(p => {
                costMatrix.set(p.x, p.y, 255);
            });
            return costMatrix;
        }
    });
};
Creep.prototype.travelToIdlePlace = function () {
    const onRoad = this.room.lookForAt(LOOK_STRUCTURES, this.pos).find(s => s.structureType === STRUCTURE_ROAD) === undefined;
    const onConstruction = this.room.lookForAt(LOOK_CONSTRUCTION_SITES, this.pos).length > 0;
    if (onRoad || onConstruction) {
        new RoomVisual(this.pos.roomName).circle(this.pos, {
            radius: 0.45,
            fill: "transparent",
            stroke: "#fff",
            strokeWidth: 0.15,
            opacity: 0.5
        });
        return false;
    }
    const idlePlace = this.room
        .lookForAtArea(LOOK_TERRAIN, Math.max(this.pos.y - 5, 1), Math.max(this.pos.x - 5, 1), Math.min(this.pos.y + 5, 48), Math.min(this.pos.x + 5, 48), true)
        .filter(t => t.terrain !== "wall" &&
        this.room
            .lookAt(t.x, t.y)
            .filter(obj => obj.type === "creep" ||
            obj.type === "constructionSite" ||
            (obj.type === "structure" && obj.structure && obj.structure.structureType !== STRUCTURE_RAMPART)).length === 0
    // this.room.lookForAt(LOOK_STRUCTURES, t.x, t.y).filter(s => s.structureType !== STRUCTURE_RAMPART).length ===
    //   0 &&
    // this.room.lookForAt(LOOK_CREEPS, t.x, t.y).length === 0 &&
    // this.room.lookForAt(LOOK_CONSTRUCTION_SITES, t.x, t.y).length === 0
    )
        .sort((a, b) => this.pos.getRangeTo(a.x, a.y) - this.pos.getRangeTo(b.x, b.y))[0];
    if (!idlePlace)
        return false;
    this.travel({ pos: new RoomPosition(idlePlace.x, idlePlace.y, this.room.name) });
    return true;
};
Creep.prototype.travelToRoom = function (destinationRoomName, options) {
    if (this.room.name === destinationRoomName) {
        if (!this.pos.isRoomEdge) {
            return false;
        }
        const pos = this.pos.openSpots.filter(p => !p.isRoomEdge && !p.hasCreep)[0];
        if (!pos) {
            Log.object(this, "Cant enter room from edge");
            return false;
        }
        this.moveTo(pos);
        return true;
    }
    return this.travel({ pos: new RoomPosition(25, 25, destinationRoomName) }, Object.assign({ range: 24 }, options));
};
Object.defineProperty(Creep.prototype, "healPower", {
    get() {
        const creep = this;
        if (creep._healPower === undefined) {
            creep._healPower = creep.body.reduce((creepPower, part) => {
                if (part.type !== HEAL || !part.hits) {
                    return creepPower;
                }
                const multiplier = part.boost ? BOOSTS.heal[part.boost].heal || 1 : 1;
                const partHealPower = HEAL_POWER * multiplier;
                return creepPower + partHealPower;
            }, 0);
        }
        return creep._healPower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "attackPower", {
    get() {
        const creep = this;
        if (creep._attackPower === undefined) {
            creep._attackPower = creep.body.reduce((creepPower, part) => {
                if (part.type !== ATTACK || !part.hits) {
                    return creepPower;
                }
                const multiplier = part.boost ? BOOSTS.attack[part.boost].attack : 1;
                const partHealPower = ATTACK_POWER * multiplier;
                return creepPower + partHealPower;
            }, 0);
        }
        return creep._attackPower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "isInHomeRoom", {
    get() {
        const creep = this;
        if (creep._isInHomeRoom === undefined) {
            creep._isInHomeRoom = creep.memory.homeRoom === creep.room.name;
        }
        return creep._isInHomeRoom;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "dismantlePower", {
    get() {
        const creep = this;
        if (creep._dismantlePower === undefined) {
            creep._dismantlePower = creep.body.reduce((creepPower, part) => {
                if (part.type !== WORK || !part.hits) {
                    return creepPower;
                }
                let multiplier = 1;
                if (part.boost) {
                    const boostEffects = BOOSTS.work[part.boost];
                    if ("dismantle" in boostEffects) {
                        multiplier = boostEffects.dismantle;
                    }
                }
                const partDismantlePower = DISMANTLE_POWER * multiplier;
                return creepPower + partDismantlePower;
            }, 0);
        }
        return creep._dismantlePower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "toughReducedHits", {
    get() {
        const creep = this;
        if (creep._toughReducedHits === undefined) {
            creep._toughReducedHits = creep.body
                .filter(b => b.type === TOUGH && b.boost && b.hits)
                .reduce((total, part) => total + part.hits, 0);
        }
        return creep._toughReducedHits;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "upgradePower", {
    get() {
        const creep = this;
        if (creep._upgradePower === undefined) {
            creep._upgradePower = creep.body.reduce((creepPower, part) => {
                if (part.type !== WORK || !part.hits) {
                    return creepPower;
                }
                let multiplier = 1;
                if (part.boost) {
                    const boostEffects = BOOSTS.work[part.boost];
                    if ("upgradeController" in boostEffects) {
                        multiplier = boostEffects.upgradeController;
                    }
                }
                const partUpgradePower = UPGRADE_CONTROLLER_POWER * multiplier;
                return creepPower + partUpgradePower;
            }, 0);
        }
        return creep._upgradePower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "rangedAttackPower", {
    get() {
        const creep = this;
        if (creep._rangedAttackPower === undefined) {
            creep._rangedAttackPower = creep.body.reduce((creepPower, part) => {
                if (part.type !== RANGED_ATTACK || !part.hits) {
                    return creepPower;
                }
                const multiplier = part.boost ? BOOSTS.ranged_attack[part.boost].rangedAttack || 1 : 1;
                const partHealPower = RANGED_ATTACK_POWER * multiplier;
                return creepPower + partHealPower;
            }, 0);
        }
        return creep._rangedAttackPower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "targetRoom", {
    set(targetRoom) {
        const creep = this;
        if (targetRoom instanceof Room) {
            creep.memory.targetRoom = targetRoom.name;
            creep._targetRoom = targetRoom;
            return;
        }
        if (typeof targetRoom === "string") {
            creep.memory.targetRoom = targetRoom;
            creep._targetRoom = Game.rooms[targetRoom];
            return;
        }
        creep.memory.targetRoom = undefined;
        creep._targetRoom = null;
    },
    get() {
        const creep = this;
        if (creep._targetRoom === undefined) {
            const targetRoomName = creep.memory.targetRoom;
            const targetRoom = targetRoomName ? Game.rooms[targetRoomName] : undefined;
            creep._targetRoom = targetRoom || null;
        }
        return creep._targetRoom;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "targetFlag", {
    get() {
        const creep = this;
        if (creep._targetFlag === undefined) {
            const targetFlagName = creep.memory.targetFlag;
            const targetFlag = targetFlagName ? Game.flags[targetFlagName] : undefined;
            creep._targetFlag = targetFlag || null;
        }
        return creep._targetFlag;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "isUnderRampart", {
    get() {
        const creep = this;
        if (creep._isUnderRampart === undefined) {
            creep._isUnderRampart =
                creep.pos.lookFor(LOOK_STRUCTURES).filter(s => s.structureType === STRUCTURE_RAMPART).length > 0;
        }
        return creep._isUnderRampart;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "isOnRoomEdge", {
    get() {
        const creep = this;
        if (creep._isOnRoomEdge === undefined) {
            const edges = [0, 49];
            creep._isOnRoomEdge = edges.includes(creep.pos.x) || edges.includes(creep.pos.y);
        }
        return creep._isOnRoomEdge;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "potentialTowerDamage", {
    get() {
        const creep = this;
        if (creep._potentialTowerDamage === undefined) {
            creep._potentialTowerDamage = creep.room
                .find(FIND_STRUCTURES)
                .filter(s => s.structureType === STRUCTURE_TOWER && s.store.energy >= TOWER_ENERGY_COST)
                .reduce((total, tower) => {
                let r = creep.pos.getRangeTo(tower);
                let amount = TOWER_POWER_ATTACK;
                if (r > TOWER_OPTIMAL_RANGE) {
                    if (r > TOWER_FALLOFF_RANGE) {
                        r = TOWER_FALLOFF_RANGE;
                    }
                    amount -=
                        (amount * TOWER_FALLOFF * (r - TOWER_OPTIMAL_RANGE)) / (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
                }
                return total + amount;
            }, 0);
        }
        return creep._potentialTowerDamage;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "target", {
    set(target) {
        const creep = this;
        creep.memory.targetId = target ? target.id : undefined;
        creep._target = target;
    },
    get() {
        const creep = this;
        if (creep._target === undefined) {
            creep._target = creep.memory.targetId ? Game.getObjectById(creep.memory.targetId) : null;
        }
        return creep._target;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "preheal", {
    set(amount) {
        const creep = this;
        creep._preheal = (creep._preheal || 0) + amount;
    },
    get() {
        const creep = this;
        return creep._preheal || 0;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "routeBetweenHomeAndTargetRooms", {
    get() {
        const creep = this;
        if (creep._routeBetweenHomeAndTargetRooms === undefined) {
            const route = {};
            if (creep.memory.homeRoom) {
                route[creep.memory.homeRoom] = true;
            }
            else {
                console.log(`Creep ${String(creep.memory.role)} has no homeRoom defined, routeBetweenHomeAndTargetRooms might be returning bad results`);
            }
            if (creep.memory.targetRoom) {
                route[creep.memory.targetRoom] = true;
            }
            else {
                console.log(`Creep ${String(creep.memory.role)} has no targetRoom defined, routeBetweenHomeAndTargetRooms might be returning bad results`);
            }
            creep._routeBetweenHomeAndTargetRooms = route;
        }
        return creep._routeBetweenHomeAndTargetRooms;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "moveSpeed", {
    get() {
        const creep = this;
        if (creep._moveSpeed === undefined) {
            let totalCarry = creep.store.getUsedCapacity();
            let negativeFatigue = 0;
            let positiveFatigue = 0;
            creep.body.forEach(body => {
                if (body.type === MOVE) {
                    negativeFatigue += 2 * (body.boost ? BOOSTS[MOVE][body.boost].fatigue : 1);
                    return;
                }
                if (body.type === CARRY) {
                    if (!totalCarry)
                        return;
                    if (!body.hits)
                        return;
                    const multiplier = body.boost ? BOOSTS[CARRY][body.boost].capacity : 1;
                    totalCarry -= Math.min(totalCarry, CARRY_CAPACITY * multiplier);
                    positiveFatigue++;
                    return;
                }
                positiveFatigue++;
            });
            creep._moveSpeed = {
                road: Math.max(1, Math.ceil(positiveFatigue / negativeFatigue)),
                plain: Math.max(1, Math.ceil((positiveFatigue * 2) / negativeFatigue)),
                swamp: Math.max(1, Math.ceil((positiveFatigue * 10) / negativeFatigue))
            };
        }
        return creep._moveSpeed;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "duoMemory", {
    get() {
        const creep = this;
        if (creep._duoMemory === undefined) {
            creep._duoMemory = creep.memory.duoId && Memory.duos ? Memory.duos[creep.memory.duoId] || null : null;
        }
        return creep._duoMemory;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "isNPC", {
    get() {
        const creep = this;
        if (creep._isNPC === undefined) {
            creep._isNPC =
                creep.owner.username === USERNAME.SOURCE_KEEPER ||
                    creep.owner.username === USERNAME.INVADER ||
                    creep.owner.username === USERNAME.SCREEPS;
        }
        return creep._isNPC;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "targetConstructionSite", {
    set(constructionSite) {
        const creep = this;
        creep.memory.targetConstructionSiteId = constructionSite ? constructionSite.id : undefined;
        creep._targetConstructionSite = constructionSite;
    },
    get() {
        var _a;
        const creep = this;
        if (creep._targetConstructionSite === undefined) {
            creep._targetConstructionSite = creep.memory.targetConstructionSiteId
                ? Game.getObjectById(creep.memory.targetConstructionSiteId)
                : null;
            if ((_a = creep._targetConstructionSite) === null || _a === void 0 ? void 0 : _a.pos.lookFor(LOOK_CREEPS).length) {
                creep.memory.targetConstructionSiteId = undefined;
                creep._targetConstructionSite = null;
            }
            const newConstruction = creep.pos.findClosestByRange(FIND_MY_CONSTRUCTION_SITES, {
                filter: c => c.structureType !== STRUCTURE_RAMPART && c.pos.lookFor(LOOK_CREEPS).length === 0
            });
            if (newConstruction) {
                creep.memory.targetConstructionSiteId = newConstruction.id;
                creep._targetConstructionSite = newConstruction;
            }
        }
        return creep._targetConstructionSite;
    },
    enumerable: false,
    configurable: true
});
Creep.prototype.withdrawFromTerminal = function (resource, amount) {
    var _a;
    const terminal = this.room.terminal || ((_a = this.homeRoom) === null || _a === void 0 ? void 0 : _a.terminal);
    if (!terminal) {
        return false;
    }
    if (terminal.store[resource] < (amount || 50)) {
        return false;
    }
    if (this.withdraw(terminal, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
        this.travel(terminal);
    }
    return true;
};
Creep.prototype.withdrawFromStorage = function (resource, amount) {
    var _a;
    const storage = this.room.storage || ((_a = this.homeRoom) === null || _a === void 0 ? void 0 : _a.storage);
    if (!storage) {
        return false;
    }
    if (storage.store[resource] < (amount || 50)) {
        return false;
    }
    if (this.withdraw(storage, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
        this.travel(storage);
    }
    return true;
};
Creep.prototype.realDamageTaken = function (damage) {
    let damageReduce = 0;
    let damageEffective = damage;
    this.body.forEach(bodyPart => {
        if (!bodyPart.boost)
            return;
        if (damageEffective <= 0) {
            return;
        }
        let damageRatio = 1;
        if (bodyPart.boost &&
            BOOSTS[bodyPart.type][bodyPart.boost] &&
            BOOSTS[bodyPart.type][bodyPart.boost].damage) {
            damageRatio = BOOSTS[bodyPart.type][bodyPart.boost].damage;
        }
        const bodyPartHitsEffective = bodyPart.hits / damageRatio;
        damageReduce += Math.min(bodyPartHitsEffective, damageEffective) * (1 - damageRatio);
        damageEffective -= Math.min(bodyPartHitsEffective, damageEffective);
    });
    damage -= Math.round(damageReduce);
    return damage;
};
Object.defineProperty(Creep.prototype, "expectedDamageTaken", {
    get() {
        const creep = this;
        if (creep._expectedDamageTaken === undefined) {
            const creepDamage = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3).reduce((damage, hostileCreep) => {
                const distance = creep.pos.getRangeTo(hostileCreep);
                if (distance <= 1) {
                    return damage + hostileCreep.attackPower + hostileCreep.rangedAttackPower;
                }
                return damage + hostileCreep.rangedAttackPower;
            }, 0);
            const towerDamage = creep.room.towers.reduce((damage, tower) => {
                if (tower.my) {
                    return damage;
                }
                return damage + tower.attackPower(creep);
            }, 0);
            creep._expectedDamageTaken = creepDamage + towerDamage;
        }
        return creep._expectedDamageTaken;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "expectedDamageTakenFromMe", {
    get() {
        const creep = this;
        if (creep._expectedDamageTakenFromMe === undefined) {
            const creepDamage = creep.pos.findInRange(FIND_MY_CREEPS, 3).reduce((damage, myCreep) => {
                const distance = creep.pos.getRangeTo(myCreep);
                if (distance <= 1) {
                    return damage + myCreep.attackPower + myCreep.rangedAttackPower;
                }
                return damage + myCreep.rangedAttackPower;
            }, 0);
            const towerDamage = creep.room.towers.reduce((damage, tower) => {
                return damage + tower.attackPower(creep);
            }, 0);
            creep._expectedDamageTakenFromMe = creepDamage + towerDamage;
        }
        return creep._expectedDamageTakenFromMe;
    },
    enumerable: false,
    configurable: true
});
Creep.prototype.expectedDamageTakenV2 = function (ticks, attackerCallback = (creep) => creep.my) {
    const creepDamage = this.pos.findInRange(FIND_CREEPS, 10).reduce((damage, creep) => {
        if (!attackerCallback(creep)) {
            return damage;
        }
        const distance = this.pos.getRangeTo(creep);
        const distanceAddition = Math.max(0, ticks - (this.fatigue ? 0 : 1) - (creep.fatigue ? 0 : 1));
        if (distance <= 3 + distanceAddition) {
            damage += creep.rangedAttackPower;
        }
        if (distance <= 1 + distanceAddition) {
            damage += creep.attackPower;
        }
        return damage;
    }, 0);
    const towerDamage = this.room.towers.reduce((damage, tower) => {
        return damage + tower.attackPower(this);
    }, 0);
    return creepDamage + towerDamage;
};
Object.defineProperty(Creep.prototype, "expectedDamageTakenNextTick", {
    get() {
        const creep = this;
        if (creep._expectedDamageTakenNextTick === undefined) {
            const creepDamage = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 6).reduce((damage, hostileCreep) => {
                const distance = creep.pos.getRangeTo(hostileCreep);
                if (distance === 2 && hostileCreep.fatigue) {
                    return damage + hostileCreep.rangedAttackPower;
                }
                if (distance <= 2) {
                    return damage + hostileCreep.attackPower + hostileCreep.rangedAttackPower;
                }
                return damage + hostileCreep.rangedAttackPower;
            }, 0);
            const towerDamage = creep.room.towers.reduce((damage, tower) => {
                if (tower.my) {
                    return damage;
                }
                return damage + tower.attackPower(creep);
            }, 0);
            creep._expectedDamageTakenNextTick = creepDamage + towerDamage;
        }
        return creep._expectedDamageTakenNextTick;
    },
    enumerable: false,
    configurable: true
});
Creep.prototype.expectedDamageTakenNextTick2 = function (types) {
    types = Object.assign({ hostileCreeps: true, hostileTowers: true, npcCreeps: true, npcTowers: true, myCreeps: false, myTowers: false }, types);
    let damage = 0;
    if (types.hostileCreeps) {
        damage += this.pos
            .findInRange(FIND_HOSTILE_CREEPS, 6)
            .filter(c => !c.isNPC && !c.my)
            .reduce((d, hostileCreep) => {
            const distance = this.pos.getRangeTo(hostileCreep);
            if (distance === 2 && hostileCreep.fatigue) {
                return damage + hostileCreep.rangedAttackPower;
            }
            if (distance <= 2) {
                return d + hostileCreep.attackPower + hostileCreep.rangedAttackPower;
            }
            return d + hostileCreep.rangedAttackPower;
        }, 0);
    }
    if (types.npcCreeps) {
        damage += this.pos
            .findInRange(FIND_HOSTILE_CREEPS, 6)
            .filter(c => c.isNPC && !c.my)
            .reduce((d, hostileCreep) => {
            const distance = this.pos.getRangeTo(hostileCreep);
            if (distance === 2 && hostileCreep.fatigue) {
                return damage + hostileCreep.rangedAttackPower;
            }
            if (distance <= 2) {
                return d + hostileCreep.attackPower + hostileCreep.rangedAttackPower;
            }
            return d + hostileCreep.rangedAttackPower;
        }, 0);
    }
    if (types.myCreeps) {
        damage += this.pos.findInRange(FIND_MY_CREEPS, 6).reduce((d, hostileCreep) => {
            const distance = this.pos.getRangeTo(hostileCreep);
            if (distance === 2 && hostileCreep.fatigue) {
                return damage + hostileCreep.rangedAttackPower;
            }
            if (distance <= 2) {
                return d + hostileCreep.attackPower + hostileCreep.rangedAttackPower;
            }
            return d + hostileCreep.rangedAttackPower;
        }, 0);
    }
    if (types.hostileTowers) {
        damage += this.room.towers
            .filter(t => !t.isNPC && !t.my)
            .reduce((d, tower) => {
            return d + tower.attackPower(this);
        }, 0);
    }
    if (types.npcTowers) {
        damage += this.room.towers
            .filter(t => t.isNPC && !t.my)
            .reduce((d, tower) => {
            return d + tower.attackPower(this);
        }, 0);
    }
    if (types.myTowers) {
        damage += this.room.towers
            .filter(t => t.my)
            .reduce((d, tower) => {
            return d + tower.attackPower(this);
        }, 0);
    }
    return damage;
};
Object.defineProperty(Creep.prototype, "intentCount", {
    set(value) {
        const creep = this;
        creep._intentCount = value;
    },
    get() {
        const creep = this;
        if (creep._intentCount === undefined) {
            creep._intentCount = 0;
        }
        return creep._intentCount;
    },
    enumerable: false,
    configurable: true
});
Creep.prototype.kite = function () {
    var _a;
    if (((_a = this.room.controller) === null || _a === void 0 ? void 0 : _a.my) && this.room.controller.safeMode) {
        return false;
    }
    const hostiles = this.room.find(FIND_HOSTILE_CREEPS, {
        filter: c => !c.isNPC && c.attackPower + c.rangedAttackPower > 0
    });
    const closeHostiles = hostiles.filter(h => h.pos.getRangeTo(this) <= 4);
    if (closeHostiles.length === 0) {
        const hostilesInLimboRange = hostiles.filter(h => h.pos.getRangeTo(this) === 5);
        if (hostilesInLimboRange.length > 0) {
            return true;
        }
        return false;
    }
    const ret = PathFinder.search(this.pos, hostiles.map(h => ({ pos: h.pos, range: 5 })), {
        swampCost: 10,
        flee: true,
        roomCallback(roomName) {
            const matrix = new PathFinder.CostMatrix();
            const room = Game.rooms[roomName];
            if (room) {
                room.find(FIND_CREEPS).forEach(c => {
                    matrix.set(c.pos.x, c.pos.y, 100);
                });
                room
                    .find(FIND_STRUCTURES, {
                    filter: s => s.structureType !== STRUCTURE_ROAD && s.structureType !== STRUCTURE_CONTAINER
                })
                    .forEach(s => {
                    matrix.set(s.pos.x, s.pos.y, 256);
                });
            }
            return matrix;
        }
    });
    if (ret.incomplete) {
        console.log("no path to escape");
        Log.object(this, "no path to escape");
        return false;
    }
    this.moveByPath(ret.path);
    return false;
};
Creep.prototype.kiteSk = function () {
    const hostiles = [
        ...this.room.find(FIND_HOSTILE_CREEPS, { filter: c => c.attackPower + c.rangedAttackPower > 0 }),
        ...this.room.find(FIND_HOSTILE_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_KEEPER_LAIR && s.ticksToSpawn && s.ticksToSpawn < 10
        })
    ];
    const hostilesInLimboRange = hostiles.filter(h => h.pos.getRangeTo(this) === 5);
    const hostilesClose = hostiles.filter(h => h.pos.getRangeTo(this) <= 5);
    if (hostilesInLimboRange.length && hostilesInLimboRange.length === hostilesClose.length) {
        this.say("👻");
        return true;
    }
    const closeHostiles = hostiles.filter(h => h.pos.getRangeTo(this) <= 4);
    if (!closeHostiles.length) {
        return false;
    }
    this.say("👻+");
    closeHostiles.forEach(c => {
        this.room.visual.line(c.pos, this.pos);
    });
    const ret = PathFinder.search(this.pos, hostiles.map(h => ({ pos: h.pos, range: 6 })), {
        flee: true,
        roomCallback: (roomName) => {
            const matrix = Rooms.matrix(roomName);
            const room = Game.rooms[roomName];
            if (room) {
                room.find(FIND_CREEPS).forEach(c => {
                    if (c.id === this.id) {
                        return;
                    }
                    matrix.set(c.pos.x, c.pos.y, 100);
                });
            }
            return matrix;
        }
    });
    if (ret.incomplete) {
        Log.object(this, "no path to escape");
        return false;
    }
    this.say("👻+" + ret.path.length);
    this.moveByPath(ret.path);
    return true;
};
Creep.prototype.bestHeal = function () {
    if (!this.healPower) {
        return false;
    }
    if (this.intents.includes(CreepIntent.HEAL)) {
        return false;
    }
    if (this.intents.includes(CreepIntent.RANGED_HEAL)) {
        return false;
    }
    const woundedCreep = this.pos
        .findInRange(FIND_MY_CREEPS, 1)
        .filter(c => c.hits < c.hitsMax)
        .sort((a, b) => a.hits - b.hits)[0];
    if (!woundedCreep) {
        return false;
    }
    this.heal(woundedCreep);
    this.intents.push(CreepIntent.HEAL);
    return true;
};
Creep.prototype.bestRangedHeal = function () {
    if (!this.healPower) {
        return false;
    }
    if (this.intents.includes(CreepIntent.HEAL)) {
        return false;
    }
    if (this.intents.includes(CreepIntent.RANGED_HEAL)) {
        return false;
    }
    if (this.intents.includes(CreepIntent.RANGED_ATTACK)) {
        return false;
    }
    const woundedCreep = this.pos
        .findInRange(FIND_MY_CREEPS, 3)
        .filter(c => c.hits < c.hitsMax)
        .sort((a, b) => a.hits - b.hits)[0];
    if (!woundedCreep) {
        return false;
    }
    this.rangedHeal(woundedCreep);
    this.intents.push(CreepIntent.RANGED_HEAL);
    return true;
};
Object.defineProperty(Creep.prototype, "intents", {
    set(value) {
        const creep = this;
        creep._intents = value;
    },
    get() {
        const creep = this;
        if (creep._intents === undefined) {
            creep._intents = [];
        }
        return creep._intents;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "boostsMissing", {
    get() {
        const creep = this;
        if (creep._boostsMissing === undefined) {
            creep._boostsMissing =
                creep.isInHomeRoom && creep.memory.boosts
                    ? creep.memory.boosts
                        .filter(boost => creep.body.find(b => !b.boost && b.type === RESOURCE_BODY[boost]))
                        .map(boost => ({
                        boost,
                        amount: creep.body.filter(b => !b.boost && b.type === RESOURCE_BODY[boost]).length * LAB_BOOST_MINERAL
                    }))
                        .filter(b => {
                        let amount = 0;
                        if (creep.room.storage) {
                            amount += creep.room.storage.store.getUsedCapacity(b.boost);
                        }
                        if (creep.room.terminal) {
                            amount += creep.room.terminal.store.getUsedCapacity(b.boost);
                        }
                        if (creep.room.centerLab) {
                            amount += creep.room.centerLab.store.getUsedCapacity(b.boost);
                        }
                        if (creep.room.centerBalancerCreep) {
                            amount += creep.room.centerBalancerCreep.store.getUsedCapacity(b.boost);
                        }
                        return amount >= b.amount;
                    })
                    : [];
        }
        return creep._boostsMissing;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "isEnemy", {
    get() {
        const creep = this;
        if (creep._isEnemy === undefined) {
            creep._isEnemy = ENEMIES.includes(creep.owner.username);
        }
        return creep._isEnemy;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "isFriendly", {
    get() {
        const creep = this;
        if (creep._isFriendly === undefined) {
            creep._isFriendly = FRIENDLIES.includes(creep.owner.username);
        }
        return creep._isFriendly;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Creep.prototype, "links", {
    get() {
        const creep = this;
        if (creep._links === undefined) {
            creep._links = creep.memory.links
                ? creep.memory.links.reduce((links, linkId) => {
                    const link = Game.getObjectById(linkId);
                    if (link) {
                        links.push(link);
                    }
                    return links;
                }, [])
                : [];
        }
        return creep._links;
    },
    enumerable: false,
    configurable: true
});
Creep.prototype.boost = function (options) {
    if (!this.ticksToLive) {
        return false;
    }
    const minTicksToLive = (options === null || options === void 0 ? void 0 : options.minTicksToLive) === undefined ? 1400 : options.minTicksToLive;
    if (this.ticksToLive < minTicksToLive) {
        return false;
    }
    if (!this.isInHomeRoom) {
        return false;
    }
    if (!this.room.centerLab) {
        return false;
    }
    if (this.boostsMissing.length === 0) {
        return false;
    }
    const distance = this.pos.getRangeTo(this.room.centerLab);
    if (distance > 1) {
        this.travel(this.room.centerLab);
    }
    else {
        const currentBoost = this.boostsMissing.find(b => { var _a; return b.boost === ((_a = this.room.centerLab) === null || _a === void 0 ? void 0 : _a.mineralType) && this.room.centerLab.store.getUsedCapacity(b.boost) >= b.amount; });
        if (currentBoost) {
            this.room.centerLab.boostCreep(this);
        }
    }
    return true;
};
Creep.prototype.isEmpty = function (resource) {
    return this.store.getUsedCapacity(resource) === 0;
};
Creep.prototype.isFull = function () {
    return this.store.getFreeCapacity() === 0;
};
Creep.prototype.idleAwayFrom = function (types, range) {
    const closeStructures = this.pos.findInRange(FIND_STRUCTURES, range, {
        filter: s => types.includes(s.structureType)
    });
    if (closeStructures.length === 0) {
        return false;
    }
    const ret = PathFinder.search(this.pos, this.pos
        .findInRange(FIND_STRUCTURES, range * 4, { filter: s => types.includes(s.structureType) })
        .map(s => ({ pos: s.pos, range })), {
        flee: true,
        roomCallback: (roomName) => {
            const matrix = Rooms.matrix(roomName);
            this.pos.findInRange(FIND_CREEPS, range * 3).forEach(creep => {
                if (creep.id === this.id) {
                    return;
                }
                matrix.set(creep.pos.x, creep.pos.y, 200);
            });
            return matrix;
        }
    });
    if (ret.incomplete) {
        return false;
    }
    this.moveByPath(ret.path);
    return true;
};
Creep.prototype.autoAttack = function () {
    const target = this.pos.findInRange(FIND_HOSTILE_CREEPS, 1).sort((a, b) => a.hits - b.hits)[0] ||
        this.pos.findInRange(FIND_HOSTILE_POWER_CREEPS, 1).sort((a, b) => a.hits - b.hits)[0] ||
        this.pos.findInRange(FIND_HOSTILE_STRUCTURES, 1, { filter: s => !s.pos.hasRampart })[0] ||
        this.pos.findInRange(FIND_HOSTILE_STRUCTURES, 1)[0];
    if (!target) {
        return false;
    }
    this.attack(target);
    return true;
};
Creep.prototype.moveToSiegeFlagRoom = function (flag) {
    if (this.room.name === flag.pos.roomName) {
        return false;
    }
    const CUSTOM_ROUTES = {};
    const customRoute = CUSTOM_ROUTES[flag.pos.roomName];
    if (customRoute && this.room.name !== customRoute) {
        this.travelToRoom(customRoute, { ignoreHostiles: false });
    }
    else {
        this.travel(flag, { range: 1, ignoreHostiles: false });
    }
    return true;
};
Creep.prototype.die = function () {
    this.say("🗑️", true);
    return this.suicide() === OK;
};

PowerCreep.prototype.travelToIdlePlace = function () {
    if (!this.room)
        return false;
    if (this.room.lookForAt(LOOK_STRUCTURES, this.pos).find(s => s.structureType === STRUCTURE_ROAD) === undefined) {
        new RoomVisual(this.pos.roomName).circle(this.pos, {
            radius: 0.45,
            fill: "transparent",
            stroke: "#fff",
            strokeWidth: 0.15,
            opacity: 0.5
        });
        return false;
    }
    const idlePlace = this.room
        .lookForAtArea(LOOK_TERRAIN, Math.max(this.pos.y - 5, 0), Math.max(this.pos.x - 5, 0), Math.min(this.pos.y + 5, 49), Math.min(this.pos.x + 5, 49), true)
        .filter(t => this.room &&
        t.terrain === "plain" &&
        this.room.lookForAt(LOOK_STRUCTURES, t.x, t.y).filter(s => s.structureType !== STRUCTURE_RAMPART).length ===
            0 &&
        this.room.lookForAt(LOOK_CREEPS, t.x, t.y).length === 0)
        .sort((a, b) => this.pos.getRangeTo(a.x, a.y) - this.pos.getRangeTo(b.x, b.y))[0];
    if (!idlePlace)
        return false;
    this.moveTo(new RoomPosition(idlePlace.x, idlePlace.y, this.room.name), { maxRooms: 1 });
    return true;
};
PowerCreep.prototype.travelToRoom = function (destinationRoomName, options) {
    if (!this.room)
        return false;
    if (this.room.name === destinationRoomName &&
        this.pos.x !== 49 &&
        this.pos.x !== 0 &&
        this.pos.y !== 49 &&
        this.pos.y !== 0)
        return false;
    const response = this.moveTo(new RoomPosition(25, 25, destinationRoomName), Object.assign(Object.assign({}, options), { range: 15 }));
    return response === 0 || response === -11;
};
Object.defineProperty(PowerCreep.prototype, "isUnderRampart", {
    get() {
        const creep = this;
        if (creep._isUnderRampart === undefined) {
            creep._isUnderRampart =
                creep.pos.lookFor(LOOK_STRUCTURES).filter(s => s.structureType === STRUCTURE_RAMPART).length > 0;
        }
        return creep._isUnderRampart;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(PowerCreep.prototype, "moveSpeed", {
    get() {
        return {
            road: 1,
            plain: 1,
            swamp: 1
        };
    },
    enumerable: false,
    configurable: true
});
PowerCreep.prototype.travel = function (target, opts) {
    if (this.pos.roomName !== target.pos.roomName) {
        Game.map.visual.line(this.pos, target.pos);
    }
    return new Traveler(this, target, opts).move();
};
Object.defineProperty(PowerCreep.prototype, "homeRoom", {
    get() {
        const creep = this;
        if (creep._homeRoom === undefined) {
            const room = creep.memory.homeRoom ? Game.rooms[creep.memory.homeRoom] : undefined;
            creep._homeRoom = room && room.level >= 8 && room.my && room.myCenterPowerSpawn ? room : null;
        }
        return creep._homeRoom;
    },
    enumerable: false,
    configurable: true
});

Flag.prototype.rampartDefence = function () {
    return this.color === COLOR_BROWN && this.secondaryColor === COLOR_BROWN;
};
Flag.prototype.isDismantlerDuo = function () {
    return this.color === COLOR_YELLOW && this.secondaryColor === COLOR_ORANGE;
};
Flag.prototype.isAttackerDuo = function () {
    return this.color === COLOR_RED && this.secondaryColor === COLOR_BLUE;
};
Object.defineProperty(Flag.prototype, "roomMem", {
    get() {
        const flag = this;
        return Rooms.memory(flag.pos.roomName);
    },
    enumerable: false,
    configurable: true
});

Object.defineProperty(Mineral.prototype, "container", {
    get() {
        const mineral = this;
        if (mineral._container === undefined) {
            mineral._container =
                mineral.pos
                    .findInRange(FIND_STRUCTURES, 1)
                    .find(s => s.structureType === STRUCTURE_CONTAINER) || null;
        }
        return mineral._container;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Mineral.prototype, "containerConstruction", {
    get() {
        const mineral = this;
        if (mineral._containerConstruction === undefined) {
            mineral._containerConstruction = mineral.pos
                .findInRange(FIND_CONSTRUCTION_SITES, 1)
                .find(s => s.structureType === STRUCTURE_CONTAINER);
        }
        return mineral._containerConstruction;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Mineral.prototype, "containers", {
    get() {
        const mineral = this;
        if (mineral._containers === undefined) {
            mineral._containers = mineral.pos
                .findInRange(FIND_STRUCTURES, 1)
                .filter(s => s.structureType === STRUCTURE_CONTAINER);
        }
        return mineral._containers;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Mineral.prototype, "containerConstructions", {
    get() {
        const mineral = this;
        if (mineral._containerConstructions === undefined) {
            mineral._containerConstructions = mineral.pos
                .findInRange(FIND_CONSTRUCTION_SITES, 1)
                .filter(s => s.structureType === STRUCTURE_CONTAINER);
        }
        return mineral._containerConstructions;
    },
    enumerable: false,
    configurable: true
});
Mineral.prototype.extractor = function () {
    if (this._extractor === undefined) {
        this._extractor = this.pos
            .findInRange(FIND_STRUCTURES, 1)
            .find(s => s.structureType === STRUCTURE_EXTRACTOR);
    }
    return this._extractor;
};

Object.defineProperty(Source.prototype, "container", {
    get() {
        const source = this;
        if (source._container === undefined) {
            source._container =
                source.pos
                    .findInRange(FIND_STRUCTURES, 1)
                    .find(s => s.structureType === STRUCTURE_CONTAINER) || null;
        }
        return source._container;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Source.prototype, "containerConstruction", {
    get() {
        const source = this;
        if (source._containerConstruction === undefined) {
            source._containerConstruction = source.pos
                .findInRange(FIND_CONSTRUCTION_SITES, 1)
                .find(s => s.structureType === STRUCTURE_CONTAINER);
        }
        return source._containerConstruction;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Source.prototype, "link", {
    get() {
        const source = this;
        if (source._link === undefined) {
            source._link = source.pos
                .findInRange(FIND_STRUCTURES, 2)
                .find(s => s.structureType === STRUCTURE_LINK);
        }
        return source._link;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Source.prototype, "links", {
    get() {
        const source = this;
        if (source._links === undefined) {
            source._links = source.pos
                .findInRange(FIND_STRUCTURES, 2)
                .filter(s => s.structureType === STRUCTURE_LINK && s.cachedIsActive());
        }
        return source._links;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Source.prototype, "linkConstructions", {
    get() {
        const source = this;
        if (source._linkConstructions === undefined) {
            source._linkConstructions = source.pos
                .findInRange(FIND_MY_CONSTRUCTION_SITES, 2)
                .filter(s => s.structureType === STRUCTURE_LINK);
        }
        return source._linkConstructions;
    },
    enumerable: false,
    configurable: true
});
const energyCapacityWithRegen = function (source) {
    let sourceCapacity = source.energyCapacity;
    if (!source.effects)
        return sourceCapacity;
    const effect = source.effects.find(e => e.effect === PWR_REGEN_SOURCE);
    if (!effect)
        return sourceCapacity;
    sourceCapacity += effect.level * 50 * (ENERGY_REGEN_TIME / 15);
    return sourceCapacity;
};
Object.defineProperty(Source.prototype, "energyCapacityWithRegen", {
    get() {
        const source = this;
        if (source._energyCapacityWithRegen === undefined) {
            source._energyCapacityWithRegen = energyCapacityWithRegen(source);
        }
        return source._energyCapacityWithRegen;
    },
    enumerable: false,
    configurable: true
});
Source.prototype.linkConstruction = function () {
    if (this._linkConstruction === undefined) {
        this._linkConstruction = this.pos
            .findInRange(FIND_CONSTRUCTION_SITES, 2)
            .find(s => s.structureType === STRUCTURE_LINK);
    }
    return this._linkConstruction;
};
Object.defineProperty(Source.prototype, "workPartsToDrain", {
    get() {
        const source = this;
        if (source._workPartsToDrain === undefined) {
            source._workPartsToDrain = Math.ceil(source.energyCapacityWithRegen / HARVEST_POWER / ENERGY_REGEN_TIME);
        }
        return source._workPartsToDrain;
    },
    enumerable: false,
    configurable: true
});

Object.defineProperty(RoomObject.prototype, "wpos", {
    get() {
        const roomObject = this;
        if (roomObject._wpos === undefined) {
            roomObject._wpos = WorldPosition.fromRoomPosition(roomObject.pos);
        }
        return roomObject._wpos;
    },
    configurable: true,
    enumerable: false
});

class Creeps {
    static init() {
        this._myCreeps = undefined;
        this._myCreepsGroupedByRole = undefined;
    }
    static get que() {
        return Memory.spawnQue || [];
    }
    static getByRole(role) {
        return this.myCreepsGroupedByRole[role] || [];
    }
    static queByRole(role) {
        return this.que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.role) === role; });
    }
    static get myCreeps() {
        if (this._myCreeps === undefined) {
            this._myCreeps = Object.values(Game.creeps);
        }
        return this._myCreeps;
    }
    static get myCreepsGroupedByRole() {
        if (this._myCreepsGroupedByRole === undefined) {
            this._myCreepsGroupedByRole = this.myCreeps.reduce((grouped, creep) => {
                if (!creep.memory.role) {
                    return grouped;
                }
                if (!grouped[creep.memory.role]) {
                    grouped[creep.memory.role] = [];
                }
                grouped[creep.memory.role].push(creep);
                return grouped;
            }, {});
        }
        return this._myCreepsGroupedByRole;
    }
    static creepsCount(filters) {
        return this.myCreeps.filter(creep => {
            if (filters === null || filters === void 0 ? void 0 : filters.role) {
                if (creep.memory.role !== filters.role) {
                    return false;
                }
            }
            if (filters === null || filters === void 0 ? void 0 : filters.targetRoom) {
                if (creep.memory.targetRoom !== filters.targetRoom) {
                    return false;
                }
            }
            if (filters === null || filters === void 0 ? void 0 : filters.targetFlag) {
                if (creep.memory.targetFlag !== filters.targetFlag) {
                    return false;
                }
            }
            if (filters === null || filters === void 0 ? void 0 : filters.homeRoom) {
                if (creep.memory.homeRoom !== filters.homeRoom) {
                    return false;
                }
            }
            if (filters === null || filters === void 0 ? void 0 : filters.targetId) {
                if (creep.memory.targetId !== filters.targetId) {
                    return false;
                }
            }
            if (filters === null || filters === void 0 ? void 0 : filters.sourceId) {
                if (creep.memory.sourceId !== filters.sourceId) {
                    return false;
                }
            }
            if (filters === null || filters === void 0 ? void 0 : filters.mineralId) {
                if (creep.memory.mineralId !== filters.mineralId) {
                    return false;
                }
            }
            if (filters === null || filters === void 0 ? void 0 : filters.minTicksToLive) {
                if (creep.ticksToLive && creep.ticksToLive < filters.minTicksToLive) {
                    return false;
                }
            }
            return true;
        }).length;
    }
    static creepsCountWithQue(filters) {
        const creepsCount = this.myCreeps.filter(creep => {
            if (filters === null || filters === void 0 ? void 0 : filters.role) {
                if (creep.memory.role !== filters.role) {
                    return false;
                }
            }
            if (filters === null || filters === void 0 ? void 0 : filters.targetRoom) {
                if (creep.memory.targetRoom !== filters.targetRoom) {
                    return false;
                }
            }
            if (filters === null || filters === void 0 ? void 0 : filters.targetFlag) {
                if (creep.memory.targetFlag !== filters.targetFlag) {
                    return false;
                }
            }
            if (filters === null || filters === void 0 ? void 0 : filters.homeRoom) {
                if (creep.memory.homeRoom !== filters.homeRoom) {
                    return false;
                }
            }
            if (filters === null || filters === void 0 ? void 0 : filters.targetId) {
                if (creep.memory.targetId !== filters.targetId) {
                    return false;
                }
            }
            if (filters === null || filters === void 0 ? void 0 : filters.sourceId) {
                if (creep.memory.sourceId !== filters.sourceId) {
                    return false;
                }
            }
            if (filters === null || filters === void 0 ? void 0 : filters.mineralId) {
                if (creep.memory.mineralId !== filters.mineralId) {
                    return false;
                }
            }
            if (filters === null || filters === void 0 ? void 0 : filters.minTicksToLive) {
                if (creep.ticksToLive && creep.ticksToLive < filters.minTicksToLive) {
                    return false;
                }
            }
            return true;
        }).length;
        const queueCount = Memory.spawnQue
            ? Memory.spawnQue.filter(que => {
                var _a, _b, _c, _d, _e, _f;
                if (filters === null || filters === void 0 ? void 0 : filters.role) {
                    if (((_a = que.memory) === null || _a === void 0 ? void 0 : _a.role) !== filters.role) {
                        return false;
                    }
                }
                if (filters === null || filters === void 0 ? void 0 : filters.targetRoom) {
                    if (((_b = que.memory) === null || _b === void 0 ? void 0 : _b.targetRoom) !== filters.targetRoom) {
                        return false;
                    }
                }
                if (filters === null || filters === void 0 ? void 0 : filters.targetFlag) {
                    if (((_c = que.memory) === null || _c === void 0 ? void 0 : _c.targetFlag) !== filters.targetFlag) {
                        return false;
                    }
                }
                if (filters === null || filters === void 0 ? void 0 : filters.homeRoom) {
                    if (!que.rooms.includes(filters.homeRoom)) {
                        return false;
                    }
                }
                if (filters === null || filters === void 0 ? void 0 : filters.targetId) {
                    if (((_d = que.memory) === null || _d === void 0 ? void 0 : _d.targetId) !== filters.targetId) {
                        return false;
                    }
                }
                if (filters === null || filters === void 0 ? void 0 : filters.sourceId) {
                    if (((_e = que.memory) === null || _e === void 0 ? void 0 : _e.sourceId) !== filters.sourceId) {
                        return false;
                    }
                }
                if (filters === null || filters === void 0 ? void 0 : filters.mineralId) {
                    if (((_f = que.memory) === null || _f === void 0 ? void 0 : _f.mineralId) !== filters.mineralId) {
                        return false;
                    }
                }
                return true;
            }).length
            : 0;
        return creepsCount + queueCount;
    }
    static visualCreepCpu(creep, callback) {
        var _a, _b;
        const start = Game.cpu.getUsed();
        callback();
        const end = Game.cpu.getUsed();
        const cpuUsed = end - start;
        (_a = creep.room) === null || _a === void 0 ? void 0 : _a.visual.circle(creep.pos.x, creep.pos.y, {
            radius: 0.75,
            fill: "transparent",
            stroke: getCreepCpuColor(cpuUsed),
            strokeWidth: 0.2,
            opacity: 0.3
            // color: getCreepCpuTextColor(cpuUsed)
        });
        if (cpuUsed > 0.6) {
            (_b = creep.room) === null || _b === void 0 ? void 0 : _b.visual.text(cpuUsed.toFixed(2), creep.pos.x, creep.pos.y - 0.75 + 0.1, {
                font: 0.2,
                // stroke: getCreepCpuColor(cpuUsed),
                align: "center",
                color: getCreepCpuTextColor(cpuUsed)
            });
        }
    }
    static getByDuoId(id) {
        return this.myCreeps.filter(creep => !creep.spawning).filter(creep => creep.memory.duoId === id);
    }
}

class Duo {
    constructor(memory) {
        this.memory = memory;
        const creeps = Creeps.getByDuoId(memory.id);
        this.attacker = creeps.find(c => c.memory.duoRole === "attacker" || c.memory.duoAttacker);
        this.healer = creeps.find(c => c.memory.duoRole === "healer" || c.memory.duoHealer);
        this.updateTicks();
    }
    updateTicks() {
        var _a, _b;
        if (this.memory.stage === DuoGroupStage.SPAWNING) {
            this.memory.ticksTo = 1500;
        }
        else {
            this.memory.ticksTo = Math.min(((_a = this.attacker) === null || _a === void 0 ? void 0 : _a.ticksToLive) || CREEP_LIFE_TIME, ((_b = this.healer) === null || _b === void 0 ? void 0 : _b.ticksToLive) || CREEP_LIFE_TIME);
        }
    }
    get targetFlag() {
        if (this._targetFlag === undefined) {
            this._targetFlag = this.memory.targetFlag ? Game.flags[this.memory.targetFlag] || null : null;
        }
        return this._targetFlag;
    }
    get targetRoom() {
        if (this._targetRoom === undefined) {
            this._targetRoom = this.memory.targetRoom ? Rooms.model(this.memory.targetRoom) : null;
        }
        return this._targetRoom;
    }
    handleSpawning() {
        var _a, _b, _c, _d;
        if (this.memory.stage !== DuoGroupStage.SPAWNING) {
            return false;
        }
        (_a = this.attacker) === null || _a === void 0 ? void 0 : _a.renew(1450);
        (_b = this.healer) === null || _b === void 0 ? void 0 : _b.renew(1450);
        if ((((_c = this.attacker) === null || _c === void 0 ? void 0 : _c.ticksToLive) || 0) > 1400 && (((_d = this.healer) === null || _d === void 0 ? void 0 : _d.ticksToLive) || 0) > 1400) {
            this.memory.stage = DuoGroupStage.BOOSTING;
            return false;
        }
        return true;
    }
    handleBoosting() {
        if (!this.attacker) {
            return true;
        }
        if (!this.healer) {
            return true;
        }
        const attackerBoosted = this.attacker.boost({ minTicksToLive: 1000 });
        const healerBoosted = this.healer.boost({ minTicksToLive: 1000 });
        const boosted = !attackerBoosted && !healerBoosted;
        if (boosted) {
            this.memory.stage = DuoGroupStage.WORKING;
        }
        return true;
    }
    handleRetreating() {
        var _a;
        if (this.attacker) {
            this.attacker.recycleFinal();
        }
        if (this.healer) {
            this.healer.recycleFinal();
        }
        if (!this.attacker && !this.healer && ((_a = Memory.duos) === null || _a === void 0 ? void 0 : _a[this.memory.id])) {
            delete Memory.duos[this.memory.id];
        }
        return true;
    }
}

class Duos {
    static init() {
        this._duos = undefined;
    }
    static exit() {
        General.interval(50, () => this.cleanBuggedOutDuos());
    }
    static cleanBuggedOutDuos() {
        for (const duoId in Memory.duos) {
            if (Memory.duos[duoId].createdAt < Game.time - 3000) {
                console.log("bugged out duo", JSON.stringify(Memory.duos[duoId], null, 2));
                Memory.duos[duoId].stage = DuoGroupStage.RETREATING;
            }
        }
    }
    static create(memory) {
        if (!Memory.duos) {
            Memory.duos = {};
        }
        const id = General.uniqueId();
        Memory.duos[id] = Object.assign(Object.assign({ createdAt: Game.time, stage: DuoGroupStage.SPAWNING }, memory), { ticksTo: 1500, id });
        return id;
    }
    static isSpawningInRoom(roomName) {
        if (!Memory.duos)
            return false;
        return (Object.values(Memory.duos).filter(duo => duo.homeRoom === roomName && duo.stage === DuoGroupStage.SPAWNING)
            .length > 0);
    }
    static values() {
        if (!Memory.duos) {
            return [];
        }
        return Object.values(Memory.duos);
    }
    static get duos() {
        if (this._duos === undefined) {
            this._duos = Memory.duos ? Object.values(Memory.duos).map(memory => new Duo(memory)) : [];
        }
        return this._duos;
    }
    static duosByName(name) {
        return this.duos.filter(duo => duo.memory.name === name);
    }
}
Duos._duos = undefined;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

class BodyParts {
    constructor() {
        this.body = [];
    }
    static new() {
        return new this();
    }
    add(part, count = 1) {
        for (let i = 0; i < count; i++) {
            this.body.push(part);
        }
        return this;
    }
    addMultiple(parts, count = 1) {
        for (let i = 0; i < count; i++) {
            this.body.push(...parts);
        }
        return this;
    }
    move(count = 1) {
        this.add(MOVE, count);
        return this;
    }
    claim(count = 1) {
        this.add(CLAIM, count);
        return this;
    }
    attack(count = 1) {
        this.add(ATTACK, count);
        return this;
    }
    rangedAttack(count = 1) {
        this.add(RANGED_ATTACK, count);
        return this;
    }
    tough(count = 1) {
        this.add(TOUGH, count);
        return this;
    }
    heal(count = 1) {
        this.add(HEAL, count);
        return this;
    }
    carry(count = 1) {
        this.add(CARRY, count);
        return this;
    }
    work(count = 1) {
        this.add(WORK, count);
        return this;
    }
    get() {
        return this.body.slice(0, 50);
    }
    length() {
        return this.body.length;
    }
}

class Spawns {
    static addToQue(rooms, { role, priority, body, optionalBody, memory, boosts, directionToCenter, maxQueTime, name }) {
        const roomNames = (Array.isArray(rooms) ? rooms : [rooms]).map(r => (typeof r === "string" ? r : r.name));
        if (roomNames.length === 0)
            return;
        if (!Memory.spawnQue) {
            Memory.spawnQue = [];
        }
        Memory.spawnQue.push({
            rooms: roomNames,
            role,
            priority,
            body: body instanceof BodyParts ? body.get() : body,
            optionalBody: optionalBody instanceof BodyParts ? optionalBody.get() : optionalBody,
            memory: Object.assign(Object.assign({}, memory), { role,
                boosts, createdAt: Game.time, color: "#" + (((1 + Math.random()) * (1 << 24)) | 0).toString(16).substr(-6) }),
            directionToCenter,
            name,
            createdAt: Game.time,
            expiresAt: Game.time + (maxQueTime || 300)
        });
        Memory.spawnQue = Memory.spawnQue.sort((a, b) => a.priority - b.priority);
    }
    static getRoomQueCount(roomName) {
        var _a;
        return ((_a = Memory.spawnQue) === null || _a === void 0 ? void 0 : _a.filter(que => que.rooms.includes(roomName)).length) || 0;
    }
}

const startTime = Game.time;
const DATA = { module: {} };
function getCreepFromArgs(args) {
    if (!Array.isArray(args)) {
        return;
    }
    for (const arg of args) {
        if (arg instanceof Creep) {
            return arg;
        }
    }
    return;
}
function printCreepDebug(creep, profileData) {
    const visual = new RoomVisual(creep.room.name);
    Object.values(profileData)
        // .sort((a, b) => b.cpu - a.cpu)
        .forEach((mData, index) => {
        visual.text(`${mData.cpu.toFixed(3)} - ${mData.name}`, creep.pos.x, creep.pos.y + index * 0.5, {
            align: "left",
            font: "0.5",
            backgroundColor: "#000",
            backgroundPadding: 0
        });
    });
}
let creepDebug = {};
class Profiler {
    static subprofile(type) {
        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
        return function (target, propertyKey, descriptor) {
            // eslint-disable-next-line @typescript-eslint/ban-types
            const originalFunction = descriptor.value;
            if (!originalFunction || typeof originalFunction !== "function") {
                console.log("profiler: no original function");
                return;
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment
            const className = target === null || target === void 0 ? void 0 : target.name;
            if (!className) {
                console.log("profiler: no class name", target === null || target === void 0 ? void 0 : target.name, propertyKey);
                console.log(descriptor.value);
                return;
            }
            descriptor.value = function (...args) {
                const start = Game.cpu.getUsed();
                const result = originalFunction.apply(this, args);
                const end = Game.cpu.getUsed();
                const used = end - start;
                if (type) {
                    if (!DATA[type]) {
                        DATA[type] = {};
                    }
                    if (!DATA[type][className]) {
                        DATA[type][className] = {
                            role: className,
                            cpu: used,
                            calls: 1
                        };
                    }
                    else {
                        DATA[type][className].cpu += used;
                        DATA[type][className].calls += 1;
                    }
                }
                return result;
            };
        };
    }
    static profileModule(name, callback) {
        if (!DATA.module[name]) {
            DATA.module[name] = {
                role: name,
                cpu: 0,
                calls: 0
            };
        }
        const start = Game.cpu.getUsed();
        callback();
        const end = Game.cpu.getUsed();
        const used = end - start;
        DATA.module[name].cpu += used;
        DATA.module[name].calls += 1;
        if (used > 100) {
            console.log("danger cpu usage", name, used);
        }
    }
    static printProfile(type = "module") {
        console.log(`-`.repeat(100));
        console.log(["Role".padEnd(40), "CPU per call".padEnd(9), "CPU per tick".padEnd(9)].join(" : "));
        console.log(`-`.repeat(100));
        const totalTicksPassed = Game.time - startTime + 1;
        Object.values(DATA[type])
            .sort((a, b) => a.cpu / a.calls - b.cpu / b.calls)
            .forEach(role => {
            const perUse = role.cpu / role.calls;
            const avgUsePerTick = role.cpu / totalTicksPassed;
            console.log([role.role.padEnd(40), perUse.toFixed(2).padEnd(9), avgUsePerTick.toFixed(2).padEnd(9)].join(" : "));
        });
        console.log(`-`.repeat(100));
    }
    static init() {
        creepDebug = {};
    }
    static exit() {
        for (const creepName in creepDebug) {
            const creep = Game.creeps[creepName];
            printCreepDebug(creep, creepDebug[creepName]);
        }
    }
    static debugCreep() {
        // eslint-disable-next-line @typescript-eslint/ban-types,@typescript-eslint/explicit-module-boundary-types
        return function (target) {
            console.log("debuging", target.name);
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            const functionNames = Object.getOwnPropertyNames(target).filter(prop => typeof target[prop] === "function");
            for (const functionName of functionNames) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const originalFunction = target[functionName];
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/ban-ts-comment
                // @ts-ignore
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                target[functionName] = function (...args) {
                    const creep = getCreepFromArgs(args);
                    const start = Game.cpu.getUsed();
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access
                    const result = originalFunction.apply(this, args);
                    const end = Game.cpu.getUsed();
                    const used = end - start;
                    if (!creep) {
                        return result;
                    }
                    if (!creepDebug[creep.name]) {
                        creepDebug[creep.name] = {};
                    }
                    if (!creepDebug[creep.name][functionName]) {
                        creepDebug[creep.name][functionName] = { name: functionName, cpu: used, calls: 1 };
                    }
                    else {
                        creepDebug[creep.name][functionName].calls += 1;
                        creepDebug[creep.name][functionName].cpu += used;
                    }
                    return result;
                };
            }
        };
        // const start = Game.cpu.getUsed();
        //
        // callback();
        //
        // const end = Game.cpu.getUsed();
        //
        // Log.object(creep, (end - start).toFixed(2), msg || "");
    }
}
// export default Profiler;
global.printProfile = (type) => Profiler.printProfile(type);

const MAX_ACTIONS_PER_TICK = 3;
class TickAction {
    static add(func) {
        this.que.push(func);
    }
    static exit() {
        if (this.que.length > 100) {
            console.log("tick action overrun", this.que.length);
        }
        for (let i = 0; i < MAX_ACTIONS_PER_TICK; i++) {
            const func = this.que.shift();
            if (!func) {
                return;
            }
            func();
        }
    }
}
TickAction.que = [];

const ROLE_NAME$i = "sourceKeeperDefender";
const SPAWN_PRIORITY$8 = 3 /* Medium */;
const SPAWN_INTERVAL$9 = 61;
const MAX_HOSTILE_POWER$7 = 500;
class SKDefender {
    static handle() {
        Creeps.getByRole(ROLE_NAME$i)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.worker(creep);
        });
        General.interval(SPAWN_INTERVAL$9, () => TickAction.add(() => this.spawner()));
    }
    static worker(creep) {
        this.moveToRoom(creep) || this.moveToHostile(creep) || this.moveToSoonestLair(creep);
        this.meleAttackHostiles(creep) || this.heal(creep);
        creep.rangedBestAttack();
    }
    static spawner() {
        Rooms.skMiningRooms.forEach(({ homeRoomModel, targetRoomModel }) => {
            if (!homeRoomModel.room) {
                return;
            }
            const stronghold = Memory.strongholds[targetRoomModel.roomName];
            if (stronghold && stronghold.isAlive) {
                return;
            }
            if (stronghold && stronghold.startsAt && stronghold.startsAt > Game.time - CREEP_LIFE_TIME + 300) {
                return;
            }
            if (homeRoomModel.level < 8) {
                return;
            }
            if (homeRoomModel.room.wasRecentlyUnderAttack) {
                return;
            }
            if (homeRoomModel.room.isSiegeBase) {
                return;
            }
            if (homeRoomModel.room.isAbandoning) {
                return;
            }
            if (targetRoomModel.pvpDeaths > 50) {
                return;
            }
            if (targetRoomModel.hostilePower(ATTACK, RANGED_ATTACK) > MAX_HOSTILE_POWER$7) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({
                minTicksToLive: 300,
                targetRoom: targetRoomModel.roomName,
                role: ROLE_NAME$i
            });
            if (creepsCount >= 1) {
                return;
            }
            Spawns.addToQue(homeRoomModel.roomName, {
                body: new BodyParts().attack().move(23).attack(16).rangedAttack().heal(5).rangedAttack().move(2).heal(),
                priority: SPAWN_PRIORITY$8,
                role: ROLE_NAME$i,
                memory: {
                    targetRoom: targetRoomModel.roomName
                }
            });
        });
    }
    static moveToSoonestLair(creep) {
        const lair = creep.room
            .find(FIND_STRUCTURES)
            .filter(structure => structure.structureType === STRUCTURE_KEEPER_LAIR).sort((a, b) => (a.ticksToSpawn || 300) - (b.ticksToSpawn || 300))[0];
        if (creep.pos.inRangeTo(lair, 1)) {
            return true;
        }
        creep.travel(lair, {
            costRoad: 1,
            costPlain: 2,
            costSwamp: 5
        });
        return true;
    }
    static moveToHostile(creep) {
        const hostile = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {
            filter: c => c.body.filter(b => b.type === ATTACK || b.type === RANGED_ATTACK).length > 0 && !c.pos.rampart
        });
        if (!hostile) {
            return false;
        }
        const distance = creep.pos.getRangeTo(hostile);
        if (distance === 4 && creep.hits !== creep.hitsMax) {
            return true;
        }
        else {
            creep.travel(hostile);
        }
        return true;
    }
    static meleAttackHostiles(creep) {
        if (!creep.attackPower) {
            return false;
        }
        const hostile = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 1)[0];
        if (!hostile) {
            return false;
        }
        creep.attack(hostile);
        return true;
    }
    static heal(creep) {
        if (!creep.healPower) {
            return false;
        }
        const woundedCreep = creep.pos
            .findInRange(FIND_MY_CREEPS, 1)
            .filter(c => c.hits < c.hitsMax)
            .sort((a, b) => a.hits - b.hits)[0];
        if (!woundedCreep) {
            return false;
        }
        creep.heal(woundedCreep);
        return true;
    }
    static moveToRoom(creep) {
        const targetRoomName = creep.memory.targetRoom;
        if (!targetRoomName) {
            return false;
        }
        return creep.travelToRoom(targetRoomName);
    }
}
__decorate([
    Profiler.subprofile("creep")
], SKDefender, "worker", null);
__decorate([
    Profiler.subprofile("spawn")
], SKDefender, "spawner", null);

const ROLE_NAME$h = "sourceKeeperDefenderRanged";
const SPAWN_PRIORITY$7 = 4 /* Low */;
const SPAWN_INTERVAL$8 = 62;
const MAX_HOSTILE_POWER$6 = 1000;
class SKDefenderRanged {
    static handle() {
        Creeps.getByRole(ROLE_NAME$h)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.worker(creep);
        });
        General.interval(SPAWN_INTERVAL$8, () => TickAction.add(() => this.spawner()));
    }
    static worker(creep) {
        this.moveToRoom(creep) ||
            this.followMeleDefender(creep) ||
            creep.kite() ||
            this.moveToHostile(creep) ||
            this.moveToSoonestLair(creep);
        creep.bestHeal();
        creep.rangedBestAttack() || creep.bestRangedHeal();
    }
    static spawner() {
        Rooms.skMiningRooms.forEach(({ homeRoomModel, targetRoomModel }) => {
            var _a;
            if (!homeRoomModel.room) {
                return;
            }
            const stronghold = Memory.strongholds[targetRoomModel.roomName];
            if (stronghold && stronghold.isAlive) {
                return;
            }
            if (stronghold && stronghold.startsAt && stronghold.startsAt > Game.time - CREEP_LIFE_TIME + 300) {
                return;
            }
            if (homeRoomModel.level < 8) {
                return;
            }
            if (homeRoomModel.room.wasRecentlyUnderAttack) {
                return;
            }
            if (homeRoomModel.room.isSiegeBase) {
                return;
            }
            if (homeRoomModel.room.isAbandoning) {
                return;
            }
            if (targetRoomModel.pvpDeaths > 50) {
                return;
            }
            if (targetRoomModel.hostilePower(ATTACK, RANGED_ATTACK) > MAX_HOSTILE_POWER$6) {
                return;
            }
            const constructionSiteCount = ((_a = targetRoomModel.room) === null || _a === void 0 ? void 0 : _a.find(FIND_MY_CONSTRUCTION_SITES).length) || 0;
            if (!targetRoomModel.sectionHasInvaders && constructionSiteCount === 0 && targetRoomModel.pvpDeaths === 0) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({
                minTicksToLive: 300,
                targetRoom: targetRoomModel.roomName,
                role: ROLE_NAME$h
            });
            if (creepsCount >= 1) {
                return;
            }
            Spawns.addToQue(homeRoomModel.roomName, {
                body: BodyParts.new().move(24).rangedAttack(19).heal(6).move(),
                priority: SPAWN_PRIORITY$7,
                role: ROLE_NAME$h,
                memory: {
                    targetRoom: targetRoomModel.roomName
                }
            });
        });
    }
    static moveToHostile(creep) {
        const hostile = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
        if (!hostile) {
            return false;
        }
        const distance = creep.pos.getRangeTo(hostile);
        if (distance <= 3) {
            return true;
        }
        creep.travel(hostile, {
            range: 3
        });
        return true;
    }
    static followMeleDefender(creep) {
        const meleDefender = creep.room
            .find(FIND_MY_CREEPS)
            .filter(c => c.memory.role === ROLE_NAME$i)
            .sort((a, b) => (b.ticksToLive || 0) - (a.ticksToLive || 0))[0];
        if (!meleDefender) {
            return false;
        }
        const distance = creep.pos.getRangeTo(meleDefender);
        if (distance > 1) {
            creep.travel(meleDefender);
        }
        else {
            meleDefender.pull(creep);
            creep.move(meleDefender);
        }
        return true;
    }
    static moveToSoonestLair(creep) {
        const lair = creep.room
            .find(FIND_STRUCTURES)
            .filter(structure => structure.structureType === STRUCTURE_KEEPER_LAIR).sort((a, b) => (a.ticksToSpawn || 300) - (b.ticksToSpawn || 300))[0];
        if (!lair) {
            return false;
        }
        if (creep.pos.inRangeTo(lair, 3)) {
            return false;
        }
        creep.travel(lair, { range: 3 });
        return true;
    }
    static moveToRoom(creep) {
        const targetRoomName = creep.memory.targetRoom;
        if (!targetRoomName) {
            return false;
        }
        return creep.travelToRoom(targetRoomName);
    }
}
__decorate([
    Profiler.subprofile("creep")
], SKDefenderRanged, "worker", null);
__decorate([
    Profiler.subprofile("spawn")
], SKDefenderRanged, "spawner", null);

const Config = {
    Attacker: {
        roleName: "attacker"
    },
    AttackerDuo: {
        roleNameAttacker: "AttackerDuoAttacker",
        roleNameHealer: "AttackerDuoHealer",
        duoName: "AttackerDuo"
    },
    AttackerRanged: {
        roleName: "AttackerRanged"
    },
    AttackerRangedQuad: {
        roleName: "AttackerRangedQuad"
    },
    BaseCenterLabConstruction: {
        interval: 1012
    },
    BaseCenterLinkConstruction: {
        interval: 500
    },
    BaseCenterPowerSpawnConstruction: {
        interval: 1013
    },
    BaseCenterNewbieContainerConstruction: {
        interval: 500
    },
    BaseCenterRoadConstruction: {
        interval: 1014
    },
    BaseCenterSpawnConstruction: {
        interval: 201
    },
    BaseCenterStorageConstruction: {
        interval: 1014
    },
    BaseCenterTerminalConstruction: {
        interval: 101
    },
    BaseControllerStorageConstruction: {
        interval: 532
    },
    BaseExtensionConstruction: {
        intervalRoads: 5001,
        intervalBuild: 200,
        intervalRebuild: 100
    },
    BaseExtractorConstruction: {
        interval: 501,
        maxContainers: 4
    },
    BaseLabConstruction: {
        interval: 301
    },
    BaseLinkSourceConstruction: {
        interval: 500
    },
    BaseNukerConstruction: {
        interval: 5014
    },
    BaseFactoryConstruction: {
        interval: 2015
    },
    BaseObserverConstruction: {
        interval: 5015
    },
    BaseRampartConstruction: {
        interval: 100,
        maxConstructionsPerRoom: 5
    },
    BaseTowerConstruction: {
        interval: 302
    },
    ObserverStructureWorker: {
        minBucket: 500,
        range: OBSERVER_RANGE
    },
    PowerSpawnStructureWorker: {
        minStorageEnergy: 200000
    },
    TerminalStructureWorker: {
        buyEnergyWhenUnder: 70000,
        buyEnergyOrderAmount: 30000,
        buyOrderPriceMultiplier: 1.2,
        buyOrderBoostsMinCredits: 500000000,
        buyOrderEnergyMinCredits: 500000000,
        buyBoosts: {
            minStorageEnergy: 9000,
            desiredMinStorageAmount: 7000,
            batchAmount: 3000,
            instantBuyWhenStorageAmountLessThen: 2000,
            developingRoom: [BOOST_ALIAS.UPGRADE_3, BOOST_ALIAS.UPGRADE_2, BOOST_ALIAS.UPGRADE_1, BOOST_ALIAS.REPAIR_BUILD_3],
            completeRoom: [
                BOOST_ALIAS.UPGRADE_1,
                BOOST_ALIAS.UPGRADE_2,
                BOOST_ALIAS.TOUGH_3,
                BOOST_ALIAS.HEAL_3,
                BOOST_ALIAS.REPAIR_BUILD_3,
                BOOST_ALIAS.RANGED_ATTACK_3,
                BOOST_ALIAS.CARRY_3,
                BOOST_ALIAS.ATTACK_3,
                BOOST_ALIAS.MOVE_3,
                BOOST_ALIAS.DISMANTLE_3
            ]
        },
        resources: {
            room: {
                energy: { balanceMinAmount: 5000, balanceMaxAmount: 5000, balanceMinDifference: 20000 },
                power: { balanceMinAmount: 1000, balanceMaxAmount: 5000, balanceMinDifference: 1000 },
                mineral: { balanceMinAmount: 3000, balanceMaxAmount: 5000, balanceMinDifference: 5000 },
                boost: { balanceMinAmount: 3000, balanceMaxAmount: 5000, balanceMinDifference: 3000 },
                t3boost: { balanceMinAmount: 3000, balanceMaxAmount: 5000, balanceMinDifference: 1000 },
                comodity: { balanceMinAmount: 1000, balanceMaxAmount: 5000, balanceMinDifference: 5000 },
                comodityBar: { balanceMinAmount: 3000, balanceMaxAmount: 5000, balanceMinDifference: 1000 },
                compound: { balanceMinAmount: 3000, balanceMaxAmount: 5000, balanceMinDifference: 3000 },
                other: { balanceMinAmount: 1000, balanceMaxAmount: 5000, balanceMinDifference: 2000 }
            },
            storage: {
                energy: { max: 300000 },
                power: { max: 30000 },
                mineral: { max: 30000 },
                boost: { max: 30000 },
                t3boost: { max: 50000 },
                comodity: { max: 0 },
                comodityBar: { max: 20000 },
                compound: { max: 40000 },
                other: { max: 20000 }
            },
            terminal: {
                energy: { max: 15000, sell: 30000 },
                power: { max: 5000, sell: 10000 },
                mineral: { max: 5000, sell: 10000 },
                boost: { max: 3000, sell: 4000 },
                t3boost: { max: 15000, sell: 20000 },
                comodity: { max: 10000, sell: 0 },
                comodityBar: { max: 5000, sell: 10000 },
                compound: { max: 5000, sell: 10000 },
                other: { max: 5000, sell: 10000 }
            }
        },
        developingRoomResources: [
            RESOURCE_ENERGY,
            BOOST_ALIAS.UPGRADE_3,
            BOOST_ALIAS.UPGRADE_2,
            BOOST_ALIAS.UPGRADE_1,
            BOOST_ALIAS.REPAIR_BUILD_3,
            BOOST_ALIAS.REPAIR_BUILD_2,
            BOOST_ALIAS.REPAIR_BUILD_1,
            BOOST_ALIAS.ATTACK_3,
            BOOST_ALIAS.MOVE_3
        ]
    },
    BaseBuilder: {
        roleName: "baseBuilder",
        spawnPriority: 3 /* Medium */,
        spawnInterval: 6
    },
    BaseCenterBalancer: {
        roleName: "baseCenterBalancer",
        spawnPriority: 0 /* Highest */,
        spawnInterval: 60
    },
    BaseGclFarmCenterBalancer: {
        roleName: "BaseGclFarmCenterBalancer",
        spawnPriority: 0 /* Highest */,
        spawnInterval: 60
    },
    BaseEnergyBalancer: {
        roleName: "baseEnergyBalancer",
        spawnPriority: 0 /* Highest */,
        spawnInterval: 100,
        spawnMinStorageEnergy: 150000
    },
    BaseEnergyHarvester: {
        roleName: "BaseEnergyHarvester"
    },
    BaseEnergyHarvesterHauler: {
        roleName: "BaseEnergyHarvesterHauler"
    },
    BaseGclFarmHauler: {
        roleName: "BaseGclFarmHauler",
        spawnPriority: 4 /* Low */,
        spawnInterval: 60
    },
    BaseGclFarmUpgrader: {
        roleName: "BaseGclFarmUpgrader",
        spawnInterval: 57
    },
    BaseGclFarmResetter: {
        roleName: "BaseGclFarmResetter",
        spawnInterval: 300
    },
    EnergyMineMiner: {
        roleName: "EnergyMineMiner",
        spawnPriority: 2 /* High */,
        spawnInterval: 30
    },
    RemoteSourceHarvester: {
        roleName: "RemoteSourceHarvester",
        spawnPriority: 2 /* High */,
        spawnInterval: 30
    },
    RemoteSourceHauler: {
        roleName: "RemoteSourceHauler",
        spawnPriority: 1 /* Higher */,
        spawnInterval: 30
    },
    EnergyMineHauler: {
        roleName: "EnergyMineHauler",
        spawnPriority: 1 /* Higher */,
        spawnInterval: 30
    },
    MineralMineMiner: {
        roleName: "MineralMineMiner",
        spawnInterval: 90
    },
    MineralMineHauler: {
        roleName: "MineralMineHauler",
        spawnInterval: 90
    },
    BaseLabBalancer: {
        roleName: "labBalancer",
        spawnPriority: 6 /* Lowest */,
        spawnInterval: 30
    },
    BaseMineralHauler: {
        roleName: "BaseMineralHauler",
        spawnPriority: 4 /* Low */,
        spawnInterval: 60
    },
    BaseMineralMiner: {
        roleName: "mineralMiner",
        spawnPriority: 4 /* Low */,
        spawnInterval: 60,
        spawnMaxTerminalAmount: 15000
    },
    Stronghold1Attacker: {
        roleName: "Stronghold1Attacker"
    },
    Stronghold2Attacker: {
        roleName: "Stronghold2Attacker"
    },
    Stronghold3Attacker: {
        roleName: "Stronghold3Attacker"
    },
    Stronghold4Attacker: {
        roleName: "Stronghold4Attacker",
        spawnInterval: 100,
        maxQuads: 6
    },
    StrongholdDismantler: {
        roleName: "StrongholdDismantler",
        spawnInterval: 100
    },
    StrongholdHauler: {
        roleName: "StrongholdHauler"
    },
    StrongholdProtector: {
        roleName: "StrongholdProtector"
    },
    BaseNeighbourScouter: {
        roleName: "BaseNeighbourScouter",
        spawnInterval: 20
    },
    BaseNewbie: {
        roleName: "baseNewbie",
        spawnPriority: 3 /* Medium */,
        spawnInterval: 60,
        minAmountToPickup: 50,
        minAmountToWithdrawFromContainer: 1000,
        minAmountToWithdrawFromLink: 200
    },
    RemoteMineDefender: {
        roleName: "RemoteMineDefender",
        spawnInterval: 60
    },
    BaseNewbieHauler: {
        roleName: "BaseNewbieHauler"
    },
    BaseNukerGhodiumFiller: {
        roleName: "baseNukerGhodiumFiller",
        spawnPriority: 6 /* Lowest */,
        spawnInterval: 60
    },
    BasePowerCreep: {
        roleName: "basePowerCreep",
        spawnInterval: 60,
        createInterval: 10000,
        upgradeInterval: 5000,
        creepLevelSkills: {
            0: PWR_GENERATE_OPS,
            1: PWR_OPERATE_LAB,
            2: PWR_GENERATE_OPS,
            3: PWR_OPERATE_LAB,
            4: PWR_OPERATE_SPAWN,
            5: PWR_OPERATE_SPAWN,
            6: PWR_OPERATE_TOWER,
            7: PWR_GENERATE_OPS,
            8: PWR_OPERATE_LAB,
            9: PWR_OPERATE_SPAWN,
            10: PWR_REGEN_SOURCE,
            11: PWR_REGEN_SOURCE,
            12: PWR_REGEN_SOURCE,
            13: PWR_OPERATE_TOWER,
            14: PWR_REGEN_SOURCE,
            15: PWR_OPERATE_SPAWN
        }
    },
    BaseRampartDefender: {
        roleName: "baseRampartDefender",
        spawnPriority: 0 /* Highest */,
        spawnInterval: 50
    },
    BaseRampartRangedDefender: {
        roleName: "baseRampartRangedDefender",
        spawnPriority: 0 /* Highest */,
        spawnInterval: 50
    },
    BaseRoadRepairer: {
        roleName: "baseRoadRepairer",
        spawnInterval: 60,
        spawnMinStorageEnergy: 1000,
        spawnMinRoadHits: 1000,
        spawnMinContainerHits: 40000
    },
    BaseTester: {
        roleName: "BaseTester",
        spawnPriority: 0 /* Highest */,
        spawnInterval: 20
    },
    BaseTowerFiller: {
        roleName: "baseTowerFiller",
        spawnPriority: 4 /* Low */,
        spawnInterval: 59,
        spawnMinStorageEnergy: 1000
    },
    BaseUpgradeHauler: {
        roleName: "baseUpgradeHauler",
        spawnPriority: 2 /* High */,
        spawnInterval: 5,
        spawnMinStorageEnergy: 10000
    },
    BaseUpgrader: {
        roleName: "baseUpgrader",
        spawnInterval: 57,
        spawnMinStorageEnergy: 10000
    },
    PowerBankHauler: {
        roleName: "PowerBankHauler",
        spawnInterval: 57
    },
    ExpansionClaimer: {
        roleName: "expansionClaimer",
        spawnPriority: 6 /* Lowest */,
        spawnInterval: 6
    },
    DismantlerDuo: {
        roleNameAttacker: "DismantlerDuoAttacker",
        roleNameHealer: "DismantlerDuoHealer",
        duoName: "DismantlerDuo",
        spawnFlagInterval: 50
    },
    PowerBankMinerDuo: {
        duoName: "PowerBankMinerDuo",
        spawnFlagInterval: 50
    },
    Dismantler: {
        roleName: "Dismantler",
        spawnFlagInterval: 50
    },
    RemoteMineMiner: {
        roleName: "RemoteMineMiner",
        spawnInterval: 50
    },
    BaseFactoryBalancer: {
        roleName: "BaseFactoryBalancer"
    }
};

const ANCHOR_POSITIONS = [
    { x: 0, y: 0 },
    { x: 1, y: 0 },
    { x: 1, y: 1 },
    { x: 0, y: 1 }
];
function quadPositionsFromAnchor(x, y) {
    return ANCHOR_POSITIONS.map(p => ({ x: x + p.x, y: y + p.y }));
}

var QuadPosition;
(function (QuadPosition) {
    QuadPosition["TOP_LEFT"] = "top_left";
    QuadPosition["TOP_RIGHT"] = "top_right";
    QuadPosition["BOTTOM_LEFT"] = "bottom_left";
    QuadPosition["BOTTOM_RIGHT"] = "bottom_right";
})(QuadPosition || (QuadPosition = {}));
const ANCHOR_POSITION = QuadPosition.TOP_LEFT;
const QUAD_POSITION_OFFSETS = {
    [QuadPosition.TOP_LEFT]: { position: QuadPosition.TOP_LEFT, direction: TOP_LEFT, x: 0, y: 0 },
    [QuadPosition.TOP_RIGHT]: { position: QuadPosition.TOP_RIGHT, direction: TOP_LEFT, x: 1, y: 0 },
    [QuadPosition.BOTTOM_LEFT]: { position: QuadPosition.BOTTOM_LEFT, direction: TOP_LEFT, x: 0, y: 1 },
    [QuadPosition.BOTTOM_RIGHT]: { position: QuadPosition.BOTTOM_RIGHT, direction: TOP_LEFT, x: 1, y: 1 }
};
// const ANCHOR_POSITIONS: Record<QuadPositions, { direction: QuadPositions; x: number; y: number }> = {
//   [TOP_LEFT]: { direction: TOP_LEFT, x: 0, y: 0 },
//   [TOP_RIGHT]: { direction: TOP_RIGHT, x: 1, y: 0 },
//   [BOTTOM_LEFT]: { direction: BOTTOM_LEFT, x: 0, y: 1 },
//   [BOTTOM_RIGHT]: { direction: BOTTOM_RIGHT, x: 1, y: 1 }
// };
class QuadModel {
    constructor(memory) {
        this.memory = memory;
        this.creeps = this.getCreepsFromMemory();
        this.memory.ticksToLive = this.getTicksToLive();
    }
    get hits() {
        return this.allCreeps.reduce((total, creep) => total + creep.hits, 0);
    }
    get hitsMax() {
        return this.allCreeps.reduce((total, creep) => total + creep.hitsMax, 0);
    }
    getTicksToLive() {
        if (this.memory.stage === QuadGroupStage.SPAWNING) {
            return CREEP_LIFE_TIME;
        }
        if (this.allCreeps.length === 0) {
            return 0;
        }
        const values = Object.values(this.creeps)
            .map(c => c === null || c === void 0 ? void 0 : c.ticksToLive)
            .filter(t => !!t);
        if (values.length === 0) {
            return 0;
        }
        return Math.min(...values);
    }
    getCreepsFromMemory() {
        const creeps = {
            [QuadPosition.TOP_LEFT]: undefined,
            [QuadPosition.TOP_RIGHT]: undefined,
            [QuadPosition.BOTTOM_LEFT]: undefined,
            [QuadPosition.BOTTOM_RIGHT]: undefined
        };
        for (const position in this.memory.creeps) {
            const creepName = this.memory.creeps[position];
            if (!creepName) {
                continue;
            }
            const creep = Game.creeps[creepName];
            if (!creep) {
                continue;
            }
            creeps[position] = creep;
        }
        return creeps;
    }
    setStage(stage) {
        this.memory.stage = stage;
    }
    isFull() {
        return Object.values(this.creeps).filter(c => c !== undefined).length === 4;
    }
    refresh() {
        let refreshing = false;
        Object.values(this.creeps).forEach(creep => {
            if (!creep) {
                return;
            }
            if (!creep.ticksToLive) {
                return;
            }
            if (creep.ticksToLive > 1500 - Math.floor(600 / creep.body.length)) {
                return;
            }
            refreshing = true;
            const spawn = creep.pos.findClosestByRange(FIND_MY_SPAWNS, { filter: s => !s.spawning && !s.actionPending });
            if (!spawn) {
                return;
            }
            spawn.renewCreepV2(creep);
        });
        return refreshing;
    }
    waitTillAllAlive() {
        return Object.values(this.creeps).filter(c => c !== undefined && c.ticksToLive).length !== 4;
    }
    boost() {
        if (this.memory.stage !== QuadGroupStage.BOOSTING) {
            return false;
        }
        let boosting = false;
        Object.values(this.creeps).forEach(creep => {
            if (!creep) {
                return;
            }
            if (creep.boost({ minTicksToLive: 500 })) {
                boosting = true;
                return;
            }
            creep.travelToIdlePlace();
        });
        return boosting;
    }
    formTrain() {
        let forming = false;
        Object.values(QuadPosition).forEach((direction, index, array) => {
            if (index === 0) {
                return;
            }
            const leadCreep = this.creeps[array[index - 1]];
            if (!leadCreep) {
                return;
            }
            const creep = this.creeps[direction];
            if (!creep) {
                return;
            }
            if (creep.pos.getRangeTo(leadCreep) <= 1) {
                return;
            }
            if (creep.pos.isRoomEdge || leadCreep.pos.isRoomEdge) {
                if (creep.wpos.getRangeTo(leadCreep.wpos) <= 2) {
                    return;
                }
            }
            creep.travel(leadCreep);
            creep.say("train");
            forming = true;
        });
        return forming;
    }
    inStage(stage, callback) {
        if (this.memory.stage !== stage) {
            return this;
        }
        callback();
        return this;
    }
    retreat() {
        Object.values(this.creeps).forEach(creep => {
            if (!creep) {
                return;
            }
            creep.recycleFinal(1500);
        });
        return true;
    }
    get allCreeps() {
        return TickCache.cache({
            key: `${this.constructor.name}.${this.memory.id}.allCreeps`,
            callback: () => Object.values(this.creeps).filter(Boolean)
        });
    }
    get fatigue() {
        return TickCache.cache({
            key: `${this.constructor.name}.${this.memory.id}.fatigue`,
            callback: () => {
                for (const creep of this.allCreeps) {
                    if (creep.fatigue > 0) {
                        return true;
                    }
                    if (creep.body.filter(b => b.type === MOVE && b.hits > 0).length === 0) {
                        return true;
                    }
                }
                return false;
            }
        });
    }
    get missingMoveParts() {
        return TickCache.cache({
            key: `${this.constructor.name}.${this.memory.id}.missingMoveParts`,
            callback: () => !!this.allCreeps.find(c => c.body.filter(b => b.type === MOVE && b.hits > 0).length === 0)
        });
    }
    get onExit() {
        return TickCache.cache({
            key: `${this.constructor.name}.${this.memory.id}.onExit`,
            callback: () => this.anchorCreep.pos.x === 0 ||
                this.anchorCreep.pos.y === 0 ||
                this.anchorCreep.pos.x >= 48 ||
                this.anchorCreep.pos.y >= 48
        });
    }
    travelTo(pos, range) {
        if (this.fatigue) {
            return true;
        }
        if (this.hasFatigue()) {
            return true;
        }
        const anchorDistance = this.anchorCreep.pos.getRangeTo(pos);
        if (anchorDistance <= range) {
            return false;
        }
        let shouldLeadWait = false;
        Object.values(QuadPosition).forEach((direction, index, array) => {
            if (direction === ANCHOR_POSITION) {
                return;
            }
            const masterCreep = this.creeps[array[index - 1]];
            if (!masterCreep) {
                return;
            }
            const slaveCreep = this.creeps[direction];
            if (!slaveCreep) {
                return;
            }
            const distance = slaveCreep.wpos.getRangeTo(masterCreep.wpos);
            if (distance === 2 && slaveCreep.pos.roomName !== masterCreep.pos.roomName) {
                slaveCreep.travel(masterCreep);
            }
            else if (distance > 1) {
                slaveCreep.travel(masterCreep);
                shouldLeadWait = true;
            }
            else {
                slaveCreep.moveTo(masterCreep);
            }
        });
        if (!shouldLeadWait) {
            this.anchorCreep.travel({ pos }, { range });
        }
        else {
            this.anchorCreep.say("waiting");
        }
        return true;
    }
    hasFatigue() {
        return Object.values(this.creeps).filter(c => c === null || c === void 0 ? void 0 : c.fatigue).length > 0;
    }
    findAlternateFormationPosition(creep, swapIntents) {
        for (const quadPosition in this.quadPositions) {
            if (swapIntents.includes(quadPosition)) {
                continue;
            }
            const pos = this.quadPositions[quadPosition];
            const distance = creep.pos.getRangeTo(pos);
            if (distance > 1) {
                continue;
            }
            if (pos.creep && pos.creep.fatigue) {
                continue;
            }
            return quadPosition;
        }
        return;
    }
    get quadPositions() {
        if (this._quadPositions === undefined) {
            this._quadPositions = {
                [QuadPosition.TOP_LEFT]: Geo.globalRoomPosition(this.anchorCreep.pos.roomName, this.anchorCreep.pos.x + QUAD_POSITION_OFFSETS[QuadPosition.TOP_LEFT].x, this.anchorCreep.pos.y + QUAD_POSITION_OFFSETS[QuadPosition.TOP_LEFT].y),
                [QuadPosition.TOP_RIGHT]: Geo.globalRoomPosition(this.anchorCreep.pos.roomName, this.anchorCreep.pos.x + QUAD_POSITION_OFFSETS[QuadPosition.TOP_RIGHT].x, this.anchorCreep.pos.y + QUAD_POSITION_OFFSETS[QuadPosition.TOP_RIGHT].y),
                [QuadPosition.BOTTOM_LEFT]: Geo.globalRoomPosition(this.anchorCreep.pos.roomName, this.anchorCreep.pos.x + QUAD_POSITION_OFFSETS[QuadPosition.BOTTOM_LEFT].x, this.anchorCreep.pos.y + QUAD_POSITION_OFFSETS[QuadPosition.BOTTOM_LEFT].y),
                [QuadPosition.BOTTOM_RIGHT]: Geo.globalRoomPosition(this.anchorCreep.pos.roomName, this.anchorCreep.pos.x + QUAD_POSITION_OFFSETS[QuadPosition.BOTTOM_RIGHT].x, this.anchorCreep.pos.y + QUAD_POSITION_OFFSETS[QuadPosition.BOTTOM_RIGHT].y)
            };
        }
        return this._quadPositions;
    }
    formQuad() {
        if (!this.anchorCreep) {
            return false;
        }
        const positionSwitchIntents = [];
        for (const position in this.creeps) {
            const creep = this.creeps[position];
            const expectedPos = this.quadPositions[position];
            if (!creep) {
                continue;
            }
            const distance = creep.pos.getRangeTo(expectedPos);
            if (distance === 0) {
                continue;
            }
            if (distance === 2) {
                const alternateClosePosition = this.findAlternateFormationPosition(creep, positionSwitchIntents);
                if (alternateClosePosition) {
                    const alternateCreep = this.creeps[alternateClosePosition];
                    if (alternateCreep) {
                        this.memory.creeps[position] = alternateCreep.name;
                        this.memory.creeps[alternateClosePosition] = creep.name;
                        positionSwitchIntents.push(position);
                        positionSwitchIntents.push(alternateClosePosition);
                        creep.moveTo(this.quadPositions[alternateClosePosition], { reusePath: 0, range: 0 });
                        alternateCreep.moveTo(this.quadPositions[position], { reusePath: 0, range: 0 });
                        continue;
                    }
                }
            }
            creep.moveTo(expectedPos, { reusePath: 0, range: 0 });
        }
        return true;
    }
    get anchorCreep() {
        const creep = this.creeps[ANCHOR_POSITION];
        if (!creep) {
            throw new Error("Missing anchor creep");
        }
        return creep;
    }
    moveToAnchorPositions(targetAnchorPositions) {
        if (targetAnchorPositions.length === 0) {
            return false;
        }
        if (this.hasFatigue()) {
            return false;
        }
        const anchorCreep = this.anchorCreep;
        if (!anchorCreep) {
            return false;
        }
        if (targetAnchorPositions.filter(pos => pos.isEqualTo(anchorCreep.pos)).length > 0) {
            return true;
        }
        const positionWouldHitaWallOrMyNonQuadCreep = function (t, creeps, x, y) {
            const quadPositions = quadPositionsFromAnchor(x, y);
            for (const quadPosition of quadPositions) {
                if (t.get(quadPosition.x, quadPosition.y) === TERRAIN_MASK_WALL) {
                    return true;
                }
                if (creeps.filter(c => c.pos.x === quadPosition.x && c.pos.y === quadPosition.y).length > 0) {
                    return true;
                }
            }
            return false;
        };
        const ret = PathFinder.search(anchorCreep.pos, targetAnchorPositions, {
            maxRooms: 2,
            roomCallback: (roomName) => {
                const room = Game.rooms[roomName];
                if (!room) {
                    return false;
                }
                const terrain = room.getTerrain();
                const matrix = new PathFinder.CostMatrix();
                const blockingCreeps = room.find(FIND_MY_CREEPS, {
                    filter: c => !this.quadCreepNames.includes(c.name)
                });
                for (let x = 0; x <= 49; x++) {
                    for (let y = 0; y <= 49; y++) {
                        if (x === 0 || y === 0) {
                            matrix.set(x, y, 256);
                            continue;
                        }
                        if (x >= 48 || y >= 48) {
                            matrix.set(x, y, 256);
                            continue;
                        }
                        if (positionWouldHitaWallOrMyNonQuadCreep(terrain, blockingCreeps, x, y)) {
                            matrix.set(x, y, 256);
                            continue;
                        }
                    }
                }
                return matrix;
            }
        });
        if (ret.incomplete) {
            return false;
        }
        const direction = anchorCreep.pos.getDirectionTo(ret.path[0]);
        Object.values(this.creeps).forEach(creep => {
            if (!creep) {
                return;
            }
            creep.move(direction);
        });
        ret.path.forEach(p => {
            new RoomVisual(p.roomName).circle(p.x, p.y, { radius: 0.5 });
        });
        return true;
    }
    getCreeps() {
        return Object.values(this.creeps).filter(Boolean);
    }
    moveTo(positions, range, options) {
        if (this.fatigue) {
            this.anchorCreep.say("fatigue");
            return true;
        }
        if (this.missingMoveParts) {
            this.anchorCreep.say("no move");
            return true;
        }
        if (!this.anchorCreep) {
            return false;
        }
        const ret = PathFinder.search(this.anchorCreep.pos, Array.isArray(positions) ? positions.map(p => ({ pos: p, range })) : { pos: positions, range }, {
            maxOps: 10000,
            roomCallback: (roomName) => {
                var _a;
                const room = Game.rooms[roomName];
                if (!room) {
                    return true; // return base terrain matrix
                }
                const matrix = room.quadMatrix();
                const quadCreepNames = this.quadCreepNames;
                room
                    .find(FIND_CREEPS)
                    .filter(c => !quadCreepNames.includes(c.name))
                    .forEach(c => {
                    matrix.set(c.pos.x, c.pos.y, 256);
                    for (const offset of Object.values(QUAD_POSITION_OFFSETS)) {
                        if (offset.position === ANCHOR_POSITION) {
                            continue;
                        }
                        if (matrix.get(c.pos.x - offset.x, c.pos.y - offset.y) >= 90) {
                            continue;
                        }
                        matrix.set(c.pos.x - offset.x, c.pos.y - offset.y, c.my ? 90 : 30);
                    }
                });
                (_a = options === null || options === void 0 ? void 0 : options.obstacles) === null || _a === void 0 ? void 0 : _a.forEach(pos => {
                    matrix.set(pos.x, pos.y, 255);
                });
                if (options === null || options === void 0 ? void 0 : options.callback) {
                    options.callback(room || null, matrix);
                }
                // for (let x = 0; x < 49; x++) {
                //   for (let y = 0; y < 49; y++) {
                //     const m = matrix.get(x, y);
                //     if (m === 0) {
                //       continue;
                //     }
                //     room.visual.circle(x, y, { radius: 0.1, fill: `rgb(${m},255,255)` });
                //   }
                // }
                return matrix;
            }
        });
        if (ret.incomplete) {
            // this.anchorCreep.say("~");
            return false;
            // return this.travelTo(Array.isArray(positions) ? positions[0] : positions, range);
        }
        ret.path.forEach(p => new RoomVisual(p.roomName).circle(p.x, p.y, { radius: 0.2 }));
        const nextPoint = ret.path[0];
        if (!nextPoint || (ret.incomplete && ret.path.length <= 1)) {
            return true;
        }
        const direction = this.anchorCreep.pos.getDirectionTo(nextPoint);
        // todo travel if cant form
        this.allCreeps.forEach(c => c.move(direction));
        return true;
    }
    moveToV2(positions, range, options) {
        if (this.fatigue) {
            this.anchorCreep.say("fatigue");
            return true;
        }
        if (!this.anchorCreep) {
            return false;
        }
        const ret = PathFinder.search(this.anchorCreep.pos, positions, {
            maxOps: 10000,
            roomCallback: (roomName) => {
                var _a;
                const room = Game.rooms[roomName];
                if (!room) {
                    return true; // return base terrain matrix
                }
                const matrix = room.quadMatrix();
                const quadCreepNames = this.quadCreepNames;
                room
                    .find(FIND_CREEPS)
                    .filter(c => !quadCreepNames.includes(c.name))
                    .forEach(c => {
                    matrix.set(c.pos.x, c.pos.y, 256);
                    for (const offset of Object.values(QUAD_POSITION_OFFSETS)) {
                        if (offset.position === ANCHOR_POSITION) {
                            continue;
                        }
                        if (matrix.get(c.pos.x - offset.x, c.pos.y - offset.y) >= 90) {
                            continue;
                        }
                        matrix.set(c.pos.x - offset.x, c.pos.y - offset.y, c.my ? 90 : 30);
                    }
                });
                (_a = options === null || options === void 0 ? void 0 : options.obstacles) === null || _a === void 0 ? void 0 : _a.forEach(pos => {
                    matrix.set(pos.x, pos.y, 256);
                });
                // for (let x = 0; x < 49; x++) {
                //   for (let y = 0; y < 49; y++) {
                //     const m = matrix.get(x, y);
                //     if (m < 256) {
                //       continue;
                //     }
                //     room.visual.circle(x, y, { radius: 0.1, fill: `rgb(${m},255,255)` });
                //   }
                // }
                return matrix;
            }
        });
        if (ret.incomplete) {
            this.travelTo(positions[0].pos, positions[0].range);
            return false;
        }
        ret.path.forEach(p => new RoomVisual(p.roomName).circle(p.x, p.y, { radius: 0.2 }));
        const nextPoint = ret.path[0];
        if (!nextPoint || (ret.incomplete && ret.path.length <= 1)) {
            return true;
        }
        const direction = this.anchorCreep.pos.getDirectionTo(nextPoint);
        // todo travel if cant form
        this.allCreeps.forEach(c => c.move(direction));
        return true;
    }
    isAnchorFullyInRoom() {
        return (this.anchorCreep.pos.x <= 47 &&
            this.anchorCreep.pos.x >= 1 &&
            this.anchorCreep.pos.y <= 47 &&
            this.anchorCreep.pos.y >= 1);
    }
    isQuadInFormation() {
        if (!this.anchorCreep) {
            return false;
        }
        const expectedPositions = this.getExpectedQuadFormationPositions(this.anchorCreep.pos);
        for (const direction in this.creeps) {
            const creep = this.creeps[direction];
            if (!creep) {
                return false;
            }
            const expectedPos = expectedPositions[direction];
            if (!expectedPos) {
                return false;
            }
            if (!creep.pos.isEqualToWithEdges(expectedPos)) {
                return false;
            }
        }
        return true;
    }
    quadExpectedPositions() {
        if (!this.anchorCreep) {
            return [];
        }
        const positions = [];
        for (const direction in this.creeps) {
            const creep = this.creeps[direction];
            if (!creep) {
                continue;
            }
            const offsets = QUAD_POSITION_OFFSETS[direction];
            if (!offsets) {
                continue;
            }
            positions.push(Geo.globalRoomPosition(this.anchorCreep.pos.roomName, this.anchorCreep.pos.x + offsets.x, this.anchorCreep.pos.y + offsets.y));
        }
        return positions;
    }
    getExpectedQuadFormationPositions(pos) {
        const positions = {
            [QuadPosition.BOTTOM_LEFT]: undefined,
            [QuadPosition.BOTTOM_RIGHT]: undefined,
            [QuadPosition.TOP_LEFT]: undefined,
            [QuadPosition.TOP_RIGHT]: undefined
        };
        Object.values(QuadPosition).forEach(direction => {
            const creep = this.creeps[direction];
            if (!creep) {
                return;
            }
            const offsets = QUAD_POSITION_OFFSETS[direction];
            const newX = pos.x + offsets.x;
            const newY = pos.y + offsets.y;
            positions[direction] = Geo.globalRoomPosition(pos.roomName, newX, newY);
        });
        return positions;
    }
    canFormQuad() {
        const expectedPositions = this.getExpectedQuadFormationPositions(this.anchorCreep.pos);
        for (const direction in expectedPositions) {
            const position = expectedPositions[direction];
            if (!position) {
                return false;
            }
            if (position.isRoomEdge) {
                return false;
            }
            const positionHasUnwalkableStructures = position
                .lookFor(LOOK_STRUCTURES)
                .filter(s => OBSTACLE_OBJECT_TYPES.includes(s.structureType) || (s instanceof StructureRampart && !s.my));
            if (positionHasUnwalkableStructures.length > 0) {
                return false;
            }
            if (position.creep && !this.quadCreepNames.includes(position.creep.name)) {
                return false;
            }
            if (new Room.Terrain(position.roomName).get(position.x, position.y) === TERRAIN_MASK_WALL) {
                return false;
            }
        }
        return true;
    }
    canFormQuadOn(pos) {
        const expectedPositions = this.getExpectedQuadFormationPositions(pos);
        for (const direction in expectedPositions) {
            const position = expectedPositions[direction];
            if (!position) {
                return false;
            }
            const positionHasUnwalkableStructures = position
                .lookFor(LOOK_STRUCTURES)
                .filter(s => OBSTACLE_OBJECT_TYPES.includes(s.structureType) || (s instanceof StructureRampart && !s.my));
            if (positionHasUnwalkableStructures.length > 0) {
                return false;
            }
            if (position.creep && !this.quadCreepNames.includes(position.creep.name)) {
                return false;
            }
            if (new Room.Terrain(position.roomName).get(position.x, position.y) === TERRAIN_MASK_WALL) {
                return false;
            }
        }
        return true;
    }
    get quadCreepNames() {
        return Object.values(this.memory.creeps).filter(Boolean);
    }
    formQuadIfPossible() {
        var _a;
        if (!this.isAnchorFullyInRoom()) {
            return false;
        }
        if (this.isQuadInFormation()) {
            return false;
        }
        if (!this.canFormQuad()) {
            return false;
        }
        (_a = this.anchorCreep) === null || _a === void 0 ? void 0 : _a.say("forming");
        this.formQuad();
        return true;
    }
    getRangeTo(pos) {
        return this.allCreeps.reduce((min, creep) => {
            const distance = creep.wpos.getRangeTo(pos.wpos);
            return Math.min(distance, min);
        }, Number.POSITIVE_INFINITY);
    }
    get direction() {
        var _a;
        const attackerPositionDirections = {
            [LEFT]: [QuadPosition.BOTTOM_LEFT, QuadPosition.TOP_LEFT],
            [RIGHT]: [QuadPosition.TOP_RIGHT, QuadPosition.BOTTOM_RIGHT],
            [BOTTOM]: [QuadPosition.BOTTOM_LEFT, QuadPosition.BOTTOM_RIGHT],
            [TOP]: [QuadPosition.TOP_LEFT, QuadPosition.TOP_RIGHT]
        };
        const attackerPositions = [];
        for (const positionDirection in this.creeps) {
            const creep = this.creeps[positionDirection];
            if (!creep) {
                continue;
            }
            if (!((_a = creep.memory.quad) === null || _a === void 0 ? void 0 : _a.attacker)) {
                continue;
            }
            attackerPositions.push(positionDirection);
        }
        if (attackerPositions.length !== 2) {
            this.anchorCreep.say("a-" + String(attackerPositions.length));
            console.log(attackerPositions);
            return;
        }
        for (const d in attackerPositionDirections) {
            const direction = d;
            const expectedPositions = attackerPositionDirections[direction];
            if (!expectedPositions.includes(attackerPositions[0])) {
                continue;
            }
            if (!expectedPositions.includes(attackerPositions[1])) {
                continue;
            }
            return Number(direction);
        }
        return;
    }
    turnToDirection(direction) {
        var _a, _b;
        if (!this.isQuadInFormation()) {
            return false;
        }
        if (this.direction === direction) {
            return false;
        }
        const attackerPositionDirections = {
            [LEFT]: [QuadPosition.BOTTOM_LEFT, QuadPosition.TOP_LEFT],
            [RIGHT]: [QuadPosition.TOP_RIGHT, QuadPosition.BOTTOM_RIGHT],
            [BOTTOM]: [QuadPosition.BOTTOM_LEFT, QuadPosition.BOTTOM_RIGHT],
            [TOP]: [QuadPosition.TOP_LEFT, QuadPosition.TOP_RIGHT]
        };
        const expectedAttackerPositions = attackerPositionDirections[direction];
        const positionsInMotion = [];
        for (const attackerPosition in this.memory.creeps) {
            if (positionsInMotion.includes(attackerPosition)) {
                continue;
            }
            if (expectedAttackerPositions.includes(attackerPosition)) {
                continue;
            }
            const attackerCreepName = this.memory.creeps[attackerPosition];
            if (!attackerCreepName) {
                continue;
            }
            const attackerCreep = Game.creeps[attackerCreepName];
            if (!attackerCreep) {
                continue;
            }
            if (attackerCreep.fatigue) {
                continue;
            }
            if (!((_a = attackerCreep.memory.quad) === null || _a === void 0 ? void 0 : _a.attacker)) {
                continue;
            }
            for (const healerPosition in this.memory.creeps) {
                if (positionsInMotion.includes(healerPosition)) {
                    continue;
                }
                if (!expectedAttackerPositions.includes(healerPosition)) {
                    continue;
                }
                const healerCreepName = this.memory.creeps[healerPosition];
                if (!healerCreepName) {
                    continue;
                }
                const healerCreep = Game.creeps[healerCreepName];
                if (!healerCreep) {
                    continue;
                }
                if (healerCreep.fatigue) {
                    continue;
                }
                if (!((_b = healerCreep.memory.quad) === null || _b === void 0 ? void 0 : _b.healer)) {
                    continue;
                }
                attackerCreep.moveTo(healerCreep, { ignoreCreeps: true });
                attackerCreep.say("!");
                healerCreep.moveTo(attackerCreep, { ignoreCreeps: true });
                healerCreep.say("!");
                this.memory.creeps[healerPosition] = attackerCreep.name;
                this.memory.creeps[attackerPosition] = healerCreep.name;
                // todo do some group up method based on memory shite
                positionsInMotion.push(attackerPosition);
                positionsInMotion.push(healerPosition);
                break;
            }
        }
        return true;
    }
    retreatWhenNotFull() {
        if (this.allCreeps.length < 4) {
            this.setStage(QuadGroupStage.RETREATING);
            console.log("missing quad creeps");
            return true;
        }
        return false;
    }
    turnTowards(targetPos, range) {
        if (this.onExit) {
            return false;
        }
        if (this.getRangeTo(targetPos) > range) {
            return false;
        }
        const expectedDirection = this.anchorCreep.pos.getQuadDirectionTo(targetPos);
        return this.turnToDirection(expectedDirection);
    }
    kite() {
        if (this.fatigue) {
            return true;
        }
        if (this.missingMoveParts) {
            return true;
        }
        const hostileCreeps = this.anchorCreep.pos.findInRange(FIND_HOSTILE_CREEPS, 5);
        if (hostileCreeps.length === 0) {
            return false;
        }
        const ret = PathFinder.search(this.anchorCreep.pos, hostileCreeps.map(c => ({ pos: c.pos, range: 5 })), {
            flee: true,
            roomCallback: (roomName) => {
                const room = Game.rooms[roomName];
                if (!room) {
                    return true; // return base terrain matrix
                }
                const matrix = room.quadMatrix();
                const quadCreepNames = this.quadCreepNames;
                room
                    .find(FIND_CREEPS)
                    .filter(c => !quadCreepNames.includes(c.name))
                    .forEach(c => {
                    matrix.set(c.pos.x, c.pos.y, 256);
                    for (const offset of Object.values(QUAD_POSITION_OFFSETS)) {
                        if (offset.position === ANCHOR_POSITION) {
                            continue;
                        }
                        if (matrix.get(c.pos.x - offset.x, c.pos.y - offset.y) >= 90) {
                            continue;
                        }
                        matrix.set(c.pos.x - offset.x, c.pos.y - offset.y, c.my ? 90 : 30);
                    }
                });
                return matrix;
            }
        });
        const nextPoint = ret.path[0];
        if (!nextPoint) {
            return true;
        }
        const direction = this.anchorCreep.pos.getDirectionTo(nextPoint);
        this.allCreeps.forEach(c => c.move(direction));
        return true;
    }
}

class Quads {
    static create(group) {
        if (!Memory.quads) {
            Memory.quads = {};
        }
        const newId = General.uniqueId();
        Memory.quads[newId] = Object.assign({ id: newId, ticksToLive: CREEP_LIFE_TIME, createdAt: Game.time }, group);
        return newId;
    }
    static allByrole(role) {
        if (!Memory.quads) {
            Memory.quads = {};
        }
        return Object.values(Memory.quads).filter(quad => quad.role === role);
    }
    static isSpawningInRoom(roomName) {
        if (!Memory.quads) {
            Memory.quads = {};
        }
        return (Object.values(Memory.quads).findIndex(g => g.homeRoom === roomName && g.stage === QuadGroupStage.SPAWNING) !== -1);
    }
    static isBoostingInRoom(roomName) {
        if (!Memory.quads) {
            Memory.quads = {};
        }
        return (Object.values(Memory.quads).findIndex(g => g.homeRoom === roomName && g.stage === QuadGroupStage.BOOSTING) !== -1);
    }
    static exit() {
        if (!Memory.quads) {
            Memory.quads = {};
        }
        for (const quadId in Memory.quads) {
            if (Memory.quads[quadId].stage !== QuadGroupStage.SPAWNING &&
                Memory.quads[quadId].stage !== QuadGroupStage.BOOSTING &&
                Memory.quads[quadId].ticksToLive === 0) {
                console.log("deleting quad cuz no ticks", JSON.stringify(Memory.quads[quadId], null, 2));
                delete Memory.quads[quadId];
                continue;
            }
            if (Memory.quads[quadId].createdAt <= Game.time - 3000 &&
                Memory.quads[quadId].stage !== QuadGroupStage.RETREATING) {
                console.log("bugged out quad", JSON.stringify(Memory.quads[quadId], null, 2));
                Memory.quads[quadId].stage = QuadGroupStage.RETREATING;
            }
        }
    }
    static getPositions(pos) {
        return {
            [QuadPosition.TOP_LEFT]: pos.wpos.getOffset(0, 0),
            [QuadPosition.TOP_RIGHT]: pos.wpos.getOffset(1, 0),
            [QuadPosition.BOTTOM_LEFT]: pos.wpos.getOffset(0, 1),
            [QuadPosition.BOTTOM_RIGHT]: pos.wpos.getOffset(1, 1)
        };
    }
}

class HeapRoomCenterContainers {
    static get(room) {
        return this.fromHeap(room.name) || this.fromRoom(room);
    }
    static fromHeap(roomName) {
        const heap = this.heap[roomName];
        if (!heap) {
            return undefined;
        }
        if (heap.updatedAt < Game.time - 1000) {
            return undefined;
        }
        return heap.ids.map(id => Game.getObjectById(id)).filter(Boolean);
    }
    static fromRoom(room) {
        if (!room.center) {
            return this.returnAndCache(room.name, []);
        }
        const containers = room.center.findInRange(FIND_STRUCTURES, 1, {
            filter: s => s.structureType === STRUCTURE_CONTAINER
        });
        return this.returnAndCache(room.name, containers);
    }
    static returnAndCache(roomName, containers) {
        this.heap[roomName] = {
            ids: containers.map(c => c.id),
            updatedAt: Game.time
        };
        return containers;
    }
}
HeapRoomCenterContainers.heap = {};

class HeapRoomCenterLab {
    static get(room) {
        const structure = this.fromHeap(room.name);
        if (structure === null) {
            return null;
        }
        return this.fromRoom(room);
    }
    static fromHeap(roomName) {
        const heap = this.heap[roomName];
        if (!heap) {
            return undefined;
        }
        if (heap.updatedAt < Game.time - 1000) {
            return undefined;
        }
        if (!heap.id) {
            return null;
        }
        return Game.getObjectById(heap.id) || null;
    }
    static fromRoom(room) {
        if (!room.center) {
            return this.returnAndCache(room.name, null);
        }
        const lab = room.center.findInRange(FIND_MY_STRUCTURES, 1).filter(s => s.structureType === STRUCTURE_LAB)[0];
        return this.returnAndCache(room.name, lab || null);
    }
    static returnAndCache(roomName, lab) {
        this.heap[roomName] = {
            id: (lab === null || lab === void 0 ? void 0 : lab.id) || null,
            updatedAt: Game.time
        };
        return lab;
    }
}
HeapRoomCenterLab.heap = {};

class HeapRoomCenterLinks {
    static get(room) {
        return this.fromHeap(room.name) || this.fromRoom(room);
    }
    static fromHeap(roomName) {
        const heap = this.heap[roomName];
        if (!heap) {
            return undefined;
        }
        if (heap.updatedAt < Game.time - 1000) {
            return undefined;
        }
        return heap.ids.map(id => Game.getObjectById(id)).filter(Boolean);
    }
    static fromRoom(room) {
        if (!room.center) {
            return this.returnAndCache(room.name, []);
        }
        const links = room.center.findInRange(FIND_STRUCTURES, 1, {
            filter: s => s.structureType === STRUCTURE_LINK
        });
        return this.returnAndCache(room.name, links);
    }
    static returnAndCache(roomName, links) {
        this.heap[roomName] = {
            ids: links.map(c => c.id),
            updatedAt: Game.time
        };
        return links;
    }
}
HeapRoomCenterLinks.heap = {};

class HeapMyRoomSpawns {
    static get(room) {
        return this.fromHeap(room.name) || this.fromRoom(room);
    }
    static fromHeap(roomName) {
        const heap = this.heap[roomName];
        if (!heap) {
            return undefined;
        }
        if (heap.updatedAt < Game.time - 1000) {
            return undefined;
        }
        return heap.ids.map(id => Game.getObjectById(id)).filter(Boolean);
    }
    static fromRoom(room) {
        if (!room.center) {
            return this.returnAndCache(room.name, []);
        }
        const spawns = room.find(FIND_MY_SPAWNS);
        return this.returnAndCache(room.name, spawns);
    }
    static returnAndCache(roomName, spawns) {
        this.heap[roomName] = {
            ids: spawns.map(c => c.id),
            updatedAt: Game.time
        };
        return spawns;
    }
}
HeapMyRoomSpawns.heap = {};

class HeapMyRoomCenterPowerSpawn {
    static get(room) {
        const structure = this.fromHeap(room.name);
        if (structure === null) {
            return null;
        }
        return this.fromRoom(room);
    }
    static fromHeap(roomName) {
        const heap = this.heap[roomName];
        if (!heap) {
            return undefined;
        }
        if (heap.updatedAt < Game.time - 1000) {
            return undefined;
        }
        if (!heap.id) {
            return null;
        }
        return Game.getObjectById(heap.id) || null;
    }
    static fromRoom(room) {
        if (!room.center) {
            return this.returnAndCache(room.name, null);
        }
        const powerSpawn = room.center
            .findInRange(FIND_MY_STRUCTURES, 1)
            .filter(s => s.structureType === STRUCTURE_POWER_SPAWN)[0];
        return this.returnAndCache(room.name, powerSpawn || null);
    }
    static returnAndCache(roomName, powerSpawn) {
        this.heap[roomName] = {
            id: (powerSpawn === null || powerSpawn === void 0 ? void 0 : powerSpawn.id) || null,
            updatedAt: Game.time
        };
        return powerSpawn;
    }
}
HeapMyRoomCenterPowerSpawn.heap = {};

class HeapMyRoomExtensions {
    static get(room) {
        return this.fromHeap(room.name) || this.fromRoom(room);
    }
    static fromHeap(roomName) {
        const heap = this.heap[roomName];
        if (!heap) {
            return undefined;
        }
        if (heap.updatedAt < Game.time - 1000) {
            return undefined;
        }
        return heap.ids.map(id => Game.getObjectById(id)).filter(Boolean);
    }
    static fromRoom(room) {
        const extensions = room.find(FIND_MY_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_EXTENSION
        });
        return this.returnAndCache(room.name, extensions);
    }
    static returnAndCache(roomName, extensions) {
        this.heap[roomName] = {
            ids: extensions.map(c => c.id),
            updatedAt: Game.time
        };
        return extensions;
    }
}
HeapMyRoomExtensions.heap = {};

class HeapMyRoomTowers {
    static get(room) {
        return this.fromHeap(room.name) || this.fromRoom(room);
    }
    static fromHeap(roomName) {
        const heap = this.heap[roomName];
        if (!heap) {
            return undefined;
        }
        if (heap.updatedAt < Game.time - 1000) {
            return undefined;
        }
        return heap.ids.map(id => Game.getObjectById(id)).filter(Boolean);
    }
    static fromRoom(room) {
        const extensions = room.find(FIND_MY_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_EXTENSION
        });
        return this.returnAndCache(room.name, extensions);
    }
    static returnAndCache(roomName, extensions) {
        this.heap[roomName] = {
            ids: extensions.map(c => c.id),
            updatedAt: Game.time
        };
        return extensions;
    }
}
HeapMyRoomTowers.heap = {};

var FlagType;
(function (FlagType) {
    FlagType["claimer"] = "claimer";
    FlagType["layoutPreview"] = "layoutPreview";
    FlagType["scouter"] = "scouter";
    FlagType["attackerDuoTier0"] = "attackerDuoTier0";
    FlagType["dismantler"] = "dismantler";
    FlagType["dismantlerDuoTier3"] = "dismantlerDuoTier3";
    FlagType["rangedAttackerTier0"] = "rangedAttackerTier0";
    FlagType["rangedAttackerTier1"] = "rangedAttackerTier1";
    FlagType["rangedAttackerTier2"] = "rangedAttackerTier2";
    FlagType["rangedAttackerTier3"] = "rangedAttackerTier3";
    FlagType["remoteHauler"] = "remoteHauler";
    FlagType["controllerAttacker"] = "controllerAttacker";
    FlagType["baseExtensionBlock"] = "baseExtensionBlock";
    FlagType["baseLabBlock"] = "baseLabBlock";
    FlagType["baseCenterBlock"] = "baseCenterBlock";
    FlagType["baseCenterLevelingBlock"] = "baseCenterLevelingBlock";
    FlagType["rangedAttackerQuadTier0"] = "rangedAttackerQuadTier0";
    FlagType["dismantlerQuad"] = "dismantlerQuad";
    FlagType["dismantleTarget"] = "dismantleTarget";
    FlagType["baseInSiegeMode"] = "baseInSiegeMode";
    FlagType["baseTerminalDumper"] = "baseTerminalDumper";
})(FlagType || (FlagType = {}));
const colorToKey = (color, secondaryColor) => {
    return `${color}.${secondaryColor}`;
};
const CONFIG$Q = {
    [colorToKey(COLOR_WHITE, COLOR_PURPLE)]: FlagType.claimer,
    [colorToKey(COLOR_WHITE, COLOR_YELLOW)]: FlagType.baseExtensionBlock,
    [colorToKey(COLOR_WHITE, COLOR_BROWN)]: FlagType.baseLabBlock,
    [colorToKey(COLOR_WHITE, COLOR_WHITE)]: FlagType.baseCenterBlock,
    [colorToKey(COLOR_WHITE, COLOR_ORANGE)]: FlagType.baseCenterLevelingBlock,
    [colorToKey(COLOR_WHITE, COLOR_RED)]: FlagType.baseInSiegeMode,
    [colorToKey(COLOR_GREY, COLOR_BROWN)]: FlagType.baseTerminalDumper,
    [colorToKey(COLOR_GREEN, COLOR_GREEN)]: FlagType.layoutPreview,
    [colorToKey(COLOR_BROWN, COLOR_BROWN)]: FlagType.scouter,
    [colorToKey(COLOR_YELLOW, COLOR_GREEN)]: FlagType.dismantler,
    [colorToKey(COLOR_YELLOW, COLOR_ORANGE)]: FlagType.dismantlerDuoTier3,
    [colorToKey(COLOR_YELLOW, COLOR_BROWN)]: FlagType.dismantlerQuad,
    [colorToKey(COLOR_YELLOW, COLOR_GREY)]: FlagType.dismantleTarget,
    [colorToKey(COLOR_BLUE, COLOR_RED)]: FlagType.rangedAttackerTier0,
    [colorToKey(COLOR_BLUE, COLOR_PURPLE)]: FlagType.rangedAttackerTier1,
    [colorToKey(COLOR_BLUE, COLOR_BLUE)]: FlagType.rangedAttackerTier2,
    [colorToKey(COLOR_BLUE, COLOR_CYAN)]: FlagType.rangedAttackerTier3,
    [colorToKey(COLOR_BLUE, COLOR_GREEN)]: FlagType.rangedAttackerQuadTier0,
    [colorToKey(COLOR_RED, COLOR_PURPLE)]: FlagType.controllerAttacker,
    // [colorToKey(COLOR_RED, COLOR_GREEN)]: FlagType.rangedAttackerQuadTier0,
    [colorToKey(COLOR_PURPLE, COLOR_GREEN)]: FlagType.attackerDuoTier0
};
class Flags {
    static flags(...names) {
        const flags = [];
        Object.values(Game.flags).forEach(flag => {
            const flagType = this.getType(flag);
            if (!flagType) {
                return;
            }
            if (!names.includes(flagType)) {
                return;
            }
            flags.push(flag);
        });
        return flags;
    }
    static roomFlags(room, ...names) {
        const flags = [];
        room.find(FIND_FLAGS).forEach(flag => {
            const flagType = this.getType(flag);
            if (!flagType) {
                return;
            }
            if (!names.includes(flagType)) {
                return;
            }
            flags.push(flag);
        });
        return flags;
    }
    static getType(flag) {
        return CONFIG$Q[colorToKey(flag.color, flag.secondaryColor)];
    }
    static getColors(flagType) {
        for (const key in CONFIG$Q) {
            if (CONFIG$Q[key] !== flagType) {
                continue;
            }
            const [color, secondaryColor] = key.split(".");
            if (!color || !secondaryColor) {
                return;
            }
            return {
                color: parseInt(color, 10),
                secondaryColor: parseInt(secondaryColor, 10)
            };
        }
        return;
    }
}

Object.defineProperty(Room.prototype, "underAttack", {
    get() {
        const room = this;
        if (room._underAttack === undefined) {
            room._underAttack =
                room.hostileHealPower >= 1000 &&
                    room.hostileAttackPower + room.hostileRangedAttackPower + room.hostileDismantlePower > 800;
        }
        return room._underAttack;
    }
});
Object.defineProperty(Room.prototype, "extensions", {
    get() {
        const room = this;
        if (room._extensions === undefined) {
            room._extensions = room
                .find(FIND_STRUCTURES)
                .filter(s => s.structureType === STRUCTURE_EXTENSION);
        }
        return room._extensions;
    }
});
Object.defineProperty(Room.prototype, "myExtensions", {
    get() {
        const room = this;
        if (room._myExtensions === undefined) {
            room._myExtensions = HeapMyRoomExtensions.get(room);
        }
        return room._myExtensions;
    }
});
Object.defineProperty(Room.prototype, "centerBalancerCreep", {
    get() {
        var _a;
        const room = this;
        if (room._centerBalancerCreep === undefined) {
            room._centerBalancerCreep =
                ((_a = room.center) === null || _a === void 0 ? void 0 : _a.lookFor(LOOK_CREEPS).filter(c => { var _a; return ((_a = c.memory) === null || _a === void 0 ? void 0 : _a.role) === Config.BaseCenterBalancer.roleName; })[0]) || null;
        }
        return room._centerBalancerCreep;
    }
});
Object.defineProperty(Room.prototype, "energyBalancerCreeps", {
    get() {
        const room = this;
        if (room._energyBalancerCreeps === undefined) {
            room._energyBalancerCreeps = room
                .find(FIND_MY_CREEPS)
                .filter(c => { var _a; return ((_a = c.memory) === null || _a === void 0 ? void 0 : _a.role) === Config.BaseEnergyBalancer.roleName; });
        }
        return room._energyBalancerCreeps;
    }
});
Object.defineProperty(Room.prototype, "wasRecentlyUnderAttack", {
    get() {
        const room = this;
        if (room._wasRecentlyUnderAttack === undefined) {
            if (room.underAttack) {
                room.mem.wasAttackedAt = Game.time;
            }
            room._wasRecentlyUnderAttack = room.mem.wasAttackedAt ? room.mem.wasAttackedAt > Game.time - 200 : false;
        }
        return room._wasRecentlyUnderAttack;
    }
});
Object.defineProperty(Room.prototype, "hasIncreasedSpawn", {
    get() {
        const room = this;
        if (room._hasIncreasedSpawn === undefined) {
            room._hasIncreasedSpawn = room.mem.increasedSpawnUntil ? room.mem.increasedSpawnUntil > Game.time : false;
        }
        return room._hasIncreasedSpawn;
    }
});
Object.defineProperty(Room.prototype, "hasHostiles", {
    get() {
        const room = this;
        if (room._hasHostiles === undefined) {
            room._hasHostiles = room.find(FIND_HOSTILE_CREEPS).length + room.find(FIND_HOSTILE_POWER_CREEPS).length > 0;
        }
        return room._hasHostiles;
    }
});
Room.prototype.queSpawnCreep = function ({ role, priority, body, optionalBody, memory, boosts, directionToCenter }) {
    if (!this.my) {
        console.log("trying to add spawn to not owned room", role, this.name);
        return;
    }
    if (!Memory.spawnQue) {
        Memory.spawnQue = [];
    }
    Memory.spawnQue.push({
        rooms: [this.name],
        role,
        priority,
        body,
        optionalBody,
        memory: Object.assign(Object.assign({}, memory), { homeRoom: this.name, role, boosts }),
        boosts,
        directionToCenter,
        createdAt: Game.time,
        expiresAt: Game.time + 300
    });
    Memory.spawnQue = Memory.spawnQue.sort((a, b) => a.priority - b.priority);
};
Room.prototype.roadPositions = function () {
    return [
        ...this.find(FIND_STRUCTURES, { filter: s => s.structureType === STRUCTURE_ROAD }).map(s => ({
            x: s.pos.x,
            y: s.pos.y
        })),
        ...this.find(FIND_CONSTRUCTION_SITES, { filter: s => s.structureType === STRUCTURE_ROAD }).map(s => ({
            x: s.pos.x,
            y: s.pos.y
        }))
    ];
};
Room.prototype.matrix = function (opts) {
    const options = Object.assign({ edgeCost: 20 }, opts);
    const matrix = new PathFinder.CostMatrix();
    const terrain = this.getTerrain();
    this.find(FIND_SOURCES).forEach(s => {
        General.squarePositions(s.pos.roomName, s.pos.x, s.pos.y, 1).forEach(p => {
            if (terrain.get(p.x, p.y) === TERRAIN_MASK_WALL) {
                return;
            }
            matrix.set(p.x, p.y, 10);
        });
    });
    this.find(FIND_MINERALS).forEach(s => {
        General.squarePositions(s.pos.roomName, s.pos.x, s.pos.y, 1).forEach(p => {
            if (terrain.get(p.x, p.y) === TERRAIN_MASK_WALL) {
                return;
            }
            matrix.set(p.x, p.y, 20);
        });
    });
    if (this.controller) {
        General.squarePositions(this.name, this.controller.pos.x, this.controller.pos.y, 1).forEach(p => {
            if (terrain.get(p.x, p.y) === TERRAIN_MASK_WALL) {
                return;
            }
            matrix.set(p.x, p.y, 10);
        });
    }
    Geo.roomEdges(2).forEach(p => {
        if (terrain.get(p.x, p.y) === TERRAIN_MASK_WALL) {
            return;
        }
        if (p.x === 49 || p.x === 0 || p.y === 49 || p.y === 0) {
            matrix.set(p.x, p.y, options.edgeCost);
        }
        else {
            matrix.set(p.x, p.y, 2);
        }
    });
    this.find(FIND_MY_CONSTRUCTION_SITES).forEach(site => {
        if (site.my && OBSTACLE_OBJECT_TYPES.includes(site.structureType)) {
            matrix.set(site.pos.x, site.pos.y, 255);
        }
        if (site.structureType === STRUCTURE_ROAD) {
            matrix.set(site.pos.x, site.pos.y, 1);
        }
    });
    this.find(FIND_STRUCTURES).filter(structure => {
        const currentMatrix = matrix.get(structure.pos.x, structure.pos.y);
        if (structure.structureType === STRUCTURE_ROAD && currentMatrix <= 1) {
            matrix.set(structure.pos.x, structure.pos.y, 1);
        }
        if (structure.structureType === STRUCTURE_PORTAL) {
            matrix.set(structure.pos.x, structure.pos.y, 254);
        }
        if (OBSTACLE_OBJECT_TYPES.includes(structure.structureType)) {
            matrix.set(structure.pos.x, structure.pos.y, 255);
        }
        if (options.storageCost && structure.structureType === STRUCTURE_STORAGE) {
            matrix.set(structure.pos.x, structure.pos.y, options.storageCost);
        }
        if (structure.structureType === STRUCTURE_RAMPART && !structure.my) {
            matrix.set(structure.pos.x, structure.pos.y, 255);
        }
    });
    return matrix;
};
Room.prototype.quadMatrix = function () {
    return Rooms.quadMatrix(this.name);
};
Room.prototype.obstaclePositions = function () {
    return this.find(FIND_STRUCTURES, {
        filter: s => OBSTACLE_OBJECT_TYPES.includes(s.structureType) ||
            (s.structureType === STRUCTURE_RAMPART && !s.my)
    }).map(s => ({ x: s.pos.x, y: s.pos.y }));
};
Room.prototype.portals = function () {
    const portals = this.find(FIND_STRUCTURES, {
        filter: { structureType: STRUCTURE_PORTAL }
    });
    return portals.map(s => {
        return Object.assign({ x: s.pos.x, y: s.pos.y }, (s.destination instanceof RoomPosition
            ? {
                shard: Game.shard.name,
                room: s.destination.roomName,
                toX: s.destination.x,
                toY: s.destination.y
            }
            : {
                shard: s.destination.shard,
                room: s.destination.room
            }));
    });
};
Object.defineProperty(Room.prototype, "edgePositions", {
    get() {
        const room = this;
        if (room._edgePositions === undefined) {
            room._edgePositions = Geo.roomEdges().map(pos => ({ pos: new RoomPosition(pos.x, pos.y, room.name) }));
        }
        return room._edgePositions;
    }
});
Object.defineProperty(Room.prototype, "edgeDangerPositions", {
    get() {
        const room = this;
        if (room._edgeDangerPositions === undefined) {
            room._edgeDangerPositions = Geo.roomEdges(2)
                .map(pos => ({ pos: new RoomPosition(pos.x, pos.y, room.name) }))
                .filter(pos => pos.pos.findInRange(FIND_EXIT, 1).length > 0);
        }
        return room._edgeDangerPositions;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "defenceWalls", {
    get() {
        const room = this;
        if (room._defenceWalls === undefined) {
            const goodCoordinates = [2, 3, 4, 45, 46, 47];
            room._defenceWalls = room
                .find(FIND_STRUCTURES)
                .filter(structure => structure.structureType === STRUCTURE_WALL &&
                (goodCoordinates.includes(structure.pos.x) || goodCoordinates.includes(structure.pos.y)));
        }
        return room._defenceWalls;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "defenceRamparts", {
    get() {
        const room = this;
        if (room._defenceRamparts === undefined) {
            const goodCoordinates = [2, 3, 4, 45, 46, 47];
            room._defenceRamparts = room
                .find(FIND_MY_STRUCTURES)
                .filter(structure => structure.structureType === STRUCTURE_RAMPART &&
                (goodCoordinates.includes(structure.pos.x) || goodCoordinates.includes(structure.pos.y)));
        }
        return room._defenceRamparts;
    },
    enumerable: false,
    configurable: true
});
Room.prototype.controllerLinkConstruction = function () {
    var _a;
    if (this._controllerLinkConstruction === undefined) {
        this._controllerLinkConstruction =
            ((_a = this.controller) === null || _a === void 0 ? void 0 : _a.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 3).filter(structure => structure.structureType === STRUCTURE_LINK)[0]) || null;
    }
    return this._controllerLinkConstruction;
};
Room.prototype.observer = function () {
    if (this._observer === undefined) {
        this._observer = getObserver(this);
    }
    return this._observer;
};
function getObserver(room) {
    if (!room.controller)
        return null;
    if (room.controller.level < 8)
        return null;
    const observer = room
        .find(FIND_MY_STRUCTURES)
        .filter(structure => structure.structureType === STRUCTURE_OBSERVER)[0];
    return observer || null;
}
Room.prototype.isHighway = function () {
    if (this._isHighway === undefined) {
        const parsed = /^[WE]([0-9]+)[NS]([0-9]+)$/.exec(this.name);
        this._isHighway = parsed[1] % 10 === 0 || parsed[2] % 10 === 0;
    }
    return this._isHighway;
};
Room.prototype.availableSpawns = function () {
    if (this._availableSpawns === undefined) {
        this._availableSpawns = this.find(FIND_MY_SPAWNS).filter(spawn => spawn.spawning === null);
    }
    return this._availableSpawns;
};
Object.defineProperty(Room.prototype, "mySpawns", {
    get() {
        const room = this;
        if (room._mySpawns === undefined) {
            room._mySpawns = HeapMyRoomSpawns.get(room);
        }
        return room._mySpawns;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "myActiveSpawns", {
    get() {
        const room = this;
        if (room._myActiveSpawns === undefined) {
            room._myActiveSpawns = room.mySpawns.filter(s => s.cachedIsActive());
        }
        return room._myActiveSpawns;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "hasSkDefenders", {
    get() {
        const room = this;
        if (room._hasSkDefenders === undefined) {
            room._hasSkDefenders =
                room.find(FIND_MY_CREEPS).filter(c => {
                    return c.memory.role === ROLE_NAME$h || c.memory.role === ROLE_NAME$i;
                }).length > 0;
        }
        return room._hasSkDefenders;
    },
    enumerable: false,
    configurable: true
});
Room.prototype.resourceAmount = function (resource) {
    var _a, _b;
    if (this._resourceAmount === undefined) {
        this._resourceAmount = {};
    }
    if (this._resourceAmount[resource] === undefined) {
        let amount = 0;
        amount += ((_a = this.storage) === null || _a === void 0 ? void 0 : _a.store[resource]) || 0;
        amount += ((_b = this.terminal) === null || _b === void 0 ? void 0 : _b.store[resource]) || 0;
        this.find(FIND_MY_STRUCTURES).forEach(structure => {
            if (structure.structureType !== STRUCTURE_LAB)
                return;
            amount += structure.store[resource];
        });
        //
        // amount += this.find(FIND_MY_CREEPS).reduce((previous, creep) => previous + (creep.store[resource] || 0), 0);
        this._resourceAmount[resource] = amount;
    }
    return this._resourceAmount[resource] || 0;
};
Object.defineProperty(Room.prototype, "my", {
    get() {
        const room = this;
        if (room._my === undefined) {
            room._my = room.controller && room.controller.my;
        }
        return room._my;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "labInputs", {
    get() {
        const room = this;
        if (room._labInputs === undefined) {
            const labs = [];
            Flags.roomFlags(room, FlagType.baseLabBlock).forEach(flag => {
                const lab = flag.pos.lookFor(LOOK_STRUCTURES).filter(s => s.structureType === STRUCTURE_LAB)[0];
                if (!lab) {
                    return;
                }
                labs.push(lab);
            });
            room._labInputs = labs;
        }
        return room._labInputs;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "labs", {
    get() {
        const room = this;
        if (room._labs === undefined) {
            room._labs = room.find(FIND_STRUCTURES, { filter: s => s.structureType === STRUCTURE_LAB });
        }
        return room._labs;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "labOutputs", {
    get() {
        const room = this;
        if (room._labOutputs === undefined) {
            const inputFlags = Flags.roomFlags(room, FlagType.baseLabBlock);
            room._labOutputs = room.labs.filter(lab => inputFlags.filter(flag => flag.pos.isEqualTo(lab.pos)).length === 0 &&
                inputFlags.filter(flag => flag.pos.inRangeTo(lab, 1)).length > 0);
        }
        return room._labOutputs;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "centerLinks", {
    get() {
        const room = this;
        if (room._centerLinks === undefined) {
            room._centerLinks = HeapRoomCenterLinks.get(room);
        }
        return room._centerLinks;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "centerLab", {
    get() {
        const room = this;
        if (room._centerLab === undefined) {
            room._centerLab = HeapRoomCenterLab.get(room);
        }
        return room._centerLab;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "centerLabPos", {
    get() {
        const room = this;
        if (room._centerLabPos === undefined) {
            room._centerLabPos = room.center ? new RoomPosition(room.center.x + 1, room.center.y + 1, room.name) : null;
        }
        return room._centerLabPos;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "centerStoragePos", {
    get() {
        const room = this;
        if (room._centerStoragePos === undefined) {
            room._centerStoragePos = room.center ? new RoomPosition(room.center.x - 1, room.center.y - 1, room.name) : null;
        }
        return room._centerStoragePos;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "controllerLink", {
    get() {
        var _a;
        const room = this;
        if (room._controllerLink === undefined) {
            room._controllerLink =
                ((_a = room.controller) === null || _a === void 0 ? void 0 : _a.pos.findInRange(FIND_MY_STRUCTURES, 2).filter(structure => structure.structureType === STRUCTURE_LINK).sort((a, b) => (room.controller ? a.pos.getRangeTo(room.controller) : Number.POSITIVE_INFINITY) -
                    (room.controller ? b.pos.getRangeTo(room.controller) : Number.POSITIVE_INFINITY))[0]) || null;
        }
        return room._controllerLink;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "hostileHealPower", {
    get() {
        const room = this;
        if (room._hostileHealPower === undefined) {
            let power = 0;
            room
                .find(FIND_HOSTILE_CREEPS)
                .filter(c => !c.isNPC)
                .filter(creep => {
                power += creep.healPower;
            });
            room._hostileHealPower = power;
            room.mem.hostileHealPower = power || undefined;
        }
        return room._hostileHealPower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "hostileAttackPower", {
    get() {
        const room = this;
        if (room._hostileAttackPower === undefined) {
            let power = 0;
            room
                .find(FIND_HOSTILE_CREEPS)
                .filter(c => !c.isNPC)
                .filter(creep => {
                power += creep.attackPower;
            });
            room._hostileAttackPower = power;
            room.mem.hostileAttackPower = power || undefined;
        }
        return room._hostileAttackPower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "hostileRangedAttackPower", {
    get() {
        const room = this;
        if (room._hostileRangedAttackPower === undefined) {
            let power = 0;
            room
                .find(FIND_HOSTILE_CREEPS)
                .filter(c => !c.isNPC)
                .filter(creep => {
                power += creep.rangedAttackPower;
            });
            room._hostileRangedAttackPower = power;
            room.mem.hostileRangedAttackPower = power || undefined;
        }
        return room._hostileRangedAttackPower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "hostileDismantlePower", {
    get() {
        const room = this;
        if (room._hostileDismantlePower === undefined) {
            let power = 0;
            room
                .find(FIND_HOSTILE_CREEPS)
                .filter(c => !c.isNPC)
                .filter(creep => {
                power += creep.dismantlePower;
            });
            room._hostileDismantlePower = power;
            room.mem.hostileDismantlePower = power || undefined;
        }
        return room._hostileDismantlePower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "npcHealPower", {
    get() {
        const room = this;
        if (room._npcHealPower === undefined) {
            let power = 0;
            room
                .find(FIND_HOSTILE_CREEPS)
                .filter(c => c.isNPC)
                .filter(creep => {
                power += creep.healPower;
            });
            room._npcHealPower = power;
            room.mem.npcHealPower = power || undefined;
        }
        return room._npcHealPower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "npcAttackPower", {
    get() {
        const room = this;
        if (room._npcAttackPower === undefined) {
            let power = 0;
            room
                .find(FIND_HOSTILE_CREEPS)
                .filter(c => c.isNPC)
                .filter(creep => {
                power += creep.attackPower;
            });
            room._npcAttackPower = power;
            room.mem.npcAttackPower = power || undefined;
        }
        return room._npcAttackPower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "npcRangedAttackPower", {
    get() {
        const room = this;
        if (room._npcRangedAttackPower === undefined) {
            let power = 0;
            room
                .find(FIND_HOSTILE_CREEPS)
                .filter(c => c.isNPC)
                .filter(creep => {
                power += creep.rangedAttackPower;
            });
            room._npcRangedAttackPower = power;
            room.mem.npcRangedAttackPower = power || undefined;
        }
        return room._npcRangedAttackPower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "myHealPower", {
    get() {
        const room = this;
        if (room._myHealPower === undefined) {
            let power = 0;
            room.find(FIND_MY_CREEPS).filter(creep => {
                power += creep.healPower;
            });
            room._myHealPower = power;
            room.mem.myHealPower = power || undefined;
        }
        return room._myHealPower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "myAttackPower", {
    get() {
        const room = this;
        if (room._myAttackPower === undefined) {
            let power = 0;
            room.find(FIND_MY_CREEPS).filter(creep => {
                power += creep.attackPower;
            });
            room._myAttackPower = power;
            room.mem.myAttackPower = power || undefined;
        }
        return room._myAttackPower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "myRangedAttackPower", {
    get() {
        const room = this;
        if (room._myRangedAttackPower === undefined) {
            let power = 0;
            room.find(FIND_MY_CREEPS).filter(creep => {
                power += creep.rangedAttackPower;
            });
            room._myRangedAttackPower = power;
            room.mem.myRangedAttackPower = power || undefined;
        }
        return room._myRangedAttackPower;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "controllerContainer", {
    get() {
        var _a;
        const room = this;
        if (room._controllerContainer === undefined) {
            room._controllerContainer =
                ((_a = room.controller) === null || _a === void 0 ? void 0 : _a.pos.findInRange(FIND_STRUCTURES, 3).filter(structure => structure.structureType === STRUCTURE_CONTAINER)[0]) ||
                    null;
        }
        return room._controllerContainer;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "controllerContainers", {
    get() {
        var _a;
        const room = this;
        if (room._controllerContainers === undefined) {
            room._controllerContainers = (_a = room.controller) === null || _a === void 0 ? void 0 : _a.pos.findInRange(FIND_STRUCTURES, 3).filter(structure => structure.structureType === STRUCTURE_CONTAINER);
        }
        return room._controllerContainers;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "myCenterPowerSpawn", {
    get() {
        const room = this;
        if (room._myCenterPowerSpawn === undefined) {
            room._myCenterPowerSpawn = HeapMyRoomCenterPowerSpawn.get(room);
        }
        return room._myCenterPowerSpawn;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "factory", {
    get() {
        const room = this;
        if (room._factory === undefined) {
            room._factory =
                room.find(FIND_MY_STRUCTURES, { filter: s => s.structureType === STRUCTURE_FACTORY })[0] || null;
        }
        return room._factory;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "center", {
    get() {
        var _a, _b;
        const room = this;
        if (room._center === undefined) {
            room._center = ((_b = (_a = Flags.roomFlags(room, FlagType.baseCenterBlock)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.pos) || null;
        }
        return room._center;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "centerLeveling", {
    get() {
        var _a, _b;
        const room = this;
        if (room._centerLeveling === undefined) {
            room._centerLeveling = ((_b = (_a = Flags.roomFlags(room, FlagType.baseCenterLevelingBlock)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.pos) || null;
        }
        return room._centerLeveling;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "invaderCore", {
    get() {
        const room = this;
        if (room._invaderCore === undefined) {
            room._invaderCore =
                room
                    .find(FIND_HOSTILE_STRUCTURES)
                    .filter(structure => structure.structureType === STRUCTURE_INVADER_CORE)[0] || null;
        }
        return room._invaderCore;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "nuker", {
    get() {
        const room = this;
        if (room._nuker === undefined) {
            room._nuker =
                room.find(FIND_STRUCTURES).filter(structure => structure.structureType === STRUCTURE_NUKER)[0] || null;
        }
        return room._nuker;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "isSiegeBase", {
    get() {
        const room = this;
        if (room._isSiegeBase === undefined) {
            room._isSiegeBase = Flags.roomFlags(room, FlagType.baseInSiegeMode).length > 0;
        }
        return room._isSiegeBase;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "centerRoomName", {
    get() {
        const room = this;
        if (room._centerRoomName === undefined) {
            room._centerRoomName = room.name.replace(/([WESN].?)([0-9])/g, "$15");
        }
        return room._centerRoomName;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "store", {
    get() {
        const room = this;
        if (room._store === undefined) {
            const store = {
                [RESOURCE_ENERGY]: 0,
                [RESOURCE_POWER]: 0,
                [RESOURCE_HYDROGEN]: 0,
                [RESOURCE_OXYGEN]: 0,
                [RESOURCE_UTRIUM]: 0,
                [RESOURCE_KEANIUM]: 0,
                [RESOURCE_LEMERGIUM]: 0,
                [RESOURCE_ZYNTHIUM]: 0,
                [RESOURCE_CATALYST]: 0,
                [RESOURCE_GHODIUM]: 0,
                [RESOURCE_HYDROXIDE]: 0,
                [RESOURCE_ZYNTHIUM_KEANITE]: 0,
                [RESOURCE_UTRIUM_LEMERGITE]: 0,
                [RESOURCE_UTRIUM_HYDRIDE]: 0,
                [RESOURCE_UTRIUM_OXIDE]: 0,
                [RESOURCE_KEANIUM_HYDRIDE]: 0,
                [RESOURCE_KEANIUM_OXIDE]: 0,
                [RESOURCE_LEMERGIUM_HYDRIDE]: 0,
                [RESOURCE_LEMERGIUM_OXIDE]: 0,
                [RESOURCE_ZYNTHIUM_HYDRIDE]: 0,
                [RESOURCE_ZYNTHIUM_OXIDE]: 0,
                [RESOURCE_GHODIUM_HYDRIDE]: 0,
                [RESOURCE_GHODIUM_OXIDE]: 0,
                [RESOURCE_UTRIUM_ACID]: 0,
                [RESOURCE_UTRIUM_ALKALIDE]: 0,
                [RESOURCE_KEANIUM_ACID]: 0,
                [RESOURCE_KEANIUM_ALKALIDE]: 0,
                [RESOURCE_LEMERGIUM_ACID]: 0,
                [RESOURCE_LEMERGIUM_ALKALIDE]: 0,
                [RESOURCE_ZYNTHIUM_ACID]: 0,
                [RESOURCE_ZYNTHIUM_ALKALIDE]: 0,
                [RESOURCE_GHODIUM_ACID]: 0,
                [RESOURCE_GHODIUM_ALKALIDE]: 0,
                [RESOURCE_CATALYZED_UTRIUM_ACID]: 0,
                [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: 0,
                [RESOURCE_CATALYZED_KEANIUM_ACID]: 0,
                [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: 0,
                [RESOURCE_CATALYZED_LEMERGIUM_ACID]: 0,
                [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: 0,
                [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: 0,
                [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: 0,
                [RESOURCE_CATALYZED_GHODIUM_ACID]: 0,
                [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: 0,
                [RESOURCE_OPS]: 0,
                [RESOURCE_SILICON]: 0,
                [RESOURCE_METAL]: 0,
                [RESOURCE_BIOMASS]: 0,
                [RESOURCE_MIST]: 0,
                [RESOURCE_UTRIUM_BAR]: 0,
                [RESOURCE_LEMERGIUM_BAR]: 0,
                [RESOURCE_ZYNTHIUM_BAR]: 0,
                [RESOURCE_KEANIUM_BAR]: 0,
                [RESOURCE_GHODIUM_MELT]: 0,
                [RESOURCE_OXIDANT]: 0,
                [RESOURCE_REDUCTANT]: 0,
                [RESOURCE_PURIFIER]: 0,
                [RESOURCE_BATTERY]: 0,
                [RESOURCE_COMPOSITE]: 0,
                [RESOURCE_CRYSTAL]: 0,
                [RESOURCE_LIQUID]: 0,
                [RESOURCE_WIRE]: 0,
                [RESOURCE_SWITCH]: 0,
                [RESOURCE_TRANSISTOR]: 0,
                [RESOURCE_MICROCHIP]: 0,
                [RESOURCE_CIRCUIT]: 0,
                [RESOURCE_DEVICE]: 0,
                [RESOURCE_CELL]: 0,
                [RESOURCE_PHLEGM]: 0,
                [RESOURCE_TISSUE]: 0,
                [RESOURCE_MUSCLE]: 0,
                [RESOURCE_ORGANOID]: 0,
                [RESOURCE_ORGANISM]: 0,
                [RESOURCE_ALLOY]: 0,
                [RESOURCE_TUBE]: 0,
                [RESOURCE_FIXTURES]: 0,
                [RESOURCE_FRAME]: 0,
                [RESOURCE_HYDRAULICS]: 0,
                [RESOURCE_MACHINE]: 0,
                [RESOURCE_CONDENSATE]: 0,
                [RESOURCE_CONCENTRATE]: 0,
                [RESOURCE_EXTRACT]: 0,
                [RESOURCE_SPIRIT]: 0,
                [RESOURCE_EMANATION]: 0,
                [RESOURCE_ESSENCE]: 0
            };
            const structures = room
                .find(FIND_STRUCTURES)
                .filter(s => s.structureType === STRUCTURE_LAB ||
                s.structureType === STRUCTURE_STORAGE ||
                s.structureType === STRUCTURE_TERMINAL ||
                s.structureType === STRUCTURE_FACTORY);
            structures.forEach(s => {
                Object.entries(s.store).forEach(([resource, amount]) => {
                    store[resource] += amount;
                });
            });
            const creeps = room
                .find(FIND_MY_CREEPS)
                .filter(c => c.memory.role === Config.BaseCenterBalancer.roleName || c.memory.role === Config.BaseLabBalancer.roleName);
            creeps.forEach(c => {
                Object.entries(c.store).forEach(([resource, amount]) => {
                    store[resource] += amount;
                });
            });
            room._store = store;
        }
        return room._store;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "mightHaveInvaders", {
    get() {
        const room = this;
        if (room._mightHaveInvaders === undefined) {
            room._mightHaveInvaders = Cache.remember({
                key: `${room.name}.mightHaveInvaders`,
                expiresIn: 1500,
                updatesIn: 500,
                value() {
                    const SK_ROOM_COORDINATES = [
                        { x: 6, y: 4 },
                        { x: 5, y: 4 },
                        { x: 4, y: 4 },
                        { x: 4, y: 5 },
                        { x: 4, y: 6 },
                        { x: 5, y: 6 },
                        { x: 6, y: 6 },
                        { x: 6, y: 5 }
                    ];
                    const roomNames = SK_ROOM_COORDINATES.map(offset => room.name.replace(/([WE].?)([0-9])([SN].?)([0-9])/g, `$1${offset.x}$3${offset.y}`));
                    return roomNames.filter(roomName => { var _a; return (_a = Memory.strongholds[roomName]) === null || _a === void 0 ? void 0 : _a.isAlive; }).length > 0;
                }
            });
        }
        return room._mightHaveInvaders;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "isAbandoning", {
    get() {
        const room = this;
        if (room._isAbandoning === undefined) {
            room._isAbandoning = ABANDONING_ROOMS.includes(room.name);
        }
        return room._isAbandoning;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "level", {
    get() {
        var _a;
        const room = this;
        if (room._level === undefined) {
            room._level = ((_a = room.controller) === null || _a === void 0 ? void 0 : _a.level) || 0;
        }
        return room._level;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "isSpawningDuo", {
    get() {
        const room = this;
        if (room._isSpawningDuo === undefined) {
            room._isSpawningDuo = Duos.isSpawningInRoom(room.name);
        }
        return room._isSpawningDuo;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "powerBank", {
    get() {
        const room = this;
        if (room._powerBank === undefined) {
            room._powerBank = (room
                .find(FIND_HOSTILE_STRUCTURES, { filter: s => s.structureType === STRUCTURE_POWER_BANK })
                .sort((a, b) => a.hits - b.hits)[0] || null);
        }
        return room._powerBank;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "isSpawningQuad", {
    get() {
        const room = this;
        if (room._isSpawningQuad === undefined) {
            room._isSpawningQuad = Quads.isSpawningInRoom(room.name) || Quads.isBoostingInRoom(room.name);
        }
        return room._isSpawningQuad;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "towers", {
    get() {
        const room = this;
        if (room._towers === undefined) {
            room._towers = room.find(FIND_STRUCTURES, {
                filter: s => s.structureType === STRUCTURE_TOWER
            });
        }
        return room._towers;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "myTowers", {
    get() {
        const room = this;
        if (room._myTowers === undefined) {
            room._myTowers = HeapMyRoomTowers.get(room);
        }
        return room._myTowers;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "centerContainers", {
    get() {
        const room = this;
        if (room._centerContainers === undefined) {
            room._centerContainers = HeapRoomCenterContainers.get(room);
        }
        return room._centerContainers;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "isNewbie", {
    get() {
        const room = this;
        if (room._isNewbie === undefined) {
            room._isNewbie =
                room.level < 4 || !room.storage || room.storage.store.energy < 20000 || room.energyCapacityAvailable < 1300;
        }
        return room._isNewbie;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "shouldConstruct", {
    get() {
        const room = this;
        if (room._shouldConstruct === undefined) {
            room._shouldConstruct =
                room.level >= 6 ||
                    room.find(FIND_FLAGS).filter(f => f.color === COLOR_WHITE && f.secondaryColor === COLOR_GREEN).length === 0;
        }
        return room._shouldConstruct;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "boostsMissing", {
    get() {
        const room = this;
        if (room._boostsMissing === undefined) {
            room._boostsMissing = room.centerLab
                ? Object.values(room.centerLab.pos.findInRange(FIND_MY_CREEPS, 2).reduce((boosts, c) => {
                    if (c.memory.recycling) {
                        return boosts;
                    }
                    c.boostsMissing.forEach(boost => {
                        if (boosts[boost.boost]) {
                            boosts[boost.boost].amount += boost.amount;
                        }
                        else {
                            boosts[boost.boost] = boost;
                        }
                    });
                    return boosts;
                }, {})).sort((a, b) => {
                    const getText = (boost) => {
                        const tier = Resources.resourceGroup(a.boost);
                        if (tier === ResourceType.T1BOOST) {
                            return `1-${boost}`;
                        }
                        if (tier === ResourceType.T2BOOST) {
                            return `2-${boost}`;
                        }
                        if (tier === ResourceType.T3BOOST) {
                            return `3-${boost}`;
                        }
                        return `9-${boost}`;
                    };
                    return getText(b.boost).localeCompare(getText(a.boost));
                })
                : [];
        }
        return room._boostsMissing;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "model", {
    get() {
        const room = this;
        if (room._model === undefined) {
            room._model = new RoomModel(room.name);
        }
        return room._model;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "isGclFarm", {
    get() {
        const room = this;
        if (room._isGclFarm === undefined) {
            room._isGclFarm = Object.keys(GCL_POWERLEVEL_ROOMS).includes(room.name);
        }
        return room._isGclFarm;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "isGclFarmMaster", {
    get() {
        const room = this;
        if (room._isGclFarmMaster === undefined) {
            room._isGclFarmMaster = Object.values(GCL_POWERLEVEL_ROOMS).filter(rooms => rooms.includes(room.name)).length > 0;
        }
        return room._isGclFarmMaster;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "gclMasterRooms", {
    get() {
        const room = this;
        if (room._gclMasterRooms === undefined) {
            const rooms = [];
            const config = GCL_POWERLEVEL_ROOMS[room.name] || [];
            config.forEach(r => {
                const roomObject = Game.rooms[r];
                if (roomObject) {
                    rooms.push(roomObject);
                }
            });
            room._gclMasterRooms = rooms;
        }
        return room._gclMasterRooms;
    },
    enumerable: false,
    configurable: true
});
Room.prototype.distanceToTarget = function (target, range = 0) {
    var _a;
    if (!this.mem.centerDistances) {
        this.mem.centerDistances = {};
    }
    let distance = this.mem.centerDistances[target.id];
    if (distance) {
        return distance;
    }
    const center = ((_a = this.storage) === null || _a === void 0 ? void 0 : _a.pos) || this.center;
    if (!center) {
        return Infinity;
    }
    distance = Geo.getPathCost(center, target.pos, range);
    if (!distance) {
        distance = Infinity;
    }
    this.mem.centerDistances[target.id] = distance;
    return distance;
};
Room.prototype.sourceOptions = function (source) {
    var _a;
    if (!this.mem.sources) {
        this.mem.sources = {};
    }
    if (this.mem.sources[source.id] === undefined) {
        const center = ((_a = this.storage) === null || _a === void 0 ? void 0 : _a.pos) || this.center;
        const findMiningPos = () => {
            if (!center) {
                Log.room(this, "cant find room center");
                return;
            }
            const path = center.findPathTo(source, {
                ignoreCreeps: true,
                maxRooms: 1,
                ignoreRoads: true
            });
            const lastPos = path[path.length - 2];
            if (source.pos.getRangeTo(lastPos.x, lastPos.y) !== 1) {
                Log.object(source, "cant find path for mining");
                return;
            }
            return { x: lastPos.x, y: lastPos.y };
        };
        this.mem.sources[source.id] = {
            id: source.id,
            distance: center ? Geo.getPathCost(center, source.pos, 0) : undefined,
            miningPos: findMiningPos(),
            updatedAt: Game.time
        };
    }
    return this.mem.sources[source.id];
};
Object.defineProperty(Room.prototype, "tickCache", {
    get() {
        const room = this;
        if (room._tickCache === undefined) {
            room._tickCache = {};
        }
        return room._tickCache;
    },
    set(value) {
        const room = this;
        room._tickCache = value;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(Room.prototype, "mem", {
    get() {
        const room = this;
        if (!(room.tickCache.mem instanceof RoomMemoryObject)) {
            room.tickCache.mem = new RoomMemoryObject(room.name);
        }
        return room.tickCache.mem;
    },
    enumerable: false,
    configurable: true
});
// Room.prototype.remoteMineRooms = function (): RoomRemoteMine[] {
//   if (!this.memory.remoteMines || this.memory.remoteMines.updatedAt < Game.time - 20) {
//     const suroundingRoomNames = (): string[] => {
//       const rooms: Record<string, string> = {};
//
//       Object.values(Game.map.describeExits(this.name)).forEach(exitRoomName => {
//         if (!exitRoomName) {
//           return;
//         }
//
//         if (Memory.rooms[exitRoomName]?.type === RoomTypeEnum.STANDART) {
//           rooms[exitRoomName] = exitRoomName;
//         }
//
//         Object.values(Game.map.describeExits(exitRoomName)).forEach(exitRoomName2 => {
//           if (!exitRoomName2) {
//             return;
//           }
//
//           if (Game.map.getRoomLinearDistance(this.name, exitRoomName2) !== 1) {
//             return;
//           }
//
//           if (Memory.rooms[exitRoomName2]?.type === RoomTypeEnum.STANDART) {
//             rooms[exitRoomName2] = exitRoomName2;
//           }
//         });
//       });
//
//       return Object.values(rooms);
//     };
//
//     this.memory.remoteMines = {
//       rooms: suroundingRoomNames().reduce((rooms, targetRoomName) => {
//         const mineRoom = this.remoteMineRoom(targetRoomName);
//
//         if (!mineRoom) {
//           return rooms;
//         }
//
//         rooms[targetRoomName] = mineRoom;
//
//         return rooms;
//       }, {} as Record<string, RoomRemoteMine>),
//       updatedAt: Game.time
//     };
//   }
//
//   return Object.values(this.memory.remoteMines.rooms);
// };
//
// Room.prototype.remoteMineRoom = function (roomName: string): RoomRemoteMine {
//   if (!this.memory.remoteMines) {
//     this.memory.remoteMines = {};
//   }
//
//   if (!this.memory.remoteMines.rooms[roomName]) {
//     const targetRoom = Game.rooms[roomName];
//
//     this.memory.remoteMines.rooms[roomName] = {
//       roomName,
//       route: Geo.findRouteCached(this.name, roomName),
//       sources: targetRoom
//         ? targetRoom.find(FIND_SOURCES).reduce((sources, source) => {
//             sources[source.id] = this.remoteMineRoomSource(roomName, source.id);
//
//             return sources;
//           }, {} as Record<string, RoomRemoteMineSource>)
//         : undefined,
//       at: Game.time
//     };
//   }
//
//   return this.memory.remoteMines?.rooms[roomName];
// };
//
// Room.prototype.remoteMineRoomSource = function (roomName: string, sourceId: string): RoomRemoteMineSource {
//   const source = Game.getObjectById(sourceId);
//
//   return {
//     id: sourceId,
//     distance: 12,
//     miningPos: { x: 12, y: 12 }
//   };
// };

class HeapStructureSpawnIsActive {
    static get(structure) {
        const fromHeap = this.fromHeap(structure);
        if (fromHeap !== undefined) {
            return fromHeap;
        }
        return this.fromStructure(structure);
    }
    static fromHeap(structure) {
        const heap = this.heap[structure.id];
        if (!heap) {
            return undefined;
        }
        if (heap.updatedAt < Game.time - 1000) {
            return undefined;
        }
        return heap.active;
    }
    static fromStructure(structure) {
        return this.returnAndCache(structure, structure.room.level >= 8 || structure.isActive());
    }
    static returnAndCache(structure, active) {
        this.heap[structure.id] = {
            active,
            updatedAt: Game.time
        };
        return active;
    }
}
HeapStructureSpawnIsActive.heap = {};

StructureSpawn.prototype.renewCreepV2 = function (creep) {
    if (this.actionPending)
        return false;
    if (this.room.spawningCreep)
        return false;
    const response = this.renewCreep(creep);
    if (response === OK) {
        this.actionPending = true;
        this.room.spawningCreep = true;
    }
    else if (response === ERR_NOT_IN_RANGE) {
        creep.travel(this);
    }
    return true;
};
StructureSpawn.prototype.recycleCreepSafe = function (creep) {
    if (this.actionPending) {
        return true;
    }
    if (this.room.spawningCreep) {
        return true;
    }
    creep.say("🗑️", true);
    const response = this.recycleCreep(creep);
    if (response === OK) {
        this.actionPending = true;
        this.room.spawningCreep = true;
    }
    return true;
};
StructureSpawn.prototype.cachedIsActive = function () {
    return HeapStructureSpawnIsActive.get(this);
};

Object.defineProperty(StructureTower.prototype, "isNPC", {
    get() {
        const tower = this;
        if (tower._isNPC === undefined) {
            tower._isNPC =
                tower.owner.username === USERNAME.SOURCE_KEEPER ||
                    tower.owner.username === USERNAME.INVADER ||
                    tower.owner.username === USERNAME.SCREEPS;
        }
        return tower._isNPC;
    },
    enumerable: false,
    configurable: true
});
StructureTower.prototype.cachedIsActive = function () {
    return Cache.remember({
        key: CacheKeys.isActive(this.id),
        expiresIn: 5000,
        updatesIn: 1000,
        value: () => (this.room.mem.type === RoomTypeEnum.STANDART && (this.room.level >= 8 || this.isActive())) ||
            (this.room.mem.type === RoomTypeEnum.SK && !!this.room.invaderCore)
    });
};
StructureTower.prototype.attackPower = function (target) {
    var _a;
    if (!this.cachedIsActive()) {
        return 0;
    }
    if (this.store.energy === 0) {
        return 0;
    }
    let distance = this.pos.getRangeTo(target);
    let damage = TOWER_POWER_ATTACK;
    if (distance > TOWER_OPTIMAL_RANGE) {
        if (distance > TOWER_FALLOFF_RANGE) {
            distance = TOWER_FALLOFF_RANGE;
        }
        damage -= (damage * TOWER_FALLOFF * (distance - TOWER_OPTIMAL_RANGE)) / (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
    }
    (_a = this.effects) === null || _a === void 0 ? void 0 : _a.forEach(effect => {
        if (effect.effect !== PWR_OPERATE_TOWER && effect.effect !== PWR_DISRUPT_TOWER) {
            return;
        }
        damage *= POWER_INFO[effect.effect].effect[effect.level - 1];
    });
    return Math.floor(damage);
};

StructureTerminal.prototype.cachedIsActive = function () {
    return this.room.level >= 6;
};
Object.defineProperty(StructureTerminal.prototype, "isWorthless", {
    get() {
        const storage = this;
        if (storage._isWorthless === undefined) {
            storage._isWorthless = Resources.storeValuableCount(storage.store) === 0;
        }
        return storage._isWorthless;
    },
    enumerable: false,
    configurable: true
});

StructureStorage.prototype.cachedIsActive = function () {
    return Cache.remember({
        key: CacheKeys.isActive(this.id),
        expiresIn: 5000,
        updatesIn: 1000,
        value: () => this.room.level >= 8 || this.isActive()
    });
};
Object.defineProperty(StructureStorage.prototype, "isWorthless", {
    get() {
        const storage = this;
        if (storage._isWorthless === undefined) {
            storage._isWorthless =
                Resources.storeValuableCount(storage.store) < Resources.resourceValues[RESOURCE_ENERGY] * 10000;
        }
        return storage._isWorthless;
    },
    enumerable: false,
    configurable: true
});

class HeapStructureLinkIsActive {
    static get(structure) {
        const fromHeap = this.fromHeap(structure);
        if (fromHeap !== undefined) {
            return fromHeap;
        }
        return this.fromStructure(structure);
    }
    static fromHeap(structure) {
        const heap = this.heap[structure.id];
        if (!heap) {
            return undefined;
        }
        if (heap.updatedAt < Game.time - 1000) {
            return undefined;
        }
        return heap.active;
    }
    static fromStructure(structure) {
        return this.returnAndCache(structure, structure.room.level >= 8 || structure.isActive());
    }
    static returnAndCache(structure, active) {
        this.heap[structure.id] = {
            active,
            updatedAt: Game.time
        };
        return active;
    }
}
HeapStructureLinkIsActive.heap = {};

StructureLink.prototype.cachedIsActive = function () {
    return HeapStructureLinkIsActive.get(this);
};

Object.defineProperty(StructureController.prototype, "signUsername", {
    get() {
        var _a;
        const controller = this;
        try {
            return (_a = controller.sign) === null || _a === void 0 ? void 0 : _a.username;
        }
        catch (e) {
            return "unknown";
        }
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(StructureController.prototype, "signText", {
    get() {
        var _a;
        const controller = this;
        try {
            return (_a = controller.sign) === null || _a === void 0 ? void 0 : _a.text;
        }
        catch (e) {
            return "unknown";
        }
    },
    enumerable: false,
    configurable: true
});

StructureLab.prototype.cachedIsActive = function () {
    return Cache.remember({
        key: CacheKeys.isActive(this.id),
        expiresIn: 5000,
        updatesIn: 1000,
        value: () => this.room.level >= 8 || this.isActive()
    });
};

var Helpers = {
    roomLink(roomName) {
        return `<a href="https://screeps.com/a/#!/room/shard2/${roomName}">${roomName.padEnd(6)}</a>&nbsp;<small>(<a href="https://screeps.com/a/#!/history/shard0/${roomName}?=${Game.time}">${Game.time}</a>)</small>`;
    },
    isDefencePos(pos) {
        const goodCoordinates = [2, 3, 4, 45, 46, 47];
        return goodCoordinates.includes(pos.x) || goodCoordinates.includes(pos.y);
    }
};

const getTerrainWallsCount = function (terrain) {
    let count = 0;
    for (let x = 0; x <= 49; x++) {
        for (let y = 0; y <= 49; y++) {
            if (terrain.get(x, y) === TERRAIN_MASK_WALL)
                count++;
        }
    }
    return count;
};
const roomFinder = function (range) {
    const edgePositions = getEdgePositions();
    const rooms = getSuroundingRoomNames(range);
    const roomList = [];
    rooms.forEach(roomName => {
        const roomStatus = Game.map.getRoomStatus(roomName);
        if (roomStatus.status === "closed")
            return;
        if (isRoomHighway(roomName))
            return;
        if (isRoomSk(roomName))
            return;
        const exits = Object.values(Game.map.describeExits(roomName)).length;
        if (exits > 2)
            return;
        const terrain = Game.map.getRoomTerrain(roomName);
        terrain.get(1, 1);
        roomList.push({
            name: roomName,
            exits: Object.values(Game.map.describeExits(roomName)).length,
            exitTiles: edgePositions.filter(pos => terrain.get(pos.x, pos.y) === 0).length,
            terrainWalls: getTerrainWallsCount(terrain)
        });
    });
    roomList
        .sort((a, b) => {
        if (a.exitTiles > b.exitTiles)
            return 1;
        if (a.exitTiles < b.exitTiles)
            return -1;
        return 0;
    })
        .forEach(roomObj => {
        console.log(`${Helpers.roomLink(_.pad(roomObj.name, 6))} - exits: ${_.pad(String(roomObj.exits), 3)}, exitTiles: ${_.pad(String(roomObj.exitTiles), 3)}, walls: ${_.pad(String(roomObj.terrainWalls), 5)}`);
    });
};
function isRoomHighway(roomName) {
    const parsed = /^[WE]([0-9]+)[NS]([0-9]+)$/.exec(roomName);
    return parsed[1] % 10 === 0 || parsed[2] % 10 === 0;
}
function isRoomSk(roomName) {
    const parsed = /^[WE]([0-9]+)[NS]([0-9]+)$/.exec(roomName);
    const fMod = parsed[1] % 10;
    const sMod = parsed[2] % 10;
    return !(fMod === 5 && sMod === 5) && fMod >= 4 && fMod <= 6 && sMod >= 4 && sMod <= 6;
}
function getEdgePositions() {
    const EDGE_POS = [];
    for (let x = 0; x < 49; x++) {
        for (let y = 0; y <= 49; y = y + 49) {
            EDGE_POS.push({ x, y });
        }
    }
    for (let y = 0; y < 49; y++) {
        for (let x = 0; x <= 49; x = x + 49) {
            EDGE_POS.push({ x, y });
        }
    }
    return EDGE_POS;
}
function getSuroundingRoomNames(range) {
    const rooms = [];
    Rooms.myRooms.forEach(r => {
        var _a, _b, _c, _d;
        const regex = new RegExp("(?<lon>[EW])(?<x>[1-9]{1,2})(?<lat>[NS])(?<y>[1-9]{1,2})");
        const centerRoom = regex.exec(r.name);
        const lon = (_a = centerRoom === null || centerRoom === void 0 ? void 0 : centerRoom.groups) === null || _a === void 0 ? void 0 : _a.lon;
        const lat = (_b = centerRoom === null || centerRoom === void 0 ? void 0 : centerRoom.groups) === null || _b === void 0 ? void 0 : _b.lat;
        const x = (_c = centerRoom === null || centerRoom === void 0 ? void 0 : centerRoom.groups) === null || _c === void 0 ? void 0 : _c.x;
        const y = (_d = centerRoom === null || centerRoom === void 0 ? void 0 : centerRoom.groups) === null || _d === void 0 ? void 0 : _d.y;
        const pushRoom = function (name) {
            if (rooms.indexOf(name) === -1) {
                rooms.push(name);
            }
        };
        if (!lon || !lat || !x || !y)
            return;
        for (let xOffset = -range; xOffset < range; xOffset++) {
            for (let yOffset = -range; yOffset < range; yOffset++) {
                pushRoom(lon + (parseInt(x, 10) - xOffset).toString() + lat + (parseInt(y, 10) - yOffset).toString());
            }
        }
    });
    return rooms.filter((value, index, self) => self.indexOf(value) === index);
}
global.RoomFinder = roomFinder;
global.BoostRoomFinder = function (range) {
    const rooms = getSuroundingRoomNames(range);
    rooms.forEach(roomName => {
        const exits = Game.map.describeExits(roomName);
        if (!exits) {
            return;
        }
        const exitRoomNames = Object.values(exits);
        if (exitRoomNames.length !== 1) {
            return;
        }
        const supportRoomName = exitRoomNames[0];
        if (!supportRoomName) {
            return;
        }
        const memory = Rooms.memory(supportRoomName);
        if (!memory) {
            return;
        }
        if (memory.type !== RoomTypeEnum.STANDART) {
            return;
        }
        if (memory.sourceCount !== 2) {
            return;
        }
        Log.room(roomName, "Boost room with 1 exit");
    });
};

class Minerals {
    static get mineralConstants() {
        return RESOURCE_MINERALS;
    }
    static calculateMineralAmount(res) {
        let value = 0;
        const reactions = REACTIONS[res];
        if (!reactions) {
            return value;
        }
        Object.values(reactions).forEach(result => {
            var _a;
            value += (_a = REACTION_TIME[result]) !== null && _a !== void 0 ? _a : 0;
            value += this.calculateMineralAmount(result);
        });
        return value;
    }
    static idealMineralRatios() {
        return this.mineralConstants.reduce((t, mineral) => {
            t[mineral] = this.calculateMineralAmount(mineral);
            return t;
        }, {});
        // RESOURCE_MINERALS.forEach(mineral => console.log(mineral, this.calculateMineralAmount(mineral)));
        // const mineralsPerMinute = this.mineralConstants.reduce((t, mineral) => {
        //   t[mineral] = this.requiredBoostPerMinute(mineral, except);
        //
        //   return t;
        // }, {} as Record<MineralConstant, number>);
        //
        // const total = Object.values(mineralsPerMinute).reduce((t, amount) => t + amount, 0);
        //
        // const mineralsPercent = mineralsPerMinute;
        //
        // for (const mineral in mineralsPercent) {
        //   mineralsPercent[mineral as MineralConstant] = mineralsPerMinute[mineral as MineralConstant] / total;
        // }
        //
        // return mineralsPercent;
    }
    static requiredBoostPerMinute(resource, except = []) {
        let value = 0;
        for (const reactionResult in BOOST_REACTIONS) {
            if (except.includes(reactionResult)) {
                continue;
            }
            const reactionInputs = BOOST_REACTIONS[reactionResult];
            if (!reactionInputs) {
                continue;
            }
            reactionInputs.forEach(reactionInput => {
                if (reactionInput !== resource) {
                    return;
                }
                const reactionTime = REACTION_TIME[reactionResult];
                if (!reactionTime) {
                    return;
                }
                value += reactionTime;
                value += this.requiredBoostPerMinute(reactionResult);
            });
        }
        return value;
    }
}

const resources = {
    [RESOURCE_ENERGY]: {
        color: "#fff",
        text: ""
    },
    [RESOURCE_POWER]: {
        color: "#fff",
        text: ""
    },
    [RESOURCE_OPS]: {
        color: "#fff",
        text: ""
    },
    [RESOURCE_HYDROGEN]: {
        color: "#fff",
        text: ""
    },
    [RESOURCE_OXYGEN]: {
        color: "#fff",
        text: ""
    },
    [RESOURCE_UTRIUM]: {
        color: "#fff",
        text: ""
    },
    [RESOURCE_KEANIUM]: {
        color: "#fff",
        text: ""
    },
    [RESOURCE_LEMERGIUM]: {
        color: "#fff",
        text: ""
    },
    [RESOURCE_HYDROXIDE]: {
        color: "#fff",
        text: ""
    },
    [RESOURCE_ZYNTHIUM]: {
        color: "#fff",
        text: ""
    },
    [RESOURCE_CATALYST]: {
        color: "#fff",
        text: ""
    },
    [RESOURCE_ZYNTHIUM_KEANITE]: {
        color: "#fff",
        text: ""
    },
    [RESOURCE_UTRIUM_LEMERGITE]: {
        color: "#fff",
        text: ""
    },
    [RESOURCE_GHODIUM]: {
        color: "#fff",
        text: ""
    },
    [RESOURCE_UTRIUM_HYDRIDE]: {
        color: "#f93842",
        text: "+100% attack effectiveness"
    },
    [RESOURCE_UTRIUM_OXIDE]: {
        color: "#ffe56d",
        text: "+200% harvest effectiveness"
    },
    [RESOURCE_KEANIUM_HYDRIDE]: {
        color: "#777",
        text: "+50 capacity"
    },
    [RESOURCE_KEANIUM_OXIDE]: {
        color: "#5d80b2",
        text: "+100% rangedAttack and rangedMassAttack effectiveness"
    },
    [RESOURCE_LEMERGIUM_HYDRIDE]: {
        color: "#ffe56d",
        text: "+50% repair and build effectiveness without increasing the energy cost"
    },
    [RESOURCE_LEMERGIUM_OXIDE]: {
        color: "#65fd62",
        text: "+100% heal and rangedHeal effectiveness"
    },
    [RESOURCE_ZYNTHIUM_HYDRIDE]: {
        color: "#ffe56d",
        text: "+100% dismantle effectiveness"
    },
    [RESOURCE_ZYNTHIUM_OXIDE]: {
        color: "#a9b7c6",
        text: "+100% fatigue decrease speed"
    },
    [RESOURCE_GHODIUM_HYDRIDE]: {
        color: "#ffe56d",
        text: "+50% upgradeController effectiveness without increasing the energy cost"
    },
    [RESOURCE_GHODIUM_OXIDE]: {
        color: "#fff",
        text: "-30% damage taken"
    },
    [RESOURCE_UTRIUM_ACID]: {
        color: "#f93842",
        text: "+200% attack effectiveness"
    },
    [RESOURCE_UTRIUM_ALKALIDE]: {
        color: "#ffe56d",
        text: "+400% harvest effectiveness"
    },
    [RESOURCE_KEANIUM_ACID]: {
        color: "#777",
        text: "+100 capacity"
    },
    [RESOURCE_KEANIUM_ALKALIDE]: {
        color: "#5d80b2",
        text: "+200% rangedAttack and rangedMassAttack effectiveness"
    },
    [RESOURCE_LEMERGIUM_ACID]: {
        color: "#ffe56d",
        text: "+80% repair and build effectiveness without increasing the energy cost"
    },
    [RESOURCE_LEMERGIUM_ALKALIDE]: {
        color: "#65fd62",
        text: "+200% heal and rangedHeal effectiveness"
    },
    [RESOURCE_ZYNTHIUM_ACID]: {
        color: "#ffe56d",
        text: "+200% dismantle effectiveness"
    },
    [RESOURCE_ZYNTHIUM_ALKALIDE]: {
        color: "#a9b7c6",
        text: "+200% fatigue decrease speed"
    },
    [RESOURCE_GHODIUM_ACID]: {
        color: "#ffe56d",
        text: "+80% upgradeController effectiveness without increasing the energy cost"
    },
    [RESOURCE_GHODIUM_ALKALIDE]: {
        color: "#fff",
        text: "-50% damage taken"
    },
    [RESOURCE_CATALYZED_UTRIUM_ACID]: {
        color: "#f93842",
        text: "+300% attack effectiveness"
    },
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: {
        color: "#ffe56d",
        text: "+600% harvest effectiveness"
    },
    [RESOURCE_CATALYZED_KEANIUM_ACID]: {
        color: "#777",
        text: "+150 capacity"
    },
    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: {
        color: "#5d80b2",
        text: "+300% rangedAttack and rangedMassAttack effectiveness"
    },
    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: {
        color: "#ffe56d",
        text: "+100% repair and build effectiveness without increasing the energy cost"
    },
    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: {
        color: "#65fd62",
        text: "+300% heal and rangedHeal effectiveness"
    },
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: {
        color: "#ffe56d",
        text: "+300% dismantle effectiveness"
    },
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: {
        color: "#a9b7c6",
        text: "+300% fatigue decrease speed"
    },
    [RESOURCE_CATALYZED_GHODIUM_ACID]: {
        color: "#ffe56d",
        text: "+100% upgradeController effectiveness without increasing the energy cost"
    },
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: {
        color: "#fff",
        text: "-70% damage taken"
    }
};
const printStore = function () {
    const rooms = Object.values(Game.rooms).filter(r => r.my);
    for (const resource in resources) {
        const total = rooms.reduce((t, r) => t + r.store[resource], 0);
        const totalFormatted = total.toLocaleString().padEnd(9, " ");
        const average = Math.floor(total / rooms.length);
        const averageFormatted = average.toLocaleString().padEnd(9, " ");
        const resourceFormatted = resource.padEnd(9, " ");
        console.log(`${totalFormatted} | ${averageFormatted} | ${resourceFormatted} | <span style="color: ${resources[resource].color};">${resources[resource].text}</span>`);
    }
};
global.printResources = printStore;
const printRoomMinerals = function () {
    const homeRooms = {};
    let homeRoomsCount = 0;
    const skRooms = {};
    // let skRoomsCount = 0;
    General.myRooms.forEach(room => {
        room.find(FIND_MINERALS).forEach(mineral => {
            homeRooms[mineral.mineralType] = (homeRooms[mineral.mineralType] || 0) + 1;
            homeRoomsCount++;
        });
        // room.skRoom?.room?.find(FIND_MINERALS).forEach(mineral => {
        //   skRooms[mineral.mineralType] = (skRooms[mineral.mineralType] || 0) + 1;
        //   skRoomsCount++;
        // });
    });
    const idealRatios = Minerals.idealMineralRatios();
    for (const mineralConstant in idealRatios) {
        console.log(mineralConstant, String(homeRooms[mineralConstant]).padEnd(3), "-", (homeRoomsCount * idealRatios[mineralConstant]).toFixed(2), "|", String(homeRooms[mineralConstant] + skRooms[mineralConstant]).padEnd(3), "-", ((homeRoomsCount + skRooms[mineralConstant]) * idealRatios[mineralConstant]).toFixed(2));
    }
    // console.log(JSON.stringify(homeRooms, null, 2));
    // console.log(JSON.stringify(skRooms, null, 2));
    //
    // console.log(JSON.stringify(Minerals.idealMineralRatios(), null, 2));
    return;
};
global.printRoomMinerals = printRoomMinerals;

class AbstractSpawner {
    constructor(role) {
        this.role = role;
    }
    handle() {
        this.work();
    }
    getCreeps(ttl = 0) {
        return Creeps.getByRole(this.role).filter(creep => creep.spawning || (creep.ticksToLive && creep.ticksToLive > ttl));
    }
    getCreepsCount(ttl, memory, role = this.role) {
        const creepsCount = Creeps.getByRole(this.role)
            .filter(creep => {
            for (const memoryKey in memory) {
                if (creep.memory[memoryKey] !== memory[memoryKey]) {
                    return false;
                }
            }
            return true;
        })
            .filter(creep => creep.spawning || (creep.ticksToLive && creep.ticksToLive > ttl)).length;
        const queueCount = Memory.spawnQue
            ? Memory.spawnQue.filter(que => {
                var _a;
                if (((_a = que.memory) === null || _a === void 0 ? void 0 : _a.role) !== role) {
                    return false;
                }
                for (const memoryKey in memory) {
                    if (!que.memory || que.memory[memoryKey] !== memory[memoryKey]) {
                        return false;
                    }
                }
                return true;
            }).length
            : 0;
        return creepsCount + queueCount;
    }
}

const WarManualConfig = {
    role: {
        warManualDuo: {
            name: "warManualDuo",
            attackerName: "warManualDuoAttacker",
            healerName: "warManualDuoHealer",
            priority: 2 /* High */
        },
        warManualAttacker: {
            name: "warManualAttacker",
            priority: 2 /* High */
        },
        warManualRangedAttacker: {
            name: "warManualRangedAttacker",
            priority: 2 /* High */
        },
        warManualTowerDrainer: {
            name: "warManualTowerDrainer",
            priority: 2 /* High */
        }
    }
};

class WarManualTowerDrainerSpawner extends AbstractSpawner {
    work() {
        Object.values(Game.flags)
            .filter(flag => flag.color === COLOR_BROWN && flag.secondaryColor === COLOR_WHITE)
            .forEach(flag => {
            const targetRoomName = flag.pos.roomName;
            const targetRoomMemory = Rooms.memory(targetRoomName);
            const creepsCount = this.getCreepsCount(700, { targetFlag: flag.name });
            if (creepsCount >= 1) {
                return;
            }
            const spawnRoom = Geo.closestHomeRoomByRange(targetRoomName, {
                minLevel: 8,
                maxDistance: MAX_EXPANSION_RANGE * 2
                // storage: storage =>
                //   storage.store[RESOURCE_LEMERGIUM_ALKALIDE] > 600 && storage.store[RESOURCE_CATALYZED_GHODIUM_ALKALIDE] > 500
                // storage.store[RESOURCE_ZYNTHIUM_ALKALIDE] > 500
            });
            if (!spawnRoom) {
                return;
            }
            Spawns.addToQue(spawnRoom, Object.assign(Object.assign({}, ((targetRoomMemory.controllerLevel || 8) === 8 ? this.TowerTanker6() : this.TowerTanker3())), { 
                // body: new BodyParts().add(TOUGH, 5).add(RANGED_ATTACK, 2).add(MOVE, 13).add(HEAL, 30).get(),
                priority: WarManualConfig.role.warManualTowerDrainer.priority, 
                // boosts: [
                //   RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
                //   RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
                //   RESOURCE_KEANIUM_ALKALIDE,
                //   RESOURCE_ZYNTHIUM_ALKALIDE
                // ],
                role: this.role, memory: {
                    targetRoom: targetRoomName,
                    targetFlag: flag.name
                } }));
        });
    }
    actualDrainer() {
        return {
            body: new BodyParts().rangedAttack().add(MOVE, 25).add(HEAL, 24).get(),
            boosts: [
                BOOST_ALIAS.HEAL_1
                // RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
                // RESOURCE_LEMERGIUM_OXIDE,
                // RESOURCE_CATALYZED_KEANIUM_ALKALIDE
                // RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE
                // RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
                // RESOURCE_ZYNTHIUM_ALKALIDE
            ]
        };
    }
    t2() {
        return {
            body: new BodyParts().add(TOUGH, 4).rangedAttack().add(MOVE, 25).add(HEAL, 20).get(),
            boosts: [
                RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
                RESOURCE_LEMERGIUM_OXIDE,
                RESOURCE_CATALYZED_KEANIUM_ALKALIDE
                // RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE
                // RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
                // RESOURCE_ZYNTHIUM_ALKALIDE
            ]
        };
    }
    TowerTanker3() {
        return {
            body: new BodyParts().add(TOUGH, 6).add(RANGED_ATTACK, 6).add(MOVE, 25).add(HEAL, 13).get(),
            boosts: [
                RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
                RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
                RESOURCE_CATALYZED_KEANIUM_ALKALIDE
            ]
        };
    }
    Healer() {
        return {
            body: new BodyParts().add(MOVE, 10).add(HEAL, 40).get(),
            boosts: [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE, RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]
        };
    }
    TowerTanker6() {
        return {
            body: new BodyParts().add(TOUGH, 11).add(RANGED_ATTACK, 4).add(MOVE, 10).add(HEAL, 25).get(),
            boosts: [
                RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
                RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
                RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
                RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE
            ]
        };
    }
}

class AbstractWorker {
    constructor(role, creep) {
        this.role = role;
        this.creep = creep;
    }
    handle() {
        this.work();
    }
}

class WarManualTowerDrainerWorker extends AbstractWorker {
    work() {
        var _a, _b;
        this.creep.notifyWhenAttacked(false);
        this.creep.memory.stationary = true;
        if (this.creep.targetFlag &&
            (this.creep.targetFlag.roomMem.safeModeEndsAt || ((_b = (_a = this.creep.targetFlag.room) === null || _a === void 0 ? void 0 : _a.controller) === null || _b === void 0 ? void 0 : _b.safeMode))) {
            this.creep.recycleFinal(1500);
            return;
        }
        if (this.creep.boost({ minTicksToLive: 1000 })) {
            return;
        }
        this.heal();
        this.attack();
        this.move();
    }
    heal() {
        this.healMele() ||
            // this.healRanged() ||
            this.selfHeal();
    }
    healRanged() {
        const woundedInRange = this.creep.pos
            .findInRange(FIND_MY_CREEPS, 3)
            .filter(c => c.hitsMax !== c.hits)
            .sort((a, b) => a.hits - b.hits)[0];
        if (!woundedInRange)
            return false;
        this.creep.rangedHeal(woundedInRange);
        return true;
    }
    healMele() {
        const woundedMele = this.creep.pos
            .findInRange(FIND_MY_CREEPS, 1)
            .filter(c => c.hitsMax !== c.hits)
            .sort((a, b) => a.hits - b.hits)[0];
        if (!woundedMele)
            return false;
        this.creep.heal(woundedMele);
        return true;
    }
    move() {
        this.moveToClaimer() ||
            this.kiteBoostedAttacker() ||
            this.moveToFlagRoom() ||
            this.kiteBack() ||
            // this.moveToHostileCreeps() ||
            this.moveToFlag(); // || this.moveToHostiles();
    }
    moveToClaimer() {
        if (!this.creep.targetFlag) {
            return false;
        }
        if (this.creep.targetFlag.pos.roomName !== this.creep.room.name) {
            return false;
        }
        const claimer = this.creep.pos
            .findInRange(FIND_MY_CREEPS, 3, {
            filter: c => c.body.filter(b => b.type === CLAIM).length > 0 && !c.pos.isRoomEdge
        })
            .sort((a, b) => a.pos.getRangeTo(this.creep) - b.pos.getRangeTo(this.creep))[0];
        if (!claimer) {
            return false;
        }
        const distance = this.creep.pos.getRangeTo(claimer);
        if (distance > 1) {
            this.creep.travel(claimer);
        }
        else {
            this.creep.moveTo(claimer);
        }
        return true;
    }
    moveToHostileCreeps() {
        const hostileCreep = this.creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS, { filter: c => !c.pos.rampart });
        if (!hostileCreep) {
            return false;
        }
        this.creep.travel(hostileCreep);
        return true;
    }
    kiteBoostedAttacker() {
        var _a;
        if (this.creep.room.name !== ((_a = this.creep.targetFlag) === null || _a === void 0 ? void 0 : _a.pos.roomName)) {
            return false;
        }
        const attackersRange3 = this.creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3, { filter: c => c.attackPower > 1200 });
        const attackersRange2 = attackersRange3.filter(c => this.creep.pos.getRangeTo(c) <= 2);
        if (attackersRange3.length === 0) {
            return false;
        }
        if (attackersRange2.length > 0) {
            const ret = PathFinder.search(this.creep.pos, attackersRange3.map(c => ({ pos: c.pos, range: 3 })), {
                flee: true,
                maxRooms: 2,
                roomCallback: (roomName) => {
                    const matrix = new PathFinder.CostMatrix();
                    const room = Game.rooms[roomName];
                    if (!room) {
                        return matrix;
                    }
                    room.find(FIND_STRUCTURES).filter(structure => {
                        if (structure.structureType === STRUCTURE_PORTAL) {
                            matrix.set(structure.pos.x, structure.pos.y, 255);
                        }
                        if (OBSTACLE_OBJECT_TYPES.includes(structure.structureType)) {
                            matrix.set(structure.pos.x, structure.pos.y, 255);
                        }
                        if (structure.structureType === STRUCTURE_RAMPART && !structure.my) {
                            matrix.set(structure.pos.x, structure.pos.y, 255);
                        }
                    });
                    room.find(FIND_CREEPS).filter(creep => {
                        if (creep.id === this.creep.id) {
                            return;
                        }
                        matrix.set(creep.pos.x, creep.pos.y, 255);
                    });
                    return matrix;
                }
            });
            this.creep.moveByPath(ret.path);
        }
        return true;
    }
    kiteBack() {
        if (this.creep.hits / this.creep.hitsMax > 0.9)
            return false;
        if (!this.creep.homeRoom)
            return false;
        this.creep.travelToRoom(this.creep.homeRoom.name);
        return true;
    }
    attack() {
        // this.creep.rangedBestAttack(false) || this.attackRoads();
        // this.attackNewDefences() || this.attackRoads() || this.creep.rangedBestAttack() || this.attackContainers();
        this.attackNewDefences() || this.creep.rangedBestAttack() || this.attackRoads() || this.attackContainers();
    }
    attackNewDefences() {
        const newDefence = this.creep.pos.findInRange(FIND_STRUCTURES, 3, {
            filter: s => (s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_WALL) && s.hits === 1
        })[0];
        if (!newDefence) {
            return false;
        }
        this.creep.rangedAttack(newDefence);
        return true;
    }
    attackContainers() {
        if (!this.creep.room.controller)
            return false;
        if (!this.creep.room.controller.owner)
            return false;
        if (this.creep.room.controller.my)
            return false;
        const container = this.creep.pos.findInRange(FIND_STRUCTURES, 3, {
            filter: s => s.structureType === STRUCTURE_CONTAINER
        })[0];
        if (!container)
            return false;
        this.creep.rangedAttack(container);
        return true;
    }
    attackRoads() {
        if (!this.creep.targetFlag)
            return false;
        if (this.creep.targetFlag.pos.roomName !== this.creep.room.name)
            return false;
        if (this.creep.room.my)
            return false;
        const road = this.creep.pos.findInRange(FIND_STRUCTURES, 3, {
            filter: s => s.structureType === STRUCTURE_ROAD && !s.pos.rampart
        })[0];
        if (!road) {
            return false;
        }
        this.creep.rangedAttack(road);
        return true;
    }
    attackRangedMassWhenEfficient() {
        const structureDamage = this.creep.pos
            .findInRange(FIND_HOSTILE_STRUCTURES, 3)
            .reduce((total, structure) => total + (MASS_RANGED_ATTACK_DECAY[structure.pos.getRangeTo(this.creep)] || 0), 0);
        const creepDamage = this.creep.pos
            .findInRange(FIND_HOSTILE_CREEPS, 3)
            .reduce((total, hostile) => total + (MASS_RANGED_ATTACK_DECAY[hostile.pos.getRangeTo(this.creep)] || 0), 0);
        if (structureDamage + creepDamage < 1)
            return false;
        this.creep.rangedMassAttack();
        return true;
    }
    attackSingleHostile() {
        const hostile = this.creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3)[0];
        if (!hostile)
            return false;
        if (hostile.isUnderRampart)
            return false;
        this.creep.rangedAttack(hostile);
        return true;
    }
    selfHeal() {
        if (this.creep.hits === this.creep.hitsMax &&
            this.creep.room.find(FIND_HOSTILE_CREEPS).length === 0 &&
            this.creep.room.find(FIND_HOSTILE_STRUCTURES, { filter: s => s.structureType === STRUCTURE_TOWER }).length === 0) {
            return false;
        }
        this.creep.heal(this.creep);
        return true;
    }
    moveToFlagRoom() {
        if (!this.creep.targetFlag) {
            return false;
        }
        if (this.creep.targetFlag.pos.isEqualTo(this.creep.pos)) {
            return false;
        }
        return this.creep.travelToRoom(this.creep.targetFlag.pos.roomName);
        // return this.creep.travelV2(this.creep.targetFlag, { range: 0 });
    }
    moveToFlag() {
        if (!this.creep.targetFlag)
            return false;
        return this.creep.travel(this.creep.targetFlag, {
            range: this.creep.targetFlag.room && this.creep.targetFlag.pos.lookFor(LOOK_CREEPS).length > 0 ? 1 : 0
        });
        // return this.creep.travelV2(this.creep.targetFlag, { range: 0 });
    }
}

class WarManualTowerDrainer {
    handle() {
        this.handleSpawn();
        this.handleCreeps();
    }
    handleSpawn() {
        General.interval(60, () => TickAction.add(() => new WarManualTowerDrainerSpawner(WarManualConfig.role.warManualTowerDrainer.name).handle()));
    }
    handleCreeps() {
        Creeps.getByRole(WarManualConfig.role.warManualTowerDrainer.name)
            .filter(c => !c.spawning)
            .forEach(creep => {
            General.visualCreepCpu(creep, () => new WarManualTowerDrainerWorker(WarManualConfig.role.warManualTowerDrainer.name, creep).handle());
        });
    }
}

const modules$2 = [WarManualTowerDrainer];
class WarManual {
    handle() {
        this.handleSubModules();
    }
    handleSubModules() {
        modules$2.forEach(module => {
            try {
                new module().handle();
            }
            catch (e) {
                console.log(module.name, e);
            }
        });
    }
}

const WarDowngradeConfig = {
    maxRange: 12,
    role: {
        warDowngradeController: {
            name: "warDowngradeController",
            priority: 3 /* Medium */
        },
        warDowngradeDefender: {
            name: "warDowngradeDefender",
            priority: 3 /* Medium */
        },
        warDowngradeHauler: {
            name: "warDowngradeHauler",
            priority: 4 /* Low */,
            pickableResources: [
                RESOURCE_POWER,
                RESOURCE_CATALYZED_UTRIUM_ACID,
                RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
                RESOURCE_CATALYZED_KEANIUM_ACID,
                RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
                RESOURCE_CATALYZED_LEMERGIUM_ACID,
                RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
                RESOURCE_CATALYZED_ZYNTHIUM_ACID,
                RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
                RESOURCE_CATALYZED_GHODIUM_ACID,
                RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
                RESOURCE_COMPOSITE,
                RESOURCE_CRYSTAL,
                RESOURCE_LIQUID,
                RESOURCE_WIRE,
                RESOURCE_SWITCH,
                RESOURCE_TRANSISTOR,
                RESOURCE_MICROCHIP,
                RESOURCE_CIRCUIT,
                RESOURCE_DEVICE,
                RESOURCE_CELL,
                RESOURCE_PHLEGM,
                RESOURCE_TISSUE,
                RESOURCE_MUSCLE,
                RESOURCE_ORGANOID,
                RESOURCE_ORGANISM,
                RESOURCE_ALLOY,
                RESOURCE_TUBE,
                RESOURCE_FIXTURES,
                RESOURCE_FRAME,
                RESOURCE_HYDRAULICS,
                RESOURCE_MACHINE,
                RESOURCE_CONDENSATE,
                RESOURCE_CONCENTRATE,
                RESOURCE_EXTRACT,
                RESOURCE_SPIRIT,
                RESOURCE_EMANATION,
                RESOURCE_ESSENCE,
                RESOURCE_BIOMASS,
                RESOURCE_GHODIUM_OXIDE,
                RESOURCE_GHODIUM_ALKALIDE,
                RESOURCE_GHODIUM_ACID,
                RESOURCE_GHODIUM_HYDRIDE,
                RESOURCE_GHODIUM
                // RESOURCE_ENERGY
            ]
        },
        warDowngradeDismantler: {
            name: "warDowngradeDismantler",
            priority: 4 /* Low */
        },
        warEverythingDowngradeDismantler: {
            name: "warEverythingDowngradeDismantler",
            priority: 6 /* Lowest */
        }
    }
};

const BODY = BodyParts.new().claim(15).move(25).heal();
const MAX_CREEPS = 1;
class WarDowngradeControllerSpawner extends AbstractSpawner {
    work() {
        this.spawnForFlags();
    }
    //
    // private spawnForTowerless(): void {
    //   Object.keys(Misc.rooms).forEach(roomName => {
    //     const roomModel = new RoomModel(roomName);
    //     if (roomModel.isMine) return;
    //     if (roomModel.isInSafeMode) return;
    //     if (roomModel.towerCount > 0) return;
    //     if (!roomModel.ownerUsername) return;
    //
    //     const status = Game.map.getRoomStatus(roomName).status;
    //     if (status === "closed" || status === "respawn") return;
    //
    //     const creepsCount = this.getCreepsCount(700, { targetRoom: roomName });
    //     if (creepsCount >= 1) return;
    //
    //     const spawnRooms = closestHomeRoomsByRange(roomName, 2, {
    //       minLevel: 8,
    //       maxDistance: WarDowngradeConfig.maxRange,
    //       storage: storage => storage.store.energy > 50_000
    //     });
    //     if (spawnRooms.length === 0) return;
    //
    //     queSpawnCreep(
    //       spawnRooms.map(r => r.name),
    //       {
    //         body: new BodyParts()
    //           // .add(TOUGH, 6)
    //           .add(CLAIM, 19)
    //           // .add(MOVE, 25)
    //           .add(MOVE, 19)
    //           .get(),
    //         priority: WarDowngradeConfig.role.warDowngradeController.priority,
    //         role: this.role,
    //         Misc: {
    //           targetRoom: roomName
    //         }
    //       }
    //     );
    //   });
    // }
    spawnForFlags() {
        const que = Creeps.queByRole(this.role);
        const creeps = Creeps.getByRole(this.role);
        Flags.flags(FlagType.controllerAttacker).forEach(flag => {
            const roomModel = RoomModel.get(flag.pos.roomName);
            if (roomModel.isInSafeMode) {
                return;
            }
            if (!flag.room) {
                return;
            }
            if (flag.room.my) {
                return;
            }
            if (flag.pos.openSpots.length === 0) {
                return;
            }
            if (!flag.room.controller) {
                return;
            }
            // if (flag.room.controller.safeModeAvailable <= 0) return;
            if (flag.room.controller.upgradeBlocked > CREEP_CLAIM_LIFE_TIME) {
                return;
            }
            const spawnRoom = Geo.closestHomeRoomByRange(flag.room.name, {
                minLevel: 8,
                maxDistance: MAX_EXPANSION_RANGE,
                storage: storage => storage.store.energy > 30000
                // room: r => {
                //   return (flag.room?.controller?.upgradeBlocked || 0) < CREEP_CLAIM_LIFE_TIME + this.roomSpawnTime(r);
                // }
            });
            if (!spawnRoom) {
                return;
            }
            const distance = this.getDistanceToTargetController(spawnRoom, flag.room);
            if (distance >= CREEP_CLAIM_LIFE_TIME) {
                console.log("controller attacker", "target room distance too big", distance, spawnRoom.name, flag.pos.roomName);
                return;
            }
            const spawnTime = this.roomSpawnTime(spawnRoom);
            const expectedCreeps = Math.min(MAX_CREEPS, flag.room.controller.upgradeBlocked && flag.room.controller.upgradeBlocked > 450 // && Game.map.getRoomLinearDistance(spawnRoom.name, flag.pos.roomName) < 5
                ? flag.pos.openSpots.length
                : 1);
            const creepsCount = que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === flag.pos.roomName; }).length +
                creeps.filter(c => c.memory.targetRoom === flag.pos.roomName).length;
            if (creepsCount >= expectedCreeps) {
                return;
            }
            console.log("downgrader", flag.pos.roomName, spawnTime, expectedCreeps, distance);
            for (let i = creepsCount; i < expectedCreeps; i++) {
                Spawns.addToQue(spawnRoom, {
                    // body: new BodyParts()
                    //   // .add(TOUGH, 6)
                    //   .add(CLAIM, 15)
                    //   // .add(MOVE, 25)
                    //   .add(MOVE, 15)
                    //   .get(),
                    body: BODY,
                    boosts: [BOOST_ALIAS.TOUGH_3],
                    priority: WarDowngradeConfig.role.warDowngradeController.priority,
                    role: this.role,
                    memory: {
                        targetRoom: flag.pos.roomName,
                        targetFlag: flag.name,
                        homeRoom: spawnRoom.name
                    },
                    maxQueTime: flag.room.controller.upgradeBlocked && flag.room.controller.upgradeBlocked > distance + spawnTime
                        ? flag.room.controller.upgradeBlocked - distance - spawnTime
                        : 300
                });
            }
            spawnRoom.mem.increasedSpawnUntil = Game.time + 1500;
        });
    }
    getDistanceToTargetController(fromRoom, toRoom) {
        if (!toRoom.controller) {
            console.log("controller attacker", "target room has no controller");
            return Infinity;
        }
        if (!fromRoom.mySpawns[0]) {
            console.log("controller attacker", "home room has no spawns");
            return Infinity;
        }
        const route = Geo.findRouteCached(fromRoom.name, toRoom.name);
        const ret = PathFinder.search(fromRoom.mySpawns[0].pos, { pos: toRoom.controller.pos, range: 1 }, {
            maxRooms: 64,
            maxOps: 10000,
            roomCallback(roomName) {
                if (!route.includes(roomName)) {
                    return false;
                }
                return Rooms.matrix(roomName);
            }
        });
        if (ret.incomplete) {
            console.log("controller attacker", "cannot find path to target controller", fromRoom.name, toRoom.name);
            return Infinity;
        }
        return ret.path.length;
    }
    roomSpawnTime(room) {
        const spawnTicks = BODY.length() * CREEP_SPAWN_TIME;
        const spawnMultiplier = room.find(FIND_MY_SPAWNS).reduce((lowest, s) => {
            var _a;
            const effect = (_a = s.effects) === null || _a === void 0 ? void 0 : _a.find(e => e.effect === PWR_OPERATE_SPAWN);
            if (!effect) {
                return lowest;
            }
            const multiplier = POWER_INFO[PWR_OPERATE_SPAWN].effect[effect.level];
            return multiplier < lowest ? multiplier : lowest;
        }, 1);
        return spawnTicks * spawnMultiplier;
    }
}

class WarDowngradeControllerWorker extends AbstractWorker {
    work() {
        Game.map.visual.text(String(this.creep.ticksToLive), this.creep.pos);
        this.attack() || this.creep.healMele() || this.creep.prehealMele();
        this.move();
    }
    move() {
        // this.kiteBack() ||
        if (this.creep.memory.action === "wait") {
            return;
        }
        const healer = this.creep.pos
            .findInRange(FIND_MY_CREEPS, 1, { filter: c => c.healPower > 0 })
            .sort((a, b) => b.healPower - a.healPower)[0];
        if (healer && healer.fatigue > 0) {
            return;
        }
        this.creep.boost({ minTicksToLive: 500 }) ||
            // this.kite() ||
            this.moveToHeal() ||
            this.moveToFlagRoom() ||
            this.moveToController() ||
            // this.moveToControllerMax() ||
            this.moveToFlag();
        // this.moveToFlagMax();
    }
    moveToControllerMax() {
        if (!this.creep.targetFlag)
            return false;
        if (!this.creep.targetFlag.room)
            return false;
        if (!this.creep.targetFlag.room.controller)
            return false;
        if (!this.creep.targetFlag.room.controller.owner)
            return false;
        const path = PathFinder.search(this.creep.pos, this.creep.targetFlag.room.controller.pos, {
            maxRooms: 64,
            maxOps: 20000,
            roomCallback(roomName) {
                const matrix = new PathFinder.CostMatrix();
                const obstacles = Cache.get(CacheKeys.roomObstacles(roomName));
                if (obstacles) {
                    obstacles.forEach(o => {
                        matrix.set(o.x, o.y, 255);
                    });
                }
                return matrix;
            }
        });
        this.creep.moveByPath(path.path);
        return true;
    }
    kite() {
        const hostiles = this.creep.pos.findInRange(FIND_HOSTILE_CREEPS, 6).filter(c => c.rangedAttackPower);
        if (hostiles.length === 0)
            return false;
        const path = PathFinder.search(this.creep.pos, hostiles.map(c => ({
            pos: c.pos,
            range: 8
        })), {
            flee: true,
            roomCallback: (roomName) => {
                if (roomName !== this.creep.room.name)
                    return true;
                const matrix = new PathFinder.CostMatrix();
                this.creep.room.find(FIND_CREEPS).forEach(creep => matrix.set(creep.pos.x, creep.pos.y, 255));
                return matrix;
            }
        });
        this.creep.moveByPath(path.path);
        return true;
    }
    moveToHeal() {
        if (this.creep.hits === this.creep.hitsMax)
            return false;
        if (this.creep.ticksToLive && this.creep.ticksToLive < 30)
            return false;
        if (this.creep.body.filter(b => b.type === CLAIM && b.hits === 0).length === 0)
            return false;
        const healer = this.creep.pos.findClosestByRange(FIND_MY_CREEPS, {
            filter: creep => creep.id !== this.creep.id && creep.healPower > 0
        });
        if (!healer) {
            return false;
        }
        this.creep.travel(healer);
        return true;
    }
    attack() {
        return this.attackController() || this.signController() || this.claimController() || this.reserveController();
    }
    signController() {
        var _a;
        if (!this.creep.room.controller)
            return false;
        if (!this.creep.room.controller.owner)
            return false;
        if (this.creep.room.controller.my)
            return false;
        if (((_a = this.creep.room.controller.sign) === null || _a === void 0 ? void 0 : _a.text) === SIGNATURE)
            return false;
        if (!this.creep.pos.inRangeTo(this.creep.room.controller, 1))
            return false;
        this.creep.signController(this.creep.room.controller, SIGNATURE);
        return true;
    }
    claimController() {
        if (!this.creep.targetFlag)
            return false;
        if (this.creep.room.name !== this.creep.memory.targetRoom)
            return false;
        if (!this.creep.room.controller)
            return false;
        if (this.creep.room.controller.owner)
            return false;
        return this.creep.claimController(this.creep.room.controller) === OK;
    }
    reserveController() {
        if (this.creep.room.name !== this.creep.memory.targetRoom)
            return false;
        if (!this.creep.room.controller)
            return false;
        if (this.creep.room.controller.owner)
            return false;
        this.creep.reserveController(this.creep.room.controller);
        return true;
    }
    attackController() {
        if (!this.creep.room.controller) {
            return false;
        }
        if (!this.creep.room.controller.owner &&
            (!this.creep.room.controller.reservation || this.creep.room.controller.reservation.username === USERNAME.ME)) {
            return false;
        }
        if (this.creep.room.controller.my) {
            return false;
        }
        if (this.creep.room.controller.upgradeBlocked > 1) {
            return false;
        }
        if (!this.creep.pos.inRangeTo(this.creep.room.controller, 1)) {
            return false;
        }
        this.creep.attackController(this.creep.room.controller);
        return true;
    }
    moveToController() {
        if (!this.creep.targetFlag)
            return false;
        if (!this.creep.targetFlag.room)
            return false;
        if (!this.creep.targetFlag.room.controller)
            return false;
        if (!this.creep.targetFlag.room.controller.owner)
            return false;
        this.creep.travel(this.creep.targetFlag.room.controller, {
            range: 1,
            freshPath: true,
            ignoreCreeps: false,
            ignoreHostiles: false
        });
        return true;
    }
    moveToFlagRoom() {
        if (!this.creep.targetFlag) {
            return false;
        }
        return this.creep.moveToSiegeFlagRoom(this.creep.targetFlag);
    }
    moveToFlag() {
        if (!this.creep.targetFlag) {
            return false;
        }
        const closeHostileCreeps = this.creep.pos.findInRange(FIND_HOSTILE_CREEPS, 4);
        this.creep.travel(this.creep.targetFlag, {
            range: 1,
            costRoomHighway: 1,
            costRoomStandart: 1,
            costRoomSk: 2,
            ignoreCreeps: false,
            freshPath: closeHostileCreeps.length > 0,
            ignoreHostiles: false
        });
        return true;
    }
    moveToFlagMax() {
        if (!this.creep.targetFlag)
            return false;
        const path = PathFinder.search(this.creep.pos, this.creep.targetFlag.pos, {
            maxRooms: 64,
            maxOps: 20000,
            roomCallback(roomName) {
                const matrix = new PathFinder.CostMatrix();
                const obstacles = Cache.get(CacheKeys.roomObstacles(roomName));
                if (obstacles) {
                    obstacles.forEach(o => {
                        matrix.set(o.x, o.y, 255);
                    });
                }
                return matrix;
            }
        });
        this.creep.moveByPath(path.path);
        return true;
    }
    kiteBack() {
        if (this.creep.hits / this.creep.hitsMax > 0.9)
            return false;
        const path = PathFinder.search(this.creep.pos, [
            ...this.creep.room
                .find(FIND_HOSTILE_CREEPS)
                .filter(c => c.attackPower || c.rangedAttackPower)
                .map(c => ({ pos: c.pos, range: 20 })),
            ...this.creep.room
                .find(FIND_HOSTILE_STRUCTURES)
                .filter(s => s.structureType === STRUCTURE_TOWER)
                .map(c => ({ pos: c.pos, range: 40 }))
        ], {
            flee: true,
            swampCost: 2,
            plainCost: 1,
            roomCallback(roomName) {
                const room = Game.rooms[roomName];
                if (!room)
                    return true;
                const matrix = new PathFinder.CostMatrix();
                room
                    .find(FIND_STRUCTURES)
                    .filter(s => s.structureType === STRUCTURE_WALL)
                    .forEach(wall => matrix.set(wall.pos.x, wall.pos.y, 254));
                return matrix;
            }
        });
        if (!path || path.incomplete)
            return false;
        this.creep.moveByPath(path.path);
        return true;
    }
}

class WarDowngradeController {
    handle() {
        this.handleSpawn();
        this.handleCreeps();
    }
    handleSpawn() {
        General.interval(30, () => TickAction.add(() => new WarDowngradeControllerSpawner(WarDowngradeConfig.role.warDowngradeController.name).handle()));
    }
    handleCreeps() {
        Creeps.getByRole(WarDowngradeConfig.role.warDowngradeController.name)
            .filter(c => !c.spawning)
            .forEach(creep => {
            General.visualCreepCpu(creep, () => new WarDowngradeControllerWorker(WarDowngradeConfig.role.warDowngradeController.name, creep).handle());
        });
    }
}

class WarDowngradeHaulerSpawner extends AbstractSpawner {
    work() {
        Object.values(Game.flags)
            .filter(flag => flag.color === COLOR_RED && flag.secondaryColor === COLOR_GREEN)
            .forEach(flag => {
            var _a;
            const targetRoomName = flag.pos.roomName;
            const targetRoom = Game.rooms[targetRoomName];
            if (!targetRoom) {
                return;
            }
            if ((_a = targetRoom.controller) === null || _a === void 0 ? void 0 : _a.safeMode) {
                return;
            }
            const lootableResourceAmount = this.getLootableResourceAmount(targetRoom);
            if (lootableResourceAmount === 0) {
                flag.setColor(COLOR_ORANGE, COLOR_ORANGE);
                targetRoom.mem.resourcesValuableHaulCount = 0;
                Log.room(flag.pos.roomName, "hauler", "no pickable resources", "setting flag as ORANGE");
                return;
            }
            const expectedCreepCount = Math.min(Math.ceil(lootableResourceAmount / 2500 / 2), 20);
            const creepsCount = this.getCreepsCount(750, { targetRoom: targetRoomName });
            if (creepsCount >= expectedCreepCount) {
                return;
            }
            const spawnRooms = Geo.closestHomeRoomsByRange(targetRoomName, 3, {
                minLevel: 8,
                maxDistance: MAX_EXPANSION_RANGE
            });
            if (spawnRooms.length === 0) {
                return;
            }
            const closestRoom = Geo.closestHomeRoomByRange(targetRoomName, {
                room: r => !!r.storage && r.storage.my && r.storage.cachedIsActive()
            });
            if (!closestRoom) {
                return;
            }
            for (let i = creepsCount; i < expectedCreepCount; i++) {
                Spawns.addToQue(spawnRooms, {
                    body: new BodyParts().add(CARRY, 25).add(MOVE, 25).get(),
                    boosts: expectedCreepCount >= 20 ? [BOOST_ALIAS.CARRY_3, BOOST_ALIAS.CARRY_2, BOOST_ALIAS.CARRY_1] : undefined,
                    priority: WarDowngradeConfig.role.warDowngradeHauler.priority,
                    role: this.role,
                    memory: {
                        targetRoom: targetRoomName,
                        targetFlag: flag.name,
                        homeRoom: closestRoom.name
                    }
                });
            }
            if (lootableResourceAmount > 50000) {
                spawnRooms.forEach(r => (r.mem.increasedSpawnUntil = Game.time + 1500));
            }
        });
    }
    getLootableResourceAmount(room) {
        let amount = 0;
        room.find(FIND_DROPPED_RESOURCES).forEach(r => {
            if (r.pos.hasRampart) {
                return;
            }
            if (!Resources.isResourceValuable(r.resourceType)) {
                return;
            }
            amount += r.amount;
        });
        room.find(FIND_RUINS).forEach(r => {
            if (r.pos.hasRampart)
                return;
            Object.keys(r.store).forEach((resourceKey) => {
                if (!Resources.isResourceValuable(resourceKey)) {
                    return;
                }
                amount += r.store[resourceKey];
            });
        });
        room.find(FIND_TOMBSTONES).forEach(t => {
            if (t.pos.hasRampart)
                return;
            Object.keys(t.store).forEach((resourceKey) => {
                if (!Resources.isResourceValuable(resourceKey)) {
                    return;
                }
                amount += t.store[resourceKey];
            });
        });
        if (room.storage && !room.storage.pos.hasRampart) {
            Object.entries(room.storage.store).forEach(([resourceType, amnt]) => {
                if (!Resources.isResourceValuable(resourceType)) {
                    return;
                }
                amount += amnt;
            });
        }
        return amount;
    }
}

const ACTION_STORING = "storing";
const ACTION_PICKING = "picking";
const ACTION_SUICIDING = "suiciding";
class WarDowngradeHaulerWorker extends AbstractWorker {
    work() {
        if (this.creep.boost()) {
            return;
        }
        if (!this.creep.memory.action) {
            this.creep.memory.action = ACTION_PICKING;
        }
        if (this.creep.memory.action === ACTION_PICKING && this.creep.store.getFreeCapacity() === 0) {
            this.creep.memory.action = ACTION_STORING;
        }
        if (this.creep.memory.action === ACTION_STORING && this.creep.store.getUsedCapacity() === 0) {
            this.creep.memory.action = ACTION_PICKING;
        }
        if (this.creep.room.name === this.creep.memory.homeRoom &&
            this.creep.ticksToLive &&
            this.creep.ticksToLive < 700 &&
            this.creep.store.getUsedCapacity() === 0) {
            this.creep.memory.action = ACTION_SUICIDING;
        }
        if (this.creep.targetRoom && !this.creep.targetRoom.mem.resourcesValuableHaulCount) {
            this.creep.memory.action = ACTION_SUICIDING;
        }
        switch (this.creep.memory.action) {
            case ACTION_PICKING:
                if (!this.pickup()) {
                    this.creep.memory.action = ACTION_STORING;
                }
                return;
            case ACTION_STORING:
                this.deposit();
                return;
            case ACTION_SUICIDING:
                this.suicide();
                return;
        }
    }
    deposit() {
        if (!this.creep.homeRoom)
            return false;
        if (!this.creep.homeRoom.storage)
            return false;
        const resource = Object.keys(this.creep.store)[0];
        if (!resource)
            return false;
        if (this.creep.transfer(this.creep.homeRoom.storage, resource)) {
            this.creep.travel(this.creep.homeRoom.storage, { ignoreHostiles: false });
        }
        return true;
    }
    pickup() {
        if (this.creep.store.getFreeCapacity() === 0)
            return false;
        if (this.creep.pos.roomName !== this.creep.memory.targetRoom && this.creep.memory.action !== ACTION_SUICIDING) {
            return this.goToTargetRoom();
        }
        return (this.heal() ||
            this.pickupDroppedResources() ||
            this.pickupRuins() ||
            this.pickupTombstones() ||
            this.withdrawFromStorage() ||
            this.suicide());
    }
    heal() {
        if (this.creep.hits === this.creep.hitsMax) {
            return false;
        }
        const healer = this.creep.room
            .find(FIND_MY_CREEPS, {
            filter: c => c.body.filter(b => b.type === HEAL).length > 0
        })
            .sort((a, b) => b.healPower - a.healPower)[0];
        if (!healer) {
            return false;
        }
        this.creep.travel(healer, { ignoreHostiles: false });
        return true;
    }
    goToTargetRoom() {
        if (!this.creep.memory.targetRoom)
            return false;
        if (this.creep.room.name === this.creep.memory.targetRoom)
            return false;
        return this.creep.travelToRoom(this.creep.memory.targetRoom, {
            costRoomSk: 3,
            ignoreHostiles: false
        });
    }
    suicide() {
        if (!this.creep.targetRoom) {
            return false;
        }
        this.creep.memory.action = ACTION_SUICIDING;
        return this.creep.recycleFinal();
    }
    withdrawFromStorage() {
        if (!this.creep.targetRoom) {
            return false;
        }
        if (!this.creep.targetRoom.storage) {
            return false;
        }
        if (this.creep.targetRoom.storage.my) {
            return false;
        }
        if (this.creep.targetRoom.storage.pos.rampart) {
            return false;
        }
        const resource = Resources.mostValuableResource(this.creep.targetRoom.storage.store);
        if (!resource) {
            return false;
        }
        const response = this.creep.withdraw(this.creep.targetRoom.storage, resource);
        if (response === ERR_NOT_IN_RANGE) {
            this.creep.travel(this.creep.targetRoom.storage, {
                ignoreHostiles: false
            });
        }
        return true;
    }
    pickupDroppedResources() {
        const droppedResource = this.creep.room
            .find(FIND_DROPPED_RESOURCES, {
            filter: r => Resources.isResourceValuable(r.resourceType) && !r.pos.rampart
        })
            .sort((a, b) => Resources.resourceValues[b.resourceType] - Resources.resourceValues[a.resourceType])[0];
        if (!droppedResource) {
            return false;
        }
        const response = this.creep.pickup(droppedResource);
        if (response === ERR_NOT_IN_RANGE) {
            this.creep.travel(droppedResource, { ignoreHostiles: false });
        }
        return true;
    }
    pickupRuins() {
        if (!this.creep.targetRoom) {
            return false;
        }
        const ruin = this.creep.targetRoom
            .find(FIND_RUINS)
            .filter(r => {
            return Object.keys(r.store).filter(k => Resources.isResourceValuable(k)).length > 0;
        })
            .sort((a, b) => Resources.storeValue(b.store) - Resources.storeValue(a.store))[0];
        if (!ruin) {
            return false;
        }
        const distance = this.creep.pos.getRangeTo(ruin);
        if (distance > 1) {
            this.creep.travel(ruin, { ignoreHostiles: false });
        }
        else {
            const resource = Resources.mostValuableResource(ruin.store);
            if (!resource) {
                return false;
            }
            this.creep.withdraw(ruin, resource);
        }
        return true;
    }
    pickupTombstones() {
        if (!this.creep.targetRoom) {
            return false;
        }
        const tombstone = this.creep.targetRoom
            .find(FIND_TOMBSTONES)
            .filter(r => {
            return Object.keys(r.store).filter(k => Resources.isResourceValuable(k)).length > 0;
        })
            .sort((a, b) => Resources.storeValue(b.store) - Resources.storeValue(a.store))[0];
        if (!tombstone) {
            return false;
        }
        const distance = this.creep.pos.getRangeTo(tombstone);
        if (distance > 1) {
            this.creep.travel(tombstone, { ignoreHostiles: false });
        }
        else {
            const resource = Resources.mostValuableResource(tombstone.store);
            if (!resource) {
                return false;
            }
            this.creep.withdraw(tombstone, resource);
        }
        return true;
    }
}

class WarDowngradeHauler {
    handle() {
        this.handleSpawn();
        this.handleCreeps();
    }
    handleSpawn() {
        General.interval(60, () => TickAction.add(() => new WarDowngradeHaulerSpawner(WarDowngradeConfig.role.warDowngradeHauler.name).handle()));
    }
    handleCreeps() {
        Creeps.getByRole(WarDowngradeConfig.role.warDowngradeHauler.name)
            .filter(c => !c.spawning)
            .forEach(creep => {
            General.visualCreepCpu(creep, () => new WarDowngradeHaulerWorker(WarDowngradeConfig.role.warDowngradeHauler.name, creep).handle());
        });
    }
}

class WarDowngradeFlag {
    handle() {
        General.interval(5, () => this.deleteFlags());
        // this.createFlags();
    }
    createFlags() {
        Object.values(Game.rooms).forEach(room => {
            if (!room.controller) {
                return;
            }
            if (room.controller.level < 2) {
                return;
            }
            if (!room.controller.owner) {
                return;
            }
            if (room.controller.owner.username === USERNAME.ME) {
                return;
            }
            if (room.mem.towerCount && room.mem.towerCount > 0) {
                return;
            }
            const flag = room.find(FIND_FLAGS).filter(f => Flags.getType(f) === FlagType.controllerAttacker);
            if (flag.length > 0) {
                return;
            }
            room.createFlag(room.controller.pos.x, room.controller.pos.y, undefined, COLOR_RED, COLOR_PURPLE);
            console.log(`creating downgrade flag in ${room.name}`);
        });
    }
    deleteFlags() {
        Object.values(Game.flags)
            .filter(flag => Flags.getType(flag) === FlagType.controllerAttacker)
            .forEach(flag => {
            if (!flag.room) {
                return;
            }
            if (flag.room.my && flag.room.level > 1) {
                Log.room(flag.room, "WarDowngradeFlag", "cant delete flag cause room level is above 1.");
                return;
            }
            if (!flag.room.controller) {
                Log.room(flag.room, "WarDowngradeFlag", "Removing downgrade flag cause no controller");
                flag.remove();
                return;
            }
            if (flag.room.controller.my) {
                return this.removeAndDestroyAllBuildings(flag);
            }
            if (!flag.room.controller.owner &&
                Game.gcl.level === Object.values(Game.rooms).filter(r => { var _a; return (_a = r.controller) === null || _a === void 0 ? void 0 : _a.my; }).length) {
                Log.room(flag.room, "WarDowngradeFlag", "Removing downgrade flag cause no owner and cant claim any more rooms.");
                flag.remove();
                return;
            }
        });
    }
    removeAndDestroyAllBuildings(flag) {
        if (!flag.room) {
            return;
        }
        if (!flag.room.controller) {
            Log.room(flag.pos.roomName, "WarDowngradeFlag", "removing flag cause no controller");
            flag.remove();
            return;
        }
        const hostiles = flag.room.find(FIND_HOSTILE_CREEPS);
        if (hostiles.length > 0) {
            return;
        }
        flag.room
            .find(FIND_FLAGS, { filter: f => f.color === COLOR_GREY && f.secondaryColor === COLOR_GREY })
            .forEach(f => f.remove());
        const structures = flag.room.find(FIND_STRUCTURES, {
            filter: s => s.hits && (s.structureType !== STRUCTURE_STORAGE || Resources.storeValue(s.store) < 8000000) // && s.structureType !== STRUCTURE_TERMINAL
        });
        for (const structure of structures) {
            const response = structure.destroy();
            if (response !== OK) {
                Log.object(structure, "WarDowngradeFlag", "failed to destroy downgrade structure", response);
                return;
            }
        }
        flag.room.controller.unclaim();
        Log.room(flag.pos.roomName, "WarDowngradeFlag", "removing flag cause unclaimed");
        flag.remove();
    }
}

const modules$1 = [WarDowngradeController, WarDowngradeHauler, WarDowngradeFlag];
class WarDowngrade {
    handle() {
        this.handleSubModules();
    }
    handleSubModules() {
        modules$1.forEach(module => {
            try {
                new module().handle();
            }
            catch (e) {
                console.log(module.name, e);
            }
        });
    }
}

const CONFIG$P = Config.BaseNeighbourScouter;
class BaseNeighbourScouter {
    static handle() {
        Creeps.getByRole(CONFIG$P.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$P.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        this.travelToFlag(creep) || this.travelToRoom(creep) || this.nameController(creep);
    }
    static nameController(creep) {
        if (!creep.room.controller) {
            return false;
        }
        if (creep.room.controller.signUsername === USERNAME.ME) {
            return false;
        }
        if (creep.room.controller.pos.openSpots.length === 0) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.controller);
        if (distance > 1) {
            creep.travel(creep.room.controller);
        }
        else {
            if (creep.signController(creep.room.controller, SIGNATURE) === OK) {
                creep.room.mem.signatureOwner = USERNAME.ME;
            }
        }
        return true;
    }
    static travelToRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        return creep.travelToRoom(creep.memory.targetRoom, { ignoreHostiles: false });
    }
    static travelToFlag(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.targetFlag);
        if (distance === 1 && creep.targetFlag.pos.hasCreep) {
            return true;
        }
        creep.travel(creep.targetFlag, { range: 0, ignoreHostiles: false });
        return true;
    }
    static handleSpawn() {
        const creeps = Creeps.getByRole(CONFIG$P.roleName);
        const que = Creeps.queByRole(CONFIG$P.roleName);
        this.spawnerRemoteRooms(creeps, que);
        this.spawnerRemoteSkRooms(creeps, que);
        this.spawnerFlag(creeps, que);
        this.tempSpawnerFlag(creeps, que);
    }
    static tempSpawnerFlag(creeps, que) {
        Object.values(Game.flags).forEach(flag => {
            if (flag.color !== COLOR_BROWN) {
                return;
            }
            if (flag.secondaryColor !== COLOR_GREY) {
                return;
            }
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetFlag) === flag.name; }).length > 0) {
                return;
            }
            if (creeps.filter(c => c.memory.targetFlag === flag.name && (!c.ticksToLive || c.ticksToLive > 700)).length > 0) {
                return;
            }
            const spawnRoom = Geo.closestHomeRoomByRange(flag.pos.roomName, {
                maxDistance: 20,
                minLevel: 4
            });
            if (!spawnRoom) {
                Log.room(flag.pos.roomName, "BaseNeighbourScouter", "spawnerFlag", "Cant find closest room to spawn");
                return;
            }
            Spawns.addToQue(spawnRoom, {
                body: new BodyParts().rangedAttack().heal().move(30),
                priority: 0 /* Highest */,
                role: CONFIG$P.roleName,
                memory: {
                    targetFlag: flag.name
                }
            });
        });
    }
    static spawnerFlag(creeps, que) {
        Flags.flags(FlagType.scouter).forEach(flag => {
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetFlag) === flag.name; }).length > 0) {
                return;
            }
            if (creeps.filter(c => c.memory.targetFlag === flag.name && (!c.ticksToLive || c.ticksToLive > 700)).length > 0) {
                return;
            }
            const spawnRoom = Geo.closestHomeRoomByRange(flag.pos.roomName, {
                maxDistance: 20,
                minLevel: 4
            });
            if (!spawnRoom) {
                Log.room(flag.pos.roomName, "BaseNeighbourScouter", "spawnerFlag", "Cant find closest room to spawn");
                return;
            }
            Spawns.addToQue(spawnRoom, {
                body: new BodyParts().add(MOVE).get(),
                priority: 0 /* Highest */,
                role: CONFIG$P.roleName,
                memory: {
                    targetFlag: flag.name
                }
            });
        });
    }
    static spawnerRemoteSkRooms(creeps, que) {
        if (!Memory.remoteSkRooms) {
            return;
        }
        Object.values(Memory.remoteSkRooms).forEach(remoteRoomMemory => {
            if (Rooms.model(remoteRoomMemory.targetRoom).updatedAt > Game.time - 300) {
                return;
            }
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === remoteRoomMemory.targetRoom; }).length > 0) {
                return;
            }
            if (creeps.filter(c => c.memory.targetRoom === remoteRoomMemory.targetRoom).length > 0) {
                return;
            }
            Spawns.addToQue(remoteRoomMemory.homeRoom, {
                body: new BodyParts().add(MOVE).get(),
                priority: 0 /* Highest */,
                role: CONFIG$P.roleName,
                memory: {
                    targetRoom: remoteRoomMemory.targetRoom
                }
            });
        });
    }
    static spawnerRemoteRooms(creeps, que) {
        if (!Memory.remoteRooms) {
            return;
        }
        Object.values(Memory.remoteRooms).forEach(remoteRoomMemory => {
            if (Rooms.model(remoteRoomMemory.targetRoom).updatedAt > Game.time - 300) {
                return;
            }
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === remoteRoomMemory.targetRoom; }).length > 0) {
                return;
            }
            if (creeps.filter(c => c.memory.targetRoom === remoteRoomMemory.targetRoom).length > 0) {
                return;
            }
            Spawns.addToQue(remoteRoomMemory.homeRoom, {
                body: new BodyParts().add(MOVE).get(),
                priority: 0 /* Highest */,
                role: CONFIG$P.roleName,
                memory: {
                    targetRoom: remoteRoomMemory.targetRoom
                }
            });
        });
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseNeighbourScouter, "handleCreep", null);

const ROLE_NAME$g = "remoteMineReserver";
const SPAWN_PRIORITY$6 = 1 /* Higher */;
const SPAWN_INTERVAL$7 = 60;
class RemoteMineReserver {
    static handle() {
        Creeps.getByRole(ROLE_NAME$g)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.worker(creep);
        });
        General.interval(SPAWN_INTERVAL$7, () => TickAction.add(() => this.spawner()));
    }
    static worker(creep) {
        creep.escapeAnyTargetRoomHostilesToHomeRoom() ||
            this.moveIntoRoom(creep) ||
            // this.claim(creep) ||
            // this.unclaim(creep) ||
            this.reserve(creep);
    }
    static spawner() {
        if (!Memory.remoteRooms) {
            return;
        }
        const creeps = Creeps.getByRole(ROLE_NAME$g);
        const que = Creeps.queByRole(ROLE_NAME$g);
        Object.values(Memory.remoteRooms).forEach(remoteRoomMemory => {
            const homeRoom = Game.rooms[remoteRoomMemory.homeRoom];
            if (!homeRoom) {
                return;
            }
            if (homeRoom.isSiegeBase) {
                return;
            }
            if (remoteRoomMemory.avoidUntill && remoteRoomMemory.avoidUntill > Game.time) {
                return;
            }
            const targetRoomModel = Rooms.model(remoteRoomMemory.targetRoom);
            if (targetRoomModel.pvpDeaths > 10) {
                return;
            }
            if (targetRoomModel.reservedUsername === USERNAME.ME &&
                targetRoomModel.reservedEndsAt &&
                targetRoomModel.reservedEndsAt > Game.time + 2000) {
                return;
            }
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === remoteRoomMemory.targetRoom; }).length > 0) {
                return;
            }
            if (creeps.filter(c => c.memory.targetRoom === remoteRoomMemory.targetRoom).length > 0) {
                return;
            }
            Spawns.addToQue(remoteRoomMemory.homeRoom, {
                body: BodyParts.new().move(2).claim(2),
                optionalBody: BodyParts.new().move(2).claim(2),
                role: ROLE_NAME$g,
                memory: { targetRoom: targetRoomModel.roomName },
                priority: SPAWN_PRIORITY$6
            });
        });
    }
    static moveIntoRoom(creep) {
        const targetRoom = creep.memory.targetRoom;
        if (!targetRoom)
            return false;
        return creep.travelToRoom(targetRoom);
    }
    static claim(creep) {
        if (creep.room.name !== creep.memory.targetRoom) {
            return false;
        }
        const controller = creep.room.controller;
        if (!controller) {
            return false;
        }
        if (controller.safeModeCooldown && controller.safeModeCooldown > 20000) {
            return false;
        }
        if (controller.owner) {
            return false;
        }
        const distance = creep.pos.getRangeTo(controller);
        if (distance > 1) {
            creep.travel(controller);
        }
        else {
            // Log.room(creep.room, "claim");
            creep.claimController(controller);
        }
        return true;
    }
    static unclaim(creep) {
        var _a;
        if (creep.room.name !== creep.memory.targetRoom) {
            return false;
        }
        const controller = creep.room.controller;
        if (!controller) {
            return false;
        }
        if (controller.level > 1) {
            return false;
        }
        if (((_a = controller.owner) === null || _a === void 0 ? void 0 : _a.username) !== USERNAME.ME) {
            return false;
        }
        controller.unclaim();
        return true;
    }
    static reserve(creep) {
        var _a;
        if (creep.room.name !== creep.memory.targetRoom) {
            return false;
        }
        const controller = creep.room.controller;
        if (!controller) {
            return false;
        }
        const distance = creep.pos.getRangeTo(controller);
        if (distance > 1) {
            creep.travel(controller);
        }
        else {
            if (controller.signText !== SIGNATURE) {
                creep.signController(controller, SIGNATURE);
            }
            else if (controller.reservation && ((_a = controller.reservation) === null || _a === void 0 ? void 0 : _a.username) !== USERNAME.ME) {
                creep.attackController(controller);
            }
            else {
                creep.reserveController(controller);
                creep.memory.stationary = true;
            }
        }
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], RemoteMineReserver, "worker", null);
__decorate([
    Profiler.subprofile("spawn")
], RemoteMineReserver, "spawner", null);

const CONFIG$O = Config.RemoteMineDefender;
class RemoteMineDefender {
    static handle() {
        Creeps.getByRole(CONFIG$O.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.work(creep);
        });
        General.interval(CONFIG$O.spawnInterval, () => TickAction.add(() => this.spawnerMele()));
    }
    static work(creep) {
        creep.autoAttack();
        this.setTargetRoom(creep);
        this.moveToHostileNpc(creep) ||
            this.moveToHostileNpcStructure(creep) ||
            // this.moveToHomeRoom(creep) ||
            this.moveToTargetRoom(creep);
    }
    static spawnerMele() {
        if (!Memory.remoteRooms) {
            return;
        }
        const que = Creeps.queByRole(CONFIG$O.roleName);
        const creeps = Creeps.getByRole(CONFIG$O.roleName).filter(c => !c.ticksToLive || c.ticksToLive > 200);
        Object.values(Memory.remoteRooms).forEach(remoteRoomMemory => {
            const homeRoom = Game.rooms[remoteRoomMemory.homeRoom];
            if (!homeRoom) {
                return;
            }
            if (homeRoom.isSiegeBase) {
                return;
            }
            if (remoteRoomMemory.avoidUntill && remoteRoomMemory.avoidUntill > Game.time) {
                return;
            }
            const targetRoomModel = Rooms.model(remoteRoomMemory.targetRoom);
            if (targetRoomModel.isReservedNotByMe) {
                return;
            }
            if (targetRoomModel.pvpDeaths > 10) {
                return;
            }
            if (targetRoomModel.npcPower(ATTACK, RANGED_ATTACK) <= 0) {
                return;
            }
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === remoteRoomMemory.targetRoom; }).length > 0) {
                return;
            }
            if (creeps.filter(c => c.memory.targetRoom === remoteRoomMemory.targetRoom).length > 0) {
                return;
            }
            Spawns.addToQue(remoteRoomMemory.homeRoom, {
                priority: 3 /* Medium */,
                body: BodyParts.new().attack(15).move(15),
                role: CONFIG$O.roleName,
                memory: { targetRoom: remoteRoomMemory.targetRoom }
            });
        });
    }
    static moveToHostileNpcStructure(creep) {
        const hostile = creep.pos.findClosestByRange(FIND_HOSTILE_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_INVADER_CORE
        });
        if (!hostile) {
            return false;
        }
        const distance = creep.pos.getRangeTo(hostile);
        if (distance > 1) {
            creep.travel(hostile);
        }
        else {
            creep.moveTo(hostile);
        }
        return true;
    }
    static moveToHostileNpc(creep) {
        const hostile = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS, { filter: c => c.isNPC });
        if (!hostile) {
            return false;
        }
        const distance = creep.pos.getRangeTo(hostile);
        if (distance > 1) {
            creep.travel(hostile);
        }
        else {
            creep.moveTo(hostile);
        }
        return true;
    }
    static moveToHomeRoom(creep) {
        if (creep.targetRoomModel && creep.targetRoomModel.npcPower(ATTACK, RANGED_ATTACK) > 0) {
            return false;
        }
        if (!creep.memory.homeRoom) {
            return false;
        }
        creep.travel({ pos: new RoomPosition(25, 25, creep.memory.homeRoom) }, { range: 15 });
        return true;
    }
    static moveToTargetRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        if (creep.memory.targetRoom === creep.room.name) {
            return false;
        }
        creep.travelToRoom(creep.memory.targetRoom);
        return true;
    }
    static setTargetRoom(creep) {
        if (creep.targetRoomModel && creep.targetRoomModel.npcPower(ATTACK, RANGED_ATTACK) > 0) {
            return;
        }
        if (!creep.homeRoom) {
            return;
        }
        if (creep.homeRoom.model.npcPower(ATTACK, RANGED_ATTACK) === 0) {
            return;
        }
        creep.memory.targetRoom = creep.homeRoom.name;
        creep._targetRoom = undefined;
        creep._targetRoomModel = undefined;
        return;
    }
}
__decorate([
    Profiler.subprofile("creep")
], RemoteMineDefender, "work", null);
__decorate([
    Profiler.subprofile("spawn")
], RemoteMineDefender, "spawnerMele", null);

const ROLE_NAME$f = "remoteMineInvaderCoreKiller";
const SPAWN_INTERVAL$6 = 33;
class RemoteMineInvaderCoreKiller {
    static handle() {
        Creeps.getByRole(ROLE_NAME$f)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.worker(creep);
        });
        General.interval(SPAWN_INTERVAL$6, () => TickAction.add(() => this.spawner()));
    }
    static worker(creep) {
        creep.notifyWhenAttacked(false);
        this.attackInvaderCore(creep) || this.attackWalls(creep);
        this.moveToTargetRoom(creep) || this.moveToInvaderCore(creep) || this.moveToWall(creep);
    }
    static spawner() {
        if (!Memory.remoteRooms) {
            return;
        }
        const que = Creeps.queByRole(ROLE_NAME$f);
        const creeps = Creeps.getByRole(ROLE_NAME$f).filter(c => !c.ticksToLive || c.ticksToLive > 200);
        Object.values(Memory.remoteRooms).forEach(remoteRoomMemory => {
            var _a;
            const homeRoom = Game.rooms[remoteRoomMemory.homeRoom];
            if (!homeRoom) {
                return;
            }
            if (homeRoom.isSiegeBase) {
                return;
            }
            if (remoteRoomMemory.avoidUntill && remoteRoomMemory.avoidUntill > Game.time) {
                return;
            }
            const targetRoomModel = Rooms.model(remoteRoomMemory.targetRoom);
            if (!((_a = targetRoomModel.room) === null || _a === void 0 ? void 0 : _a.invaderCore)) {
                return;
            }
            if (targetRoomModel.pvpDeaths > 10) {
                return;
            }
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === remoteRoomMemory.targetRoom; }).length > 0) {
                return;
            }
            if (creeps.filter(c => c.memory.targetRoom === remoteRoomMemory.targetRoom).length > 0) {
                return;
            }
            Spawns.addToQue(remoteRoomMemory.homeRoom, {
                priority: 3 /* Medium */,
                body: BodyParts.new().attack(15).move(15),
                role: ROLE_NAME$f,
                memory: { targetRoom: remoteRoomMemory.targetRoom }
            });
        });
    }
    static attackWalls(creep) {
        if (creep.room.my) {
            return false;
        }
        const wall = creep.pos
            .findInRange(FIND_STRUCTURES, 1, { filter: s => s.structureType === STRUCTURE_WALL })
            .sort((a, b) => a.hits - b.hits)[0];
        if (!wall) {
            return false;
        }
        creep.attack(wall);
        return true;
    }
    static attackInvaderCore(creep) {
        if (!creep.targetRoom) {
            return false;
        }
        if (!creep.targetRoom.invaderCore) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.targetRoom.invaderCore);
        if (distance > 1) {
            return false;
        }
        creep.attack(creep.targetRoom.invaderCore);
        return true;
    }
    static moveToWall(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        const wall = creep.pos.findClosestByRange(FIND_STRUCTURES, { filter: s => s.structureType === STRUCTURE_WALL });
        if (!wall) {
            return false;
        }
        const distance = creep.pos.getRangeTo(wall);
        if (distance <= 1) {
            return true;
        }
        creep.travel(wall);
        return true;
    }
    static moveToInvaderCore(creep) {
        if (!creep.targetRoom) {
            return false;
        }
        if (!creep.targetRoom.invaderCore) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.targetRoom.invaderCore);
        if (distance <= 1) {
            return false;
        }
        creep.travel(creep.targetRoom.invaderCore);
        return true;
    }
    static moveToTargetRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        return creep.travelToRoom(creep.memory.targetRoom);
    }
}
__decorate([
    Profiler.subprofile("creep")
], RemoteMineInvaderCoreKiller, "worker", null);

const roles = {
    AttackerRangedQuad: "AttackerRangedQuad",
    BaseWallRepairer: "BaseWallRepairer",
    SafeModeBlockClaimer: "SafeModeBlockClaimer",
    Stronghold4Attacker: "Stronghold4Attacker",
    Stronghold5Attacker: "Stronghold5Attacker",
    ScoutSignSpreader: "ScoutSignSpreader",
    DismantlerQuad: "DismantlerQuad",
    Dismantler: "Dismantler",
    AttackerRanged: "AttackerRanged",
    StructureCleanerClaimer: "StructureCleanerClaimer",
    NewbieControllerAttacker: "NewbieControllerAttacker"
};

const CONFIG$N = Config.BaseBuilder;
const BUILD_PRIORITY = {
    [STRUCTURE_SPAWN]: 1,
    [STRUCTURE_TERMINAL]: 2,
    [STRUCTURE_STORAGE]: 3,
    [STRUCTURE_CONTAINER]: 4,
    [STRUCTURE_TOWER]: 5,
    [STRUCTURE_EXTENSION]: 6,
    [STRUCTURE_LINK]: 7,
    [STRUCTURE_ROAD]: 8,
    [STRUCTURE_WALL]: 9,
    [STRUCTURE_EXTRACTOR]: 10,
    [STRUCTURE_OBSERVER]: 11,
    [STRUCTURE_POWER_SPAWN]: 12,
    [STRUCTURE_LAB]: 13,
    [STRUCTURE_NUKER]: 14,
    [STRUCTURE_FACTORY]: 998,
    [STRUCTURE_RAMPART]: 999
};
class BaseBuilder {
    static handle() {
        Creeps.getByRole(CONFIG$N.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$N.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        this.validateCreep(creep);
        this.setTarget(creep);
        if (creep.recycleFinal(70)) {
            return;
        }
        if (!creep.target && !creep.memory.targetRoom) {
            // if (creep.homeRoom && creep.homeRoom?.level < 6) {
            //   creep.memory.role = CONFIG_BASE_UPGRADER.roleName;
            // } else {
            creep.memory.role = roles.BaseWallRepairer;
            // }
            creep.target = null;
            return;
        }
        else {
            creep.memory.recycling = undefined;
        }
        if (creep.store.getUsedCapacity() === 0) {
            creep.boost({ minTicksToLive: 1400 }) ||
                this.withdrawEnergyFromStorage(creep) ||
                this.withdrawEnergyFromTerminal(creep) ||
                this.withdrawEnergyFromContainerOrSpawn(creep);
        }
        else {
            creep.boost({ minTicksToLive: 1400 }) || this.moveToTargetRoom(creep) || this.buildConstruction(creep);
        }
    }
    static moveToTargetRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        if (creep.memory.targetRoom === creep.room.name) {
            return false;
        }
        const roomModel = Rooms.model(creep.memory.targetRoom);
        if (roomModel.hostileAttackPower +
            roomModel.hostileRangedAttackPower +
            roomModel.npcAttackPower +
            roomModel.npcRangedAttackPower >
            0) {
            return false;
        }
        return creep.travelToRoom(creep.memory.targetRoom);
    }
    static handleSpawn() {
        Rooms.myRooms.forEach(room => {
            if (room.isAbandoning) {
                return;
            }
            if (General.expansionWithSupport() && room.level < 6) {
                return;
            }
            if (!this.haveConstructions(room)) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({
                minTicksToLive: 100,
                homeRoom: room.name,
                role: CONFIG$N.roleName
            });
            const homeRoomProgress = room
                .find(FIND_MY_CONSTRUCTION_SITES)
                .reduce((total, c) => total + c.progressTotal - c.progress, 0);
            const maxCreeps = Math.min(4, Math.ceil(homeRoomProgress / 20000) || 1);
            if (creepsCount >= maxCreeps) {
                return;
            }
            Spawns.addToQue(room, {
                body: BodyParts.new().addMultiple([MOVE, WORK, MOVE, CARRY]),
                optionalBody: BodyParts.new().addMultiple([MOVE, WORK, MOVE, CARRY], 12),
                priority: CONFIG$N.spawnPriority,
                role: CONFIG$N.roleName,
                boosts: homeRoomProgress >= 50000
                    ? [BOOST_ALIAS.REPAIR_BUILD_3, BOOST_ALIAS.REPAIR_BUILD_2, BOOST_ALIAS.REPAIR_BUILD_1]
                    : undefined
            });
        });
    }
    static haveConstructions(homeRoom) {
        const constructions = homeRoom.find(FIND_MY_CONSTRUCTION_SITES, {
            filter: c => c.structureType !== STRUCTURE_RAMPART
        });
        if (constructions.length === 0) {
            return false;
        }
        return true;
    }
    static validateCreep(creep) {
        if (!creep.homeRoom) {
            Log.object(creep, "Missing home room");
        }
        if (creep.target && !(creep.target instanceof ConstructionSite)) {
            Log.object(creep, "Wrong target type");
        }
    }
    static withdrawEnergyFromContainerOrSpawn(creep) {
        if (!creep.homeRoom) {
            return false;
        }
        const storage = creep.homeRoom.centerContainers.length > 0
            ? creep.homeRoom.centerContainers.find(c => c.store.energy >= 1000)
            : creep.homeRoom.myActiveSpawns.find(s => s.store.energy >= 250);
        if (!storage) {
            return false;
        }
        const distance = creep.pos.getRangeTo(storage);
        if (distance > 1) {
            creep.travel(storage);
        }
        else {
            creep.withdraw(storage, RESOURCE_ENERGY);
        }
        return true;
    }
    static withdrawEnergyFromTerminal(creep) {
        if (!creep.homeRoom) {
            return false;
        }
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (!creep.homeRoom.terminal) {
            return false;
        }
        if (creep.homeRoom.terminal.store.energy < 100) {
            return false;
        }
        if (creep.withdraw(creep.homeRoom.terminal, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.homeRoom.terminal);
        }
        return true;
    }
    static withdrawEnergyFromStorage(creep) {
        if (!creep.homeRoom) {
            return false;
        }
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (!creep.homeRoom.storage) {
            return false;
        }
        if (creep.homeRoom.storage.store.energy < 1000) {
            return false;
        }
        if (creep.withdraw(creep.homeRoom.storage, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.homeRoom.storage);
        }
        return true;
    }
    static buildConstruction(creep) {
        if (creep.store.energy === 0) {
            return false;
        }
        if (!(creep.target instanceof ConstructionSite)) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.target);
        if (distance >= 4) {
            creep.travel(creep.target, { range: 3 });
        }
        else if (distance >= 2) {
            creep.build(creep.target);
            creep.travel(creep.target, { range: 1, ignoreCreeps: false, maxOps: 200, freshPath: true });
        }
        else {
            creep.build(creep.target);
        }
        return true;
    }
    static setTarget(creep) {
        if (creep.target) {
            return;
        }
        creep.target =
            creep.room
                .find(FIND_MY_CONSTRUCTION_SITES)
                .filter(c => c.structureType !== STRUCTURE_RAMPART)
                .sort((a, b) => BUILD_PRIORITY[a.structureType] - BUILD_PRIORITY[b.structureType])[0] ||
                this.findExitRoomConstructionSite(creep) ||
                null;
        if (creep.target) {
            creep.memory.targetRoom = creep.target.pos.roomName;
        }
        else {
            creep.memory.targetRoom = undefined;
        }
    }
    static findExitRoomConstructionSite(creep) {
        if (!creep.homeRoom) {
            return;
        }
        const construction = creep.homeRoom
            .find(FIND_MY_CONSTRUCTION_SITES)
            .filter(s => s.structureType !== STRUCTURE_RAMPART)[0];
        if (!construction) {
            return;
        }
        return construction;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseBuilder, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseBuilder, "handleSpawn", null);

var Types;
(function (Types) {
    Types[Types["energy"] = 0] = "energy";
    Types[Types["power"] = 1] = "power";
    Types[Types["ops"] = 2] = "ops";
    Types[Types["boost"] = 3] = "boost";
    Types[Types["tier1"] = 4] = "tier1";
    Types[Types["tier2"] = 5] = "tier2";
    Types[Types["tier3"] = 6] = "tier3";
    Types[Types["lvl1"] = 7] = "lvl1";
    Types[Types["lvl2"] = 8] = "lvl2";
    Types[Types["lvl3"] = 9] = "lvl3";
    Types[Types["lvl4"] = 10] = "lvl4";
    Types[Types["lvl5"] = 11] = "lvl5";
    Types[Types["commodity"] = 12] = "commodity";
    Types[Types["compressing"] = 13] = "compressing";
    Types[Types["common"] = 14] = "common";
    Types[Types["basic"] = 15] = "basic";
    Types[Types["raw"] = 16] = "raw";
    Types[Types["mechanicalChain"] = 17] = "mechanicalChain";
    Types[Types["biologicalChain"] = 18] = "biologicalChain";
    Types[Types["electronicalChain"] = 19] = "electronicalChain";
    Types[Types["mysticalChain"] = 20] = "mysticalChain";
    Types[Types["mineral"] = 21] = "mineral";
    Types[Types["boostCompound"] = 22] = "boostCompound";
})(Types || (Types = {}));
const MINERAL_BATCH_MIN = 500;
const MINERAL_STORAGE_MAX_AMOUNT = 20000;
const MINERAL_TERMINAL_BALANCE_MIN = 2000;
const MINERAL_TERMINAL_MIN_AMOUNT = 5000;
const MINERAL_TERMINAL_SELL_INSTANT_FROM = 10000;
const MINERAL_TERMINAL_SELL_INSTANT_MIN_AMOUNT = 1000;
const BOOST_COMPOUND_BATCH_MIN = 500;
const BOOST_COMPOUND_STORAGE_MAX_AMOUNT = 10000;
const BOOST_COMPOUND_TERMINAL_BALANCE_MIN = 2000;
const BOOST_COMPOUND_TERMINAL_MIN_AMOUNT = 3000;
const BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM = 10000;
const BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT = 1000;
const BOOST_TIER_3_BATCH_MIN = 500;
const BOOST_TIER_3_STORAGE_MAX_AMOUNT = 40000;
const BOOST_TIER_3_TERMINAL_BALANCE_MIN = 1000;
const BOOST_TIER_3_TERMINAL_MIN_AMOUNT = 5000;
const BOOST_TIER_3_TERMINAL_SELL_INSTANT_FROM = 10000;
const BOOST_TIER_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT = 1000;
const COMMODITY_REGIONAL_BATCH_MIN = 100;
const COMMODITY_REGIONAL_STORAGE_MAX_AMOUNT = 0;
const COMMODITY_REGIONAL_TERMINAL_BALANCE_MIN = 5000;
const COMMODITY_REGIONAL_TERMINAL_MIN_AMOUNT = 0;
const COMMODITY_REGIONAL_TERMINAL_SELL_INSTANT_FROM = 0;
const COMMODITY_REGIONAL_TERMINAL_SELL_INSTANT_MIN_AMOUNT = 1;
const COMMODITY_COMPRESSING_BATCH_MIN = 100;
const COMMODITY_COMPRESSING_STORAGE_MAX_AMOUNT = 0;
const COMMODITY_COMPRESSING_TERMINAL_BALANCE_MIN = 1000;
const COMMODITY_COMPRESSING_TERMINAL_MIN_AMOUNT = 10000;
const COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_FROM = 0;
const COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_MIN_AMOUNT = 100;
const COMMODITY_RAW_BATCH_MIN = 200;
const COMMODITY_RAW_STORAGE_MAX_AMOUNT = 0;
const COMMODITY_RAW_TERMINAL_BALANCE_MIN = 1000;
const COMMODITY_RAW_TERMINAL_MIN_AMOUNT = 5000;
const COMMODITY_RAW_TERMINAL_SELL_INSTANT_FROM = 0;
const COMMODITY_RAW_TERMINAL_SELL_INSTANT_MIN_AMOUNT = 1;
const COMMODITY_COMMON_BATCH_MIN = 100;
const COMMODITY_COMMON_STORAGE_MAX_AMOUNT = 0;
const COMMODITY_COMMON_TERMINAL_BALANCE_MIN = 5000;
const COMMODITY_COMMON_TERMINAL_MIN_AMOUNT = 0;
const COMMODITY_COMMON_TERMINAL_SELL_INSTANT_FROM = 0;
const COMMODITY_COMMON_TERMINAL_SELL_INSTANT_MIN_AMOUNT = 1;
const COMMODITY_LVL_1_BATCH_MIN = 100;
const COMMODITY_LVL_1_STORAGE_MAX_AMOUNT = 0;
const COMMODITY_LVL_1_TERMINAL_BALANCE_MIN = 5000;
const COMMODITY_LVL_1_TERMINAL_MIN_AMOUNT = 0;
const COMMODITY_LVL_1_TERMINAL_SELL_INSTANT_FROM = 0;
const COMMODITY_LVL_1_TERMINAL_SELL_INSTANT_MIN_AMOUNT = 1;
const COMMODITY_LVL_2_BATCH_MIN = 100;
const COMMODITY_LVL_2_STORAGE_MAX_AMOUNT = 0;
const COMMODITY_LVL_2_TERMINAL_BALANCE_MIN = 5000;
const COMMODITY_LVL_2_TERMINAL_MIN_AMOUNT = 0;
const COMMODITY_LVL_2_TERMINAL_SELL_INSTANT_FROM = 0;
const COMMODITY_LVL_2_TERMINAL_SELL_INSTANT_MIN_AMOUNT = 1;
const COMMODITY_LVL_3_BATCH_MIN = 100;
const COMMODITY_LVL_3_STORAGE_MAX_AMOUNT = 0;
const COMMODITY_LVL_3_TERMINAL_BALANCE_MIN = 5000;
const COMMODITY_LVL_3_TERMINAL_MIN_AMOUNT = 0;
const COMMODITY_LVL_3_TERMINAL_SELL_INSTANT_FROM = 0;
const COMMODITY_LVL_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT = 1;
const COMMODITY_LVL_4_BATCH_MIN = 100;
const COMMODITY_LVL_4_STORAGE_MAX_AMOUNT = 0;
const COMMODITY_LVL_4_TERMINAL_BALANCE_MIN = 5000;
const COMMODITY_LVL_4_TERMINAL_MIN_AMOUNT = 0;
const COMMODITY_LVL_4_TERMINAL_SELL_INSTANT_FROM = 0;
const COMMODITY_LVL_4_TERMINAL_SELL_INSTANT_MIN_AMOUNT = 1;
const COMMODITY_LVL_5_BATCH_MIN = 100;
const COMMODITY_LVL_5_STORAGE_MAX_AMOUNT = 0;
const COMMODITY_LVL_5_TERMINAL_BALANCE_MIN = 5000;
const COMMODITY_LVL_5_TERMINAL_MIN_AMOUNT = 0;
const COMMODITY_LVL_5_TERMINAL_SELL_INSTANT_FROM = 0;
const COMMODITY_LVL_5_TERMINAL_SELL_INSTANT_MIN_AMOUNT = 1;
const ENERGY_TERMINAL_MIN_AMOUNT = 15000;
const CONFIG_BALANCE = {
    [RESOURCE_ENERGY]: {
        types: [Types.energy],
        batchSizeMin: 100,
        storageMaxAmount: 250000,
        terminalBalanceMin: 5000,
        terminalBalanceMinRoomLevel: 6,
        terminalMinAmount: ENERGY_TERMINAL_MIN_AMOUNT,
        terminalMaxAmount: 30000,
        terminalSellInstantFrom: 40000,
        terminalSellInstantMinAmount: 5000,
        terminalBalanceInLowRooms: true,
        factory: {
            amount: 10000,
            produceWhenLessThan: Infinity,
            produceResource: RESOURCE_BATTERY
        }
    },
    [RESOURCE_POWER]: {
        types: [Types.power],
        batchSizeMin: 100,
        storageMaxAmount: 0,
        terminalBalanceMin: 1000,
        terminalMinAmount: 10000,
        terminalSellInstantFrom: 2000,
        terminalSellInstantMinAmount: 1000 // 1_000
    },
    [RESOURCE_OPS]: {
        types: [Types.ops],
        batchSizeMin: 100,
        storageMaxAmount: 10000,
        terminalBalanceMin: 1000,
        terminalMinAmount: 10000,
        terminalSellInstantFrom: 20000,
        terminalSellInstantMinAmount: 5000,
        terminalBuyUnder: 5000,
        terminalBuyMinCredits: 1000000000
    },
    [RESOURCE_OXYGEN]: {
        types: [Types.mineral],
        batchSizeMin: MINERAL_BATCH_MIN,
        storageMaxAmount: MINERAL_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: MINERAL_TERMINAL_BALANCE_MIN,
        terminalMinAmount: MINERAL_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: MINERAL_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: MINERAL_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyOrderUnder: 5000,
        terminalBuyOrderAmount: 5000,
        terminalBuyOrderMinCredits: 1000000000
    },
    [RESOURCE_HYDROGEN]: {
        types: [Types.mineral],
        batchSizeMin: MINERAL_BATCH_MIN,
        storageMaxAmount: MINERAL_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: MINERAL_TERMINAL_BALANCE_MIN,
        terminalMinAmount: MINERAL_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: MINERAL_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: MINERAL_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyOrderUnder: 5000,
        terminalBuyOrderAmount: 5000,
        terminalBuyOrderMinCredits: 1000000000
    },
    [RESOURCE_KEANIUM]: {
        types: [Types.mineral],
        batchSizeMin: MINERAL_BATCH_MIN,
        storageMaxAmount: MINERAL_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: MINERAL_TERMINAL_BALANCE_MIN,
        terminalMinAmount: MINERAL_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: MINERAL_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: MINERAL_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyOrderUnder: 5000,
        terminalBuyOrderAmount: 5000,
        terminalBuyOrderMinCredits: 1000000000
    },
    [RESOURCE_LEMERGIUM]: {
        types: [Types.mineral],
        batchSizeMin: MINERAL_BATCH_MIN,
        storageMaxAmount: MINERAL_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: MINERAL_TERMINAL_BALANCE_MIN,
        terminalMinAmount: MINERAL_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: MINERAL_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: MINERAL_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyOrderUnder: 5000,
        terminalBuyOrderAmount: 5000,
        terminalBuyOrderMinCredits: 1000000000
    },
    [RESOURCE_UTRIUM]: {
        types: [Types.mineral],
        batchSizeMin: MINERAL_BATCH_MIN,
        storageMaxAmount: MINERAL_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: MINERAL_TERMINAL_BALANCE_MIN,
        terminalMinAmount: MINERAL_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: MINERAL_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: MINERAL_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyOrderUnder: 5000,
        terminalBuyOrderAmount: 5000,
        terminalBuyOrderMinCredits: 1000000000
    },
    [RESOURCE_CATALYST]: {
        types: [Types.mineral],
        batchSizeMin: MINERAL_BATCH_MIN,
        storageMaxAmount: MINERAL_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: MINERAL_TERMINAL_BALANCE_MIN,
        terminalMinAmount: MINERAL_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: MINERAL_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: MINERAL_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyOrderUnder: 5000,
        terminalBuyOrderAmount: 5000,
        terminalBuyOrderMinCredits: 200000000,
        terminalBuyUnder: 5000,
        terminalBuyMinCredits: 1000000000
    },
    [RESOURCE_ZYNTHIUM]: {
        types: [Types.mineral],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: MINERAL_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: MINERAL_TERMINAL_BALANCE_MIN,
        terminalMinAmount: MINERAL_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: MINERAL_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: MINERAL_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyOrderUnder: 5000,
        terminalBuyOrderAmount: 5000,
        terminalBuyOrderMinCredits: 1000000000
    },
    [RESOURCE_GHODIUM]: {
        types: [Types.boostCompound],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_HYDROXIDE]: {
        types: [Types.boostCompound],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_ZYNTHIUM_KEANITE]: {
        types: [Types.boostCompound],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_UTRIUM_LEMERGITE]: {
        types: [Types.boostCompound],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_GHODIUM_HYDRIDE]: {
        types: [Types.boost, Types.tier1],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMinRoomLevel: 6,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalBalanceInLowRooms: true,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyUnder: 10000,
        terminalBuyMinCredits: 200000000
    },
    [RESOURCE_GHODIUM_ACID]: {
        types: [Types.boost, Types.tier2],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMinRoomLevel: 6,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalBalanceInLowRooms: true,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyUnder: 10000,
        terminalBuyMinCredits: 300000000
    },
    [RESOURCE_GHODIUM_ALKALIDE]: {
        types: [Types.boost, Types.tier2],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_GHODIUM_OXIDE]: {
        types: [Types.boost, Types.tier1],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_KEANIUM_HYDRIDE]: {
        types: [Types.boost, Types.tier1],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyUnder: 5000,
        terminalBuyMinCredits: 300000000
    },
    [RESOURCE_KEANIUM_ACID]: {
        types: [Types.boost, Types.tier2],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_KEANIUM_ALKALIDE]: {
        types: [Types.boost, Types.tier2],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_KEANIUM_OXIDE]: {
        types: [Types.boost, Types.tier1],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_LEMERGIUM_HYDRIDE]: {
        types: [Types.boost, Types.tier1],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMinRoomLevel: 6,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyUnder: 10000,
        terminalBuyMinCredits: 300000000
    },
    [RESOURCE_LEMERGIUM_ACID]: {
        types: [Types.boost, Types.tier2],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMinRoomLevel: 6,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalBalanceInLowRooms: true,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyUnder: 10000,
        terminalBuyMinCredits: 350000000
    },
    [RESOURCE_LEMERGIUM_ALKALIDE]: {
        types: [Types.boost, Types.tier2],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_LEMERGIUM_OXIDE]: {
        types: [Types.boost, Types.tier1],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_UTRIUM_HYDRIDE]: {
        types: [Types.boost, Types.tier1],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_UTRIUM_ACID]: {
        types: [Types.boost, Types.tier2],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_UTRIUM_ALKALIDE]: {
        types: [Types.boost, Types.tier2],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_UTRIUM_OXIDE]: {
        types: [Types.boost, Types.tier1],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_ZYNTHIUM_HYDRIDE]: {
        types: [Types.boost, Types.tier1],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_ZYNTHIUM_ALKALIDE]: {
        types: [Types.boost, Types.tier2],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_ZYNTHIUM_ACID]: {
        types: [Types.boost, Types.tier2],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_ZYNTHIUM_OXIDE]: {
        types: [Types.boost, Types.tier1],
        batchSizeMin: BOOST_COMPOUND_BATCH_MIN,
        storageMaxAmount: BOOST_COMPOUND_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_COMPOUND_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_COMPOUND_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_COMPOUND_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_CATALYZED_GHODIUM_ACID]: {
        types: [Types.boost, Types.tier3],
        batchSizeMin: BOOST_TIER_3_BATCH_MIN,
        storageMaxAmount: BOOST_TIER_3_STORAGE_MAX_AMOUNT,
        terminalBalanceMinRoomLevel: 6,
        terminalBalanceMin: BOOST_TIER_3_TERMINAL_BALANCE_MIN,
        terminalBalanceInLowRooms: true,
        terminalMinAmount: BOOST_TIER_3_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_TIER_3_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_TIER_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyUnder: 10000,
        terminalBuyMinCredits: 500000000
    },
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: {
        types: [Types.boost, Types.tier3],
        batchSizeMin: BOOST_TIER_3_BATCH_MIN,
        storageMaxAmount: BOOST_TIER_3_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_TIER_3_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_TIER_3_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_TIER_3_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_TIER_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_CATALYZED_KEANIUM_ACID]: {
        types: [Types.boost, Types.tier3],
        batchSizeMin: BOOST_TIER_3_BATCH_MIN,
        storageMaxAmount: BOOST_TIER_3_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_TIER_3_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_TIER_3_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_TIER_3_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_TIER_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: {
        types: [Types.boost, Types.tier3],
        batchSizeMin: BOOST_TIER_3_BATCH_MIN,
        storageMaxAmount: BOOST_TIER_3_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_TIER_3_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_TIER_3_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_TIER_3_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_TIER_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: {
        types: [Types.boost, Types.tier3],
        batchSizeMin: BOOST_TIER_3_BATCH_MIN,
        storageMaxAmount: BOOST_TIER_3_STORAGE_MAX_AMOUNT,
        terminalBalanceMinRoomLevel: 6,
        terminalBalanceMin: BOOST_TIER_3_TERMINAL_BALANCE_MIN,
        terminalBalanceInLowRooms: true,
        terminalMinAmount: BOOST_TIER_3_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_TIER_3_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_TIER_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyUnder: 10000,
        terminalBuyMinCredits: 400000000
    },
    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: {
        types: [Types.boost, Types.tier3],
        batchSizeMin: BOOST_TIER_3_BATCH_MIN,
        storageMaxAmount: BOOST_TIER_3_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_TIER_3_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_TIER_3_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_TIER_3_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_TIER_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_CATALYZED_UTRIUM_ACID]: {
        types: [Types.boost, Types.tier3],
        batchSizeMin: BOOST_TIER_3_BATCH_MIN,
        storageMaxAmount: BOOST_TIER_3_STORAGE_MAX_AMOUNT,
        terminalBalanceMinRoomLevel: 6,
        terminalBalanceMin: BOOST_TIER_3_TERMINAL_BALANCE_MIN,
        terminalBalanceInLowRooms: true,
        terminalMinAmount: BOOST_TIER_3_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_TIER_3_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_TIER_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyUnder: 10000,
        terminalBuyMinCredits: 200000000
    },
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: {
        types: [Types.boost, Types.tier3],
        batchSizeMin: BOOST_TIER_3_BATCH_MIN,
        storageMaxAmount: BOOST_TIER_3_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_TIER_3_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_TIER_3_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_TIER_3_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_TIER_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: {
        types: [Types.boost, Types.tier3],
        batchSizeMin: BOOST_TIER_3_BATCH_MIN,
        storageMaxAmount: BOOST_TIER_3_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: BOOST_TIER_3_TERMINAL_BALANCE_MIN,
        terminalMinAmount: BOOST_TIER_3_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_TIER_3_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_TIER_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        terminalBuyUnder: 10000,
        terminalBuyMinCredits: 500000000
    },
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: {
        types: [Types.boost, Types.tier3],
        batchSizeMin: BOOST_TIER_3_BATCH_MIN,
        storageMaxAmount: BOOST_TIER_3_STORAGE_MAX_AMOUNT,
        terminalBalanceMinRoomLevel: 6,
        terminalBalanceMin: BOOST_TIER_3_TERMINAL_BALANCE_MIN,
        terminalBalanceInLowRooms: true,
        terminalMinAmount: BOOST_TIER_3_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: BOOST_TIER_3_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: BOOST_TIER_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_ALLOY]: {
        types: [Types.commodity, Types.basic],
        batchSizeMin: COMMODITY_REGIONAL_BATCH_MIN,
        storageMaxAmount: COMMODITY_REGIONAL_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_REGIONAL_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_REGIONAL_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_REGIONAL_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_REGIONAL_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_WIRE]: {
        types: [Types.commodity, Types.basic],
        batchSizeMin: COMMODITY_REGIONAL_BATCH_MIN,
        storageMaxAmount: COMMODITY_REGIONAL_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_REGIONAL_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_REGIONAL_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_REGIONAL_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_REGIONAL_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_CELL]: {
        types: [Types.commodity, Types.basic],
        batchSizeMin: COMMODITY_REGIONAL_BATCH_MIN,
        storageMaxAmount: COMMODITY_REGIONAL_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_REGIONAL_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_REGIONAL_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_REGIONAL_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_REGIONAL_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_CONDENSATE]: {
        types: [Types.commodity, Types.basic],
        batchSizeMin: COMMODITY_REGIONAL_BATCH_MIN,
        storageMaxAmount: COMMODITY_REGIONAL_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_REGIONAL_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_REGIONAL_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_REGIONAL_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_REGIONAL_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_BATTERY]: {
        types: [Types.commodity, Types.compressing],
        batchSizeMin: COMMODITY_COMPRESSING_BATCH_MIN,
        storageMaxAmount: COMMODITY_COMPRESSING_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_COMPRESSING_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_COMPRESSING_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        factory: {
            amount: 1000,
            produceWhenLessThan: 100000,
            produceResource: RESOURCE_ENERGY
        }
    },
    [RESOURCE_PURIFIER]: {
        types: [Types.commodity, Types.compressing],
        batchSizeMin: COMMODITY_COMPRESSING_BATCH_MIN,
        storageMaxAmount: COMMODITY_COMPRESSING_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_COMPRESSING_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_COMPRESSING_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        factory: {
            amount: 1000,
            produceWhenLessThan: 5000,
            produceResource: RESOURCE_CATALYST
        }
    },
    [RESOURCE_REDUCTANT]: {
        types: [Types.commodity, Types.compressing],
        batchSizeMin: COMMODITY_COMPRESSING_BATCH_MIN,
        storageMaxAmount: COMMODITY_COMPRESSING_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_COMPRESSING_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_COMPRESSING_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        factory: {
            amount: 1000,
            produceWhenLessThan: 5000,
            produceResource: RESOURCE_HYDROGEN
        }
    },
    [RESOURCE_OXIDANT]: {
        types: [Types.commodity, Types.compressing],
        batchSizeMin: COMMODITY_COMPRESSING_BATCH_MIN,
        storageMaxAmount: COMMODITY_COMPRESSING_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_COMPRESSING_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_COMPRESSING_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        factory: {
            amount: 1000,
            produceWhenLessThan: 5000,
            produceResource: RESOURCE_OXYGEN
        }
    },
    [RESOURCE_GHODIUM_MELT]: {
        types: [Types.commodity, Types.compressing],
        batchSizeMin: COMMODITY_COMPRESSING_BATCH_MIN,
        storageMaxAmount: COMMODITY_COMPRESSING_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_COMPRESSING_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_COMPRESSING_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        factory: {
            amount: 1000,
            produceWhenLessThan: 5000,
            produceResource: RESOURCE_GHODIUM
        }
    },
    [RESOURCE_KEANIUM_BAR]: {
        types: [Types.commodity, Types.compressing],
        batchSizeMin: COMMODITY_COMPRESSING_BATCH_MIN,
        storageMaxAmount: COMMODITY_COMPRESSING_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_COMPRESSING_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_COMPRESSING_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        factory: {
            amount: 1000,
            produceWhenLessThan: 5000,
            produceResource: RESOURCE_KEANIUM
        }
    },
    [RESOURCE_ZYNTHIUM_BAR]: {
        types: [Types.commodity, Types.compressing],
        batchSizeMin: COMMODITY_COMPRESSING_BATCH_MIN,
        storageMaxAmount: COMMODITY_COMPRESSING_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_COMPRESSING_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_COMPRESSING_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        factory: {
            amount: 1000,
            produceWhenLessThan: 5000,
            produceResource: RESOURCE_ZYNTHIUM
        }
    },
    [RESOURCE_LEMERGIUM_BAR]: {
        types: [Types.commodity, Types.compressing],
        batchSizeMin: COMMODITY_COMPRESSING_BATCH_MIN,
        storageMaxAmount: COMMODITY_COMPRESSING_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_COMPRESSING_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_COMPRESSING_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        factory: {
            amount: 1000,
            produceWhenLessThan: 5000,
            produceResource: RESOURCE_LEMERGIUM
        }
    },
    [RESOURCE_UTRIUM_BAR]: {
        types: [Types.commodity, Types.compressing],
        batchSizeMin: COMMODITY_COMPRESSING_BATCH_MIN,
        storageMaxAmount: COMMODITY_COMPRESSING_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_COMPRESSING_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_COMPRESSING_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_COMPRESSING_TERMINAL_SELL_INSTANT_MIN_AMOUNT,
        factory: {
            amount: 1000,
            produceWhenLessThan: 5000,
            produceResource: RESOURCE_UTRIUM
        }
    },
    [RESOURCE_BIOMASS]: {
        types: [Types.commodity, Types.raw, Types.biologicalChain],
        batchSizeMin: COMMODITY_RAW_BATCH_MIN,
        storageMaxAmount: COMMODITY_RAW_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_RAW_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_RAW_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_RAW_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_RAW_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_METAL]: {
        types: [Types.commodity, Types.raw, Types.mechanicalChain],
        batchSizeMin: COMMODITY_RAW_BATCH_MIN,
        storageMaxAmount: COMMODITY_RAW_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_RAW_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_RAW_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_RAW_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_RAW_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_SILICON]: {
        types: [Types.commodity, Types.raw, Types.electronicalChain],
        batchSizeMin: COMMODITY_RAW_BATCH_MIN,
        storageMaxAmount: COMMODITY_RAW_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_RAW_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_RAW_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_RAW_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_RAW_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_MIST]: {
        types: [Types.commodity, Types.raw, Types.mysticalChain],
        batchSizeMin: COMMODITY_RAW_BATCH_MIN,
        storageMaxAmount: COMMODITY_RAW_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_RAW_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_RAW_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_RAW_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_RAW_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_COMPOSITE]: {
        types: [Types.commodity, Types.common],
        batchSizeMin: COMMODITY_COMMON_BATCH_MIN,
        storageMaxAmount: COMMODITY_COMMON_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_COMMON_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_COMMON_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_COMMON_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_COMMON_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_CRYSTAL]: {
        types: [Types.commodity, Types.common],
        batchSizeMin: COMMODITY_COMMON_BATCH_MIN,
        storageMaxAmount: COMMODITY_COMMON_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_COMMON_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_COMMON_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_COMMON_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_COMMON_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_LIQUID]: {
        types: [Types.commodity, Types.common],
        batchSizeMin: COMMODITY_COMMON_BATCH_MIN,
        storageMaxAmount: COMMODITY_COMMON_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_COMMON_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_COMMON_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_COMMON_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_COMMON_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_TUBE]: {
        types: [Types.commodity, Types.lvl1, Types.mechanicalChain],
        batchSizeMin: COMMODITY_LVL_1_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_1_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_1_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_1_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_1_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_1_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_PHLEGM]: {
        types: [Types.commodity, Types.lvl1, Types.biologicalChain],
        batchSizeMin: COMMODITY_LVL_1_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_1_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_1_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_1_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_1_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_1_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_SWITCH]: {
        types: [Types.commodity, Types.lvl1, Types.electronicalChain],
        batchSizeMin: COMMODITY_LVL_1_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_1_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_1_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_1_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_1_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_1_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_CONCENTRATE]: {
        types: [Types.commodity, Types.lvl1, Types.mysticalChain],
        batchSizeMin: COMMODITY_LVL_1_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_1_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_1_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_1_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_1_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_1_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_FIXTURES]: {
        types: [Types.commodity, Types.lvl2, Types.mechanicalChain],
        batchSizeMin: COMMODITY_LVL_2_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_2_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_2_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_2_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_2_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_2_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_TISSUE]: {
        types: [Types.commodity, Types.lvl2, Types.biologicalChain],
        batchSizeMin: COMMODITY_LVL_2_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_2_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_2_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_2_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_2_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_2_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_TRANSISTOR]: {
        types: [Types.commodity, Types.lvl2, Types.electronicalChain],
        batchSizeMin: COMMODITY_LVL_2_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_2_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_2_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_2_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_2_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_2_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_EXTRACT]: {
        types: [Types.commodity, Types.lvl2, Types.mysticalChain],
        batchSizeMin: COMMODITY_LVL_2_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_2_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_2_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_2_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_2_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_2_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_FRAME]: {
        types: [Types.commodity, Types.lvl3, Types.mechanicalChain],
        batchSizeMin: COMMODITY_LVL_3_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_3_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_3_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_3_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_3_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_MUSCLE]: {
        types: [Types.commodity, Types.lvl3, Types.biologicalChain],
        batchSizeMin: COMMODITY_LVL_3_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_3_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_3_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_3_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_3_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_MICROCHIP]: {
        types: [Types.commodity, Types.lvl3, Types.electronicalChain],
        batchSizeMin: COMMODITY_LVL_3_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_3_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_3_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_3_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_3_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_SPIRIT]: {
        types: [Types.commodity, Types.lvl3, Types.mysticalChain],
        batchSizeMin: COMMODITY_LVL_3_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_3_STORAGE_MAX_AMOUNT,
        terminalMinAmount: COMMODITY_LVL_3_TERMINAL_MIN_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_3_TERMINAL_BALANCE_MIN,
        terminalSellInstantFrom: COMMODITY_LVL_3_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_3_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_HYDRAULICS]: {
        types: [Types.commodity, Types.lvl4, Types.mechanicalChain],
        batchSizeMin: COMMODITY_LVL_4_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_4_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_4_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_4_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_4_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_4_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_ORGANOID]: {
        types: [Types.commodity, Types.lvl4, Types.biologicalChain],
        batchSizeMin: COMMODITY_LVL_4_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_4_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_4_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_4_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_4_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_4_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_CIRCUIT]: {
        types: [Types.commodity, Types.lvl4, Types.electronicalChain],
        batchSizeMin: COMMODITY_LVL_4_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_4_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_4_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_4_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_4_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_4_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_EMANATION]: {
        types: [Types.commodity, Types.lvl4, Types.mysticalChain],
        batchSizeMin: COMMODITY_LVL_4_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_4_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_4_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_4_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_4_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_4_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_MACHINE]: {
        types: [Types.commodity, Types.lvl5, Types.mechanicalChain],
        batchSizeMin: COMMODITY_LVL_5_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_5_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_5_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_5_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_5_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_5_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_ORGANISM]: {
        types: [Types.commodity, Types.lvl5, Types.biologicalChain],
        batchSizeMin: COMMODITY_LVL_5_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_5_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_5_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_5_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_5_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_5_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_DEVICE]: {
        types: [Types.commodity, Types.lvl5, Types.electronicalChain],
        batchSizeMin: COMMODITY_LVL_5_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_5_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_5_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_5_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_5_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_5_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    },
    [RESOURCE_ESSENCE]: {
        types: [Types.commodity, Types.lvl5, Types.mysticalChain],
        batchSizeMin: COMMODITY_LVL_5_BATCH_MIN,
        storageMaxAmount: COMMODITY_LVL_5_STORAGE_MAX_AMOUNT,
        terminalBalanceMin: COMMODITY_LVL_5_TERMINAL_BALANCE_MIN,
        terminalMinAmount: COMMODITY_LVL_5_TERMINAL_MIN_AMOUNT,
        terminalSellInstantFrom: COMMODITY_LVL_5_TERMINAL_SELL_INSTANT_FROM,
        terminalSellInstantMinAmount: COMMODITY_LVL_5_TERMINAL_SELL_INSTANT_MIN_AMOUNT
    }
};

const CONFIG$M = Config.BaseCenterBalancer;
// const TERMINAL_STRUCTURE_CONFIG = Config.TerminalStructureWorker;
class BaseCenterBalancer {
    static handle() {
        Creeps.getByRole(CONFIG$M.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$M.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        this.moveToCenter(creep);
        this.renewCreep(creep);
        if (creep.idle()) {
            return;
        }
        if (creep.store.getUsedCapacity() === 0) {
            this.withdrawBadBoostsFromLab(creep) ||
                this.withdrawEnergyFromStorageForLab(creep) ||
                this.withdrawBoostsForLab(creep, creep.room.storage) ||
                this.withdrawBoostsForLab(creep, creep.room.terminal) ||
                this.withdrawFromTombstones(creep) ||
                this.withdrawEnergyFromLink(creep) ||
                // this.withdrawEnergyFromTerminal(creep) ||
                this.withdrawFromContainer(creep) ||
                this.withdrawPowerFromStorageForSpawn(creep) ||
                this.withdrawPowerFromTerminalForSpawn(creep) ||
                this.withdrawEnergyFromStorageForSpawns(creep) ||
                this.withdrawEnergyFromStorageForPowerSpawn(creep) ||
                this.withdrawEnergyFromStorageForTerminal(creep) ||
                this.withdrawOverflowingResourcesFromStorage(creep) ||
                this.withdrawResourcesForTerminalFromStorage(creep) ||
                this.withdrawOverflowingResourcesFromTerminalToStorage(creep) ||
                this.withdrawFullTerminal(creep) ||
                this.withdrawFullStorage(creep) ||
                this.goIdle(creep);
        }
        else {
            this.storeBoostToLab(creep) ||
                this.storeEnergyToLab(creep) ||
                this.storeToSpawn(creep) ||
                this.storeEnergyToPowerSpawn(creep) ||
                this.storePowerToPowerSpawn(creep) ||
                this.storeToTerminalMissing(creep) ||
                this.storeToTerminalIfNotMax(creep) ||
                this.storeToStorage(creep) ||
                this.storeEverythingToTerminal(creep) ||
                this.storeEverythingToStorage(creep) ||
                this.dropResources(creep) ||
                this.goIdle(creep);
        }
    }
    static handleSpawn() {
        const creeps = Creeps.getByRole(CONFIG$M.roleName);
        const que = Creeps.queByRole(CONFIG$M.roleName);
        Rooms.myRooms.forEach(room => {
            if (!room.storage && room.centerContainers.length === 0) {
                return;
            }
            if (room.isGclFarm) {
                return;
            }
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.homeRoom) === room.name; }).length > 0) {
                return;
            }
            if (creeps.filter(c => c.memory.homeRoom === room.name).length > 0) {
                return;
            }
            if (!room.center) {
                Log.room(room, "Center flags is not equal to one");
                return;
            }
            Spawns.addToQue(room, {
                body: BodyParts.new().move(1).carry(4),
                optionalBody: room.level >= 6 ? BodyParts.new().carry(16) : BodyParts.new().carry(2),
                priority: CONFIG$M.spawnPriority,
                role: CONFIG$M.roleName,
                directionToCenter: true,
                memory: { stationary: true, homeRoom: room.name }
            });
        });
    }
    static goIdle(creep) {
        if (creep.room.level < 8) {
            return;
        }
        if (creep.room.wasRecentlyUnderAttack) {
            return;
        }
        if (creep.room.hasIncreasedSpawn) {
            return;
        }
        creep.memory.idleUntill = Game.time + 10;
    }
    static storeBoostToLab(creep) {
        if (!creep.room.centerLab) {
            return false;
        }
        if (creep.room.centerLab.mineralType && creep.store.getUsedCapacity(creep.room.centerLab.mineralType) === 0) {
            return false;
        }
        const boost = creep.room.boostsMissing[0];
        if (!boost) {
            return false;
        }
        const amount = Math.min(creep.store.getUsedCapacity(boost.boost), boost.amount - creep.room.centerLab.store[boost.boost]);
        if (amount <= 0) {
            return false;
        }
        creep.transfer(creep.room.centerLab, boost.boost, amount);
        return true;
    }
    static withdrawBoostsForLab(creep, storage) {
        if (!storage) {
            return false;
        }
        if (!creep.room.centerLab) {
            return false;
        }
        const boost = creep.room.boostsMissing[0];
        if (!boost) {
            return false;
        }
        if (creep.room.centerLab.store.getUsedCapacity(boost.boost) >= boost.amount) {
            return false;
        }
        if (storage.store[boost.boost] <= 0) {
            return false;
        }
        const amount = Math.min(storage.store[boost.boost], creep.store.getFreeCapacity(), boost.amount - creep.room.centerLab.store[boost.boost]);
        creep.withdraw(storage, boost.boost, amount);
        return true;
    }
    static withdrawBadBoostsFromLab(creep) {
        if (!creep.room.centerLab) {
            return false;
        }
        if (!creep.room.centerLab.mineralType) {
            return false;
        }
        const boost = creep.room.boostsMissing[0];
        if (!boost) {
            return false;
        }
        if (creep.room.centerLab.mineralType === boost.boost) {
            return false;
        }
        creep.withdraw(creep.room.centerLab, creep.room.centerLab.mineralType);
        return true;
    }
    static storageCanStoreAmount(creep, resource) {
        if (!creep.room.storage) {
            return 0;
        }
        const config = CONFIG_BALANCE[resource];
        return Math.max(0, config.storageMaxAmount - creep.room.storage.store[resource]);
    }
    static storageOverflowAmount(creep, resource) {
        if (!creep.room.storage) {
            return 0;
        }
        const config = CONFIG_BALANCE[resource];
        return Math.max(0, creep.room.storage.store[resource] - config.storageMaxAmount);
    }
    static terminalCanStoreAmount(creep, resource) {
        if (!creep.room.terminal) {
            return 0;
        }
        const config = CONFIG_BALANCE[resource];
        return Math.max(0, config.terminalMinAmount - creep.room.terminal.store[resource]);
    }
    static terminalMustFillAmount(creep, resource) {
        if (!creep.room.terminal) {
            return 0;
        }
        const config = CONFIG_BALANCE[resource];
        return Math.max(0, config.terminalMinAmount - creep.room.terminal.store[resource]);
    }
    static terminalOwerflowAmount(creep, resource) {
        if (!creep.room.terminal) {
            return 0;
        }
        const config = CONFIG_BALANCE[resource];
        return Math.max(0, creep.room.terminal.store[resource] - config.terminalMinAmount);
    }
    static storageHasFreeSpace(creep) {
        var _a;
        return (((_a = creep.room.storage) === null || _a === void 0 ? void 0 : _a.store.getFreeCapacity()) || 0) >= 20000;
    }
    static terminalHasFreeSpace(creep) {
        var _a;
        return (((_a = creep.room.terminal) === null || _a === void 0 ? void 0 : _a.store.getFreeCapacity()) || 0) >= 5000;
    }
    static withdrawFromTombstones(creep) {
        const tombstone = creep.pos.findInRange(FIND_TOMBSTONES, 1).find(t => t.store.getUsedCapacity() > 0);
        if (!tombstone) {
            return false;
        }
        const resource = Resources.firstStoreResource(tombstone.store);
        if (!resource) {
            return false;
        }
        creep.withdraw(tombstone, resource);
        return true;
    }
    static withdrawPowerFromTerminalForSpawn(creep) {
        if (!creep.room.terminal) {
            return false;
        }
        if (!creep.room.myCenterPowerSpawn) {
            return false;
        }
        const amount = creep.room.myCenterPowerSpawn.store.getFreeCapacity(RESOURCE_POWER);
        if (amount < 50) {
            return false;
        }
        if (!creep.room.terminal.store.getUsedCapacity(RESOURCE_POWER)) {
            return false;
        }
        creep.withdraw(creep.room.terminal, RESOURCE_POWER, Math.min(amount, creep.store.getUsedCapacity(RESOURCE_POWER), creep.room.terminal.store.getUsedCapacity(RESOURCE_POWER)));
        return true;
    }
    static withdrawPowerFromStorageForSpawn(creep) {
        if (!creep.room.storage) {
            return false;
        }
        if (!creep.room.myCenterPowerSpawn) {
            return false;
        }
        const amount = creep.room.myCenterPowerSpawn.store.getFreeCapacity(RESOURCE_POWER);
        if (amount < 50) {
            return false;
        }
        if (!creep.room.storage.store.getUsedCapacity(RESOURCE_POWER)) {
            return false;
        }
        creep.withdraw(creep.room.storage, RESOURCE_POWER, Math.min(amount, creep.store.getUsedCapacity(RESOURCE_POWER), creep.room.storage.store.getUsedCapacity(RESOURCE_POWER)));
        return true;
    }
    static withdrawEnergyFromStorageForTerminal(creep) {
        if (!creep.room.storage) {
            return false;
        }
        if (creep.room.storage.store.energy < 1000) {
            return false;
        }
        if (!creep.room.terminal) {
            return false;
        }
        if (!creep.room.terminal.cachedIsActive()) {
            return false;
        }
        if (creep.room.terminal.store.getFreeCapacity(RESOURCE_ENERGY) < 1000) {
            return false;
        }
        const amount = this.terminalMustFillAmount(creep, RESOURCE_ENERGY);
        if (amount < 1000) {
            return false;
        }
        const finalAmount = Math.min(creep.store.getFreeCapacity(RESOURCE_ENERGY), creep.room.terminal.store.getFreeCapacity(RESOURCE_ENERGY), amount);
        if (finalAmount < 500) {
            return false;
        }
        creep.withdraw(creep.room.storage, RESOURCE_ENERGY, finalAmount);
        return true;
    }
    static withdrawEnergyFromStorageForPowerSpawn(creep) {
        if (!creep.room.storage) {
            return false;
        }
        if (!creep.room.myCenterPowerSpawn) {
            return false;
        }
        const amount = creep.room.myCenterPowerSpawn.store.getFreeCapacity(RESOURCE_ENERGY);
        if (amount < 1000) {
            return false;
        }
        const finalAmount = Math.min(creep.store.getFreeCapacity(RESOURCE_ENERGY), amount);
        creep.withdraw(creep.room.storage, RESOURCE_ENERGY, finalAmount);
        return true;
    }
    static withdrawEnergyFromStorageForLab(creep) {
        if (!creep.room.storage) {
            return false;
        }
        if (!creep.room.centerLab) {
            return false;
        }
        if (creep.room.storage.store.energy < 1000) {
            return false;
        }
        if (creep.room.centerLab.store.energy >= LAB_ENERGY_CAPACITY / 2) {
            return false;
        }
        const finalAmount = Math.min(creep.store.getFreeCapacity(RESOURCE_ENERGY), creep.room.centerLab.store.getFreeCapacity(RESOURCE_ENERGY));
        creep.withdraw(creep.room.storage, RESOURCE_ENERGY, finalAmount);
        return true;
    }
    static withdrawEnergyFromStorageForSpawns(creep) {
        if (!creep.room.storage) {
            return false;
        }
        if (creep.room.storage.store.energy === 0) {
            return false;
        }
        const amount = creep.room
            .find(FIND_MY_SPAWNS)
            .reduce((carry, spawn) => carry + spawn.store.getFreeCapacity(RESOURCE_ENERGY), 0);
        if (amount < 250) {
            return false;
        }
        const finalAmount = Math.min(creep.store.getFreeCapacity(RESOURCE_ENERGY), amount);
        creep.withdraw(creep.room.storage, RESOURCE_ENERGY, finalAmount);
        return true;
    }
    static storeToTerminalMissing(creep) {
        if (!creep.room.terminal) {
            return false;
        }
        if (!this.terminalHasFreeSpace(creep)) {
            return false;
        }
        const resource = Resources.firstStoreResource(creep.store);
        if (!resource) {
            return false;
        }
        const amount = this.terminalMustFillAmount(creep, resource);
        if (amount === 0) {
            return false;
        }
        creep.transfer(creep.room.terminal, resource);
        return true;
    }
    static storeToTerminalIfNotMax(creep) {
        if (!creep.room.terminal) {
            return false;
        }
        if (!this.terminalHasFreeSpace(creep)) {
            return false;
        }
        // if (this.terminal.store.getFreeCapacity() < 5_000) return false;
        const resource = Resources.firstStoreResource(creep.store);
        if (!resource) {
            return false;
        }
        if (!this.terminalCanStoreAmount(creep, resource)) {
            return false;
        }
        creep.transfer(creep.room.terminal, resource);
        return true;
    }
    static storeEverythingToTerminal(creep) {
        if (!creep.room.terminal) {
            return false;
        }
        if (!this.terminalHasFreeSpace(creep)) {
            return false;
        }
        // if (this.terminal.store.getFreeCapacity() < 5_000) return false;
        const resource = Resources.firstStoreResource(creep.store);
        if (!resource) {
            return false;
        }
        creep.transfer(creep.room.terminal, resource);
        return true;
    }
    static dropResources(creep) {
        const resource = Resources.firstStoreResource(creep.store);
        if (!resource) {
            return false;
        }
        creep.drop(resource);
        return true;
    }
    static storeEverythingToStorage(creep) {
        if (!creep.room.storage) {
            return false;
        }
        if (!this.storageHasFreeSpace(creep)) {
            return false;
        }
        // if (this.terminal.store.getFreeCapacity() < 5_000) return false;
        const resource = Resources.firstStoreResource(creep.store);
        if (!resource) {
            return false;
        }
        creep.transfer(creep.room.storage, resource);
        return true;
    }
    static storeToStorage(creep) {
        if (!creep.room.storage) {
            return false;
        }
        if (!this.storageHasFreeSpace(creep)) {
            return false;
        }
        for (const resourceString in creep.store) {
            const resource = resourceString;
            const amount = this.storageCanStoreAmount(creep, resource);
            if (amount === 0) {
                continue;
            }
            const actualAmount = Math.min(creep.store.getUsedCapacity(resource), amount);
            creep.transfer(creep.room.storage, resource, actualAmount);
            return true;
        }
        return false;
    }
    static storeEnergyToPowerSpawn(creep) {
        if (creep.store[RESOURCE_ENERGY] === 0) {
            return false;
        }
        if (!creep.room.myCenterPowerSpawn) {
            return false;
        }
        if (creep.room.myCenterPowerSpawn.store.getFreeCapacity(RESOURCE_ENERGY) < 300) {
            return false;
        }
        const finalAmount = Math.min(creep.store[RESOURCE_ENERGY], creep.room.myCenterPowerSpawn.store.getFreeCapacity(RESOURCE_ENERGY));
        creep.transfer(creep.room.myCenterPowerSpawn, RESOURCE_ENERGY, finalAmount);
        return true;
    }
    static storePowerToPowerSpawn(creep) {
        if (creep.store[RESOURCE_POWER] === 0) {
            return false;
        }
        if (!creep.room.myCenterPowerSpawn) {
            return false;
        }
        if (creep.room.myCenterPowerSpawn.store.getFreeCapacity(RESOURCE_POWER) < 50) {
            return false;
        }
        const finalAmount = Math.min(creep.store[RESOURCE_POWER], creep.room.myCenterPowerSpawn.store.getFreeCapacity(RESOURCE_POWER));
        creep.transfer(creep.room.myCenterPowerSpawn, RESOURCE_POWER, finalAmount);
        return true;
    }
    static storeEnergyToLab(creep) {
        if (creep.store.energy === 0) {
            return false;
        }
        if (!creep.room.centerLab) {
            return false;
        }
        if (creep.room.centerLab.store.energy > LAB_ENERGY_CAPACITY / 2) {
            return false;
        }
        creep.transfer(creep.room.centerLab, RESOURCE_ENERGY);
        return true;
    }
    static storeToSpawn(creep) {
        if (creep.store.energy === 0) {
            return false;
        }
        const spawn = creep.room
            .find(FIND_MY_SPAWNS)
            .filter(s => s.store.getFreeCapacity(RESOURCE_ENERGY) >= 150 && s.cachedIsActive())
            .sort((a, b) => a.store.energy - b.store.energy)[0];
        if (!spawn) {
            return false;
        }
        creep.transfer(spawn, RESOURCE_ENERGY);
        return true;
    }
    static withdrawFullTerminal(creep) {
        if (!creep.room.terminal) {
            return false;
        }
        if (this.terminalHasFreeSpace(creep)) {
            return false;
        }
        const resources = Object.entries(Resources.resourceValues)
            .sort((a, b) => a[1] - b[1])
            .map(r => r[0]);
        for (const resource of resources) {
            const overflowingAmount = this.terminalOwerflowAmount(creep, resource);
            if (!overflowingAmount) {
                continue;
            }
            if (creep.room.terminal.store.getUsedCapacity(resource) < overflowingAmount) {
                continue;
            }
            creep.withdraw(creep.room.terminal, resource);
            return true;
        }
        return false;
    }
    static withdrawFullStorage(creep) {
        if (!creep.room.storage) {
            return false;
        }
        if (this.storageHasFreeSpace(creep)) {
            return false;
        }
        const resources = Object.entries(Resources.resourceValues)
            .sort((a, b) => a[1] - b[1])
            .map(r => r[0]);
        for (const resource of resources) {
            const overflowingAmount = this.terminalOwerflowAmount(creep, resource);
            if (!overflowingAmount) {
                continue;
            }
            if (creep.room.storage.store.getUsedCapacity(resource) < overflowingAmount) {
                continue;
            }
            creep.withdraw(creep.room.storage, resource);
            return true;
        }
        return false;
    }
    static withdrawOverflowingResourcesFromTerminalToStorage(creep) {
        if (!creep.room.storage) {
            return false;
        }
        if (!creep.room.terminal) {
            return false;
        }
        if (!this.storageHasFreeSpace(creep)) {
            return false;
        }
        for (const resource in creep.room.terminal.store) {
            const amount = Math.min(this.storageCanStoreAmount(creep, resource), this.terminalOwerflowAmount(creep, resource));
            if (amount === 0) {
                continue;
            }
            creep.withdraw(creep.room.terminal, resource, Math.min(amount, creep.store.getFreeCapacity(resource)));
            return true;
        }
        return false;
    }
    static withdrawResourcesForTerminalFromStorage(creep) {
        if (!creep.room.storage) {
            return false;
        }
        if (!creep.room.terminal) {
            return false;
        }
        if (!this.terminalHasFreeSpace(creep)) {
            return false;
        }
        for (const resource in creep.room.storage.store) {
            const amount = Math.min(creep.room.storage.store[resource], this.terminalMustFillAmount(creep, resource));
            if (amount === 0) {
                continue;
            }
            creep.withdraw(creep.room.storage, resource, Math.min(amount, creep.store.getFreeCapacity(resource)));
            return true;
        }
        return false;
    }
    static withdrawOverflowingResourcesFromStorage(creep) {
        if (!creep.room.storage) {
            return false;
        }
        if (!creep.room.terminal) {
            return false;
        }
        if (!this.terminalHasFreeSpace(creep)) {
            return false;
        }
        for (const resource in creep.room.storage.store) {
            const amount = this.storageOverflowAmount(creep, resource);
            if (amount === 0) {
                continue;
            }
            creep.withdraw(creep.room.storage, resource, Math.min(amount, creep.store.getFreeCapacity(resource)));
            return true;
        }
        return false;
    }
    static withdrawEnergyFromTerminal(creep) {
        if (!creep.room.terminal) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        const config = CONFIG_BALANCE[RESOURCE_ENERGY];
        if (creep.room.terminal.store[RESOURCE_ENERGY] <= config.terminalMinAmount) {
            return false;
        }
        if (creep.room.storage.store.getFreeCapacity() < 1000) {
            return false;
        }
        const amount = Math.min(creep.room.terminal.store.energy - config.terminalMinAmount, creep.store.getFreeCapacity());
        if (amount <= 0) {
            return false;
        }
        creep.withdraw(creep.room.terminal, RESOURCE_ENERGY, amount);
        return true;
    }
    static withdrawFromContainer(creep) {
        const container = creep.room.centerContainers.find(s => s.store.getUsedCapacity() > 0);
        if (!container) {
            return false;
        }
        const resource = Resources.firstStoreResource(container.store);
        if (!resource) {
            return false;
        }
        creep.withdraw(container, resource);
        return true;
    }
    static moveToCenter(creep) {
        const center = General.expansionWithSupport() && creep.room.level < 7
            ? creep.room.centerLeveling || creep.room.center
            : creep.room.center;
        if (!center) {
            return false;
        }
        if (creep.pos.isEqualTo(center)) {
            return false;
        }
        const blockingCreep = center.lookFor(LOOK_CREEPS)[0];
        if (blockingCreep) {
            blockingCreep.moveTo(creep);
        }
        creep.moveTo(center, { ignoreCreeps: true });
        return true;
    }
    static withdrawEnergyFromLink(creep) {
        if (creep.room.centerLinks.length === 0) {
            return false;
        }
        const link = creep.room.centerLinks.find(l => l.store.energy > 0);
        if (!link) {
            return false;
        }
        creep.withdraw(link, RESOURCE_ENERGY);
        return true;
    }
    static renewCreep(creep) {
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > 1300) {
            return false;
        }
        if (creep.store.getCapacity() < 1000) {
            return false;
        }
        const spawns = creep.room
            .find(FIND_MY_SPAWNS)
            .filter(s => s.spawning === null && !s.actionPending && s.store.energy >= 100 && s.cachedIsActive());
        if (spawns.length === 0) {
            return false;
        }
        for (const spawn of spawns) {
            if (spawn.renewCreepV2(creep)) {
                return true;
            }
        }
        return false;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseCenterBalancer, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseCenterBalancer, "handleSpawn", null);

const CONFIG$L = Config.BaseEnergyBalancer;
class BaseEnergyBalancer {
    static handle() {
        Creeps.getByRole(CONFIG$L.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$L.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        if (creep.idle()) {
            return;
        }
        if (creep.store.getUsedCapacity() === 0) {
            this.pick(creep);
        }
        else {
            this.store(creep);
        }
    }
    static handleSpawn() {
        const creeps = Creeps.getByRole(CONFIG$L.roleName);
        const que = Creeps.queByRole(CONFIG$L.roleName);
        Rooms.myRooms.forEach(room => {
            var _a;
            if (room.energyCapacityAvailable <= 300) {
                return;
            }
            if (!room.storage && room.centerContainers.length === 0) {
                return;
            }
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.homeRoom) === room.name; }).length > 0) {
                return;
            }
            const aliveRoomCreeps = creeps.filter(c => (!c.ticksToLive || c.ticksToLive > 600) && c.memory.homeRoom === room.name);
            if (aliveRoomCreeps.length >= this.expectedCreepCountInRoom(room, aliveRoomCreeps)) {
                return;
            }
            Spawns.addToQue(room, {
                body: BodyParts.new().move(1).carry(2),
                optionalBody: BodyParts.new().addMultiple([MOVE, CARRY, CARRY], (((_a = room.controller) === null || _a === void 0 ? void 0 : _a.level) || 1) * 3),
                priority: CONFIG$L.spawnPriority,
                role: CONFIG$L.roleName,
                memory: {
                    homeRoom: room.name
                }
            });
        });
    }
    static findSpawn(creep) {
        if (creep.room.level >= 5) {
            return null;
        }
        return creep.pos.findClosestByRange(FIND_MY_SPAWNS, {
            filter: s => {
                if (s.store.getFreeCapacity(RESOURCE_ENERGY) <= 0) {
                    return false;
                }
                const creepsWithIntents = s.room.find(FIND_MY_CREEPS, {
                    filter: c => c.memory.targetId === s.id && c.memory.role === CONFIG$L.roleName
                });
                if (creepsWithIntents.length > 0) {
                    return false;
                }
                return true;
            }
        });
    }
    static findExtension(creep) {
        return (creep.room.myExtensions
            .filter(s => {
            if (s.store.getFreeCapacity(RESOURCE_ENERGY) <= 0) {
                return false;
            }
            const creepsWithIntents = s.room.find(FIND_MY_CREEPS, {
                filter: c => c.memory.targetId === s.id && c.memory.role === CONFIG$L.roleName
            });
            if (creepsWithIntents.length > 0) {
                return false;
            }
            const creepsInMele = s.pos.findInRange(FIND_MY_CREEPS, 1, {
                filter: c => c.memory.role === CONFIG$L.roleName && c.id !== creep.id
            });
            return creepsInMele.length <= 0 || creep.pos.getRangeTo(s) <= 1;
        })
            .sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0] || null);
    }
    static findTower(creep) {
        return creep.room.myTowers.find(s => s.store.getFreeCapacity(RESOURCE_ENERGY) > 500) || null;
    }
    static findLab(creep) {
        return creep.pos.findClosestByRange(FIND_MY_STRUCTURES, {
            filter: s => {
                if (s.structureType === STRUCTURE_LAB) {
                    if (s.store.getFreeCapacity(RESOURCE_ENERGY) <= 0) {
                        return false;
                    }
                    const creepsWithIntents = s.room.find(FIND_MY_CREEPS, {
                        filter: c => c.memory.targetId === s.id && c.memory.role === CONFIG$L.roleName
                    });
                    return creepsWithIntents.length <= 0;
                }
                return false;
            }
        });
    }
    static findNuke(creep) {
        if (!creep.room.storage) {
            return null;
        }
        if (creep.room.storage.store[RESOURCE_ENERGY] < CONFIG$L.spawnMinStorageEnergy) {
            return null;
        }
        return creep.pos.findClosestByRange(FIND_MY_STRUCTURES, {
            filter: s => {
                if (s.structureType === STRUCTURE_NUKER) {
                    return s.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
                }
                return false;
            }
        });
    }
    static findTarget(creep) {
        return (this.findExtension(creep) ||
            this.findTower(creep) ||
            this.findLab(creep) ||
            this.findSpawn(creep) ||
            this.findNuke(creep));
    }
    static setTarget(creep) {
        if (creep.target && "store" in creep.target && creep.target.store.getFreeCapacity(RESOURCE_ENERGY) > 0) {
            return;
        }
        creep.target = this.findTarget(creep) || null;
    }
    static resetTarget(creep) {
        creep.target = null;
    }
    static storeEnergy(creep) {
        if (!(creep.target instanceof StructureExtension) &&
            !(creep.target instanceof StructureTower) &&
            !(creep.target instanceof StructureLab) &&
            !(creep.target instanceof StructureNuker) &&
            !(creep.target instanceof StructureSpawn)) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.target);
        if (distance <= 1) {
            creep.transfer(creep.target, RESOURCE_ENERGY);
        }
        if (distance > 1) {
            creep.travel(creep.target);
        }
        if (distance <= 1) {
            const structureFreeCapacity = (function () {
                if (creep.target instanceof StructureNuker) {
                    return creep.target.store.getFreeCapacity(RESOURCE_ENERGY);
                }
                if (creep.target instanceof StructureLab) {
                    return creep.target.store.getFreeCapacity(RESOURCE_ENERGY);
                }
                if (creep.target instanceof Structure) {
                    return creep.target.store.getFreeCapacity(RESOURCE_ENERGY);
                }
                return 0;
            })();
            if (structureFreeCapacity >= creep.store[RESOURCE_ENERGY]) {
                this.moveToPick(creep);
                return true;
            }
            creep.target = this.findTarget(creep) || null;
            if (creep.target) {
                const nextDistance = creep.pos.getRangeTo(creep.target);
                if (nextDistance > 1) {
                    creep.travel(creep.target, { costSwamp: 10, costPlain: 2 });
                }
            }
        }
        return true;
    }
    static moveToPickFromStorage(creep) {
        if (!creep.room.storage) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.storage);
        if (distance > 1) {
            creep.travel(creep.room.storage);
        }
        return true;
    }
    static moveToPickFromTerminal(creep) {
        if (!creep.room.terminal) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.terminal);
        if (distance > 1) {
            creep.travel(creep.room.terminal);
        }
        return true;
    }
    static withdrawEnergyFromTombstones(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (creep.room.wasRecentlyUnderAttack) {
            return false;
        }
        if (!creep.room.center) {
            return false;
        }
        const tombstones = creep.room.center.findInRange(FIND_TOMBSTONES, 4, { filter: t => t.store.energy > 50 })[0];
        if (!tombstones) {
            return false;
        }
        const distance = creep.pos.getRangeTo(tombstones);
        if (distance > 1) {
            creep.travel(tombstones);
        }
        else {
            creep.withdraw(tombstones, RESOURCE_ENERGY);
            this.findNewTargetAndMoveToIt(creep);
        }
        return true;
    }
    static withdrawEnergyFromStorage(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        if (!creep.room.storage.store.energy) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.storage);
        if (distance > 1) {
            creep.travel(creep.room.storage);
        }
        else {
            creep.withdraw(creep.room.storage, RESOURCE_ENERGY);
            this.findNewTargetAndMoveToIt(creep);
        }
        return true;
    }
    static findNewTargetAndMoveToIt(creep) {
        creep.target = this.findTarget(creep) || null;
        if (creep.target) {
            const nextDistance = creep.pos.getRangeTo(creep.target);
            if (nextDistance > 1) {
                creep.travel(creep.target, { costSwamp: 10, costPlain: 2 });
            }
        }
    }
    static withdrawEnergyFromContainer(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (creep.room.centerContainers.length === 0) {
            return false;
        }
        const container = creep.room.centerContainers
            .filter(c => c.store.energy > 0)
            .sort((a, b) => b.store.energy - a.store.energy)[0];
        if (!container) {
            return false;
        }
        const distance = creep.pos.getRangeTo(container);
        if (distance > 1) {
            creep.travel(container);
        }
        else {
            creep.withdraw(container, RESOURCE_ENERGY);
            this.findNewTargetAndMoveToIt(creep);
        }
        return true;
    }
    static withdrawEnergyFromTerminal(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (!creep.room.terminal) {
            return false;
        }
        if (!creep.room.terminal.store.energy) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.terminal);
        if (distance > 1) {
            creep.travel(creep.room.terminal);
        }
        else {
            creep.withdraw(creep.room.terminal, RESOURCE_ENERGY);
            this.findNewTargetAndMoveToIt(creep);
        }
        return true;
    }
    static suicide(creep) {
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > 60) {
            return false;
        }
        this.resetTarget(creep);
        return creep.recycleFinal();
    }
    static moveToPick(creep) {
        this.moveToPickFromStorage(creep) || this.moveToPickFromTerminal(creep);
    }
    static pick(creep) {
        this.suicide(creep) ||
            this.withdrawEnergyFromTombstones(creep) ||
            this.withdrawEnergyFromStorage(creep) ||
            this.withdrawEnergyFromTerminal(creep) ||
            this.withdrawEnergyFromContainer(creep) ||
            this.moveAwayFromStorage(creep);
    }
    static store(creep) {
        this.setTarget(creep);
        if (!creep.target) {
            creep.memory.idleUntill = Game.time + 10;
            this.moveAwayFromStorage(creep);
            return;
        }
        this.suicide(creep) || this.storeEnergy(creep) || this.moveAwayFromStorage(creep);
    }
    static moveAwayFromStorage(creep) {
        return creep.idleAwayFrom([STRUCTURE_STORAGE, STRUCTURE_TERMINAL], 3);
    }
    static expectedCreepCountInRoom(room, creeps) {
        switch (room.level) {
            case 0:
                return 1;
            case 1:
                return 1;
            case 2:
                return 1;
            case 3:
                return 1;
            case 4:
                return 1;
            case 5:
                if (room.isSiegeBase) {
                    return 2;
                }
                return 1;
            case 6:
                if (room.isSiegeBase) {
                    return 2;
                }
                return 1;
            case 7:
                if (room.isSiegeBase) {
                    return 2;
                }
                return 2;
            case 8: {
                const caryCapacity = creeps.reduce((total, creep) => total + creep.store.getCapacity(), 0);
                if (caryCapacity < 500) {
                    return creeps.length + 1;
                }
                if (room.isSiegeBase) {
                    return 2;
                }
                if (room.wasRecentlyUnderAttack) {
                    return 2;
                }
                if (room.mem.increasedSpawnUntil) {
                    return 2;
                }
                return 1;
            }
            default:
                return 1;
        }
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseEnergyBalancer, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseEnergyBalancer, "handleSpawn", null);

var Action$2;
(function (Action) {
    Action["PICKUP"] = "pickup";
    Action["UNLOAD"] = "unload";
})(Action$2 || (Action$2 = {}));
const CONFIG$K = Config.BaseLabBalancer;
class BaseLabBalancer {
    static handle() {
        Creeps.getByRole(CONFIG$K.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$K.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        if (creep.idle()) {
            return;
        }
        if (this.suicide(creep)) {
            return;
        }
        this.handleAction(creep);
        switch (creep.memory.action) {
            case Action$2.PICKUP:
                this.pickup(creep);
                return;
            case Action$2.UNLOAD:
                this.unload(creep);
        }
    }
    static pickup(creep) {
        this.pickDroppedBoosts(creep) ||
            this.followBoostedRecyclingCreep(creep) ||
            this.pickFromTombstone(creep) ||
            this.pickFromLabContainer(creep) ||
            this.withdrawAllResourcesWhenNoReaction(creep) ||
            this.withdrawAllResourcesFromFactoryWhenAbandoning(creep) ||
            this.withdrawAllResourcesFromStorageWhenAbandoning(creep) ||
            this.withdrawBadOutputTypeFromLab(creep) ||
            this.withdrawBadInputResourcesFromLab(creep) ||
            this.withdrawInputResourcesFromStorage(creep) ||
            this.withdrawInputResourcesFromTerminal(creep) ||
            this.withdrawInputResourcesFromFactory(creep) ||
            this.withdrawOutputFromLab(creep) ||
            this.goIdle(creep) ||
            this.setAction(creep, Action$2.UNLOAD);
    }
    static unload(creep) {
        this.storeInputResourcesToLab(creep) ||
            this.storeResourcesToTerminal(creep) ||
            this.storeResourcesToStorage(creep) ||
            this.goIdle(creep);
    }
    static handleSpawn() {
        const creeps = Creeps.getByRole(CONFIG$K.roleName);
        const que = Creeps.queByRole(CONFIG$K.roleName);
        Rooms.myRooms.forEach(room => {
            if (room.level < 8) {
                return;
            }
            if (room.labs.length > 3) {
                if (!room.terminal) {
                    return;
                }
                if (!room.storage) {
                    return;
                }
                if (!room.controller) {
                    return;
                }
                if (room.wasRecentlyUnderAttack) {
                    return;
                }
                if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.homeRoom) === room.name; }).length > 0) {
                    return;
                }
                if (creeps.filter(c => c.memory.homeRoom === room.name).length > 0) {
                    return;
                }
                Spawns.addToQue(room, {
                    body: new BodyParts().move(1).carry(2),
                    optionalBody: new BodyParts().addMultiple([MOVE, CARRY, CARRY], 4),
                    priority: CONFIG$K.spawnPriority,
                    role: CONFIG$K.roleName,
                    memory: { homeRoom: room.name }
                });
            }
            else {
                if (!room.storage) {
                    return;
                }
                const tombstones = room
                    .find(FIND_TOMBSTONES)
                    .filter(t => Object.keys(t.store).filter(s => RESOURCE_BOOSTS.includes(s)).length > 0);
                if (tombstones.length === 0) {
                    return;
                }
                if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.homeRoom) === room.name; }).length > 0) {
                    return;
                }
                if (creeps.filter(c => c.memory.homeRoom === room.name && (!c.ticksToLive || c.ticksToLive > 400)).length > 0) {
                    return;
                }
                Spawns.addToQue(room, {
                    body: new BodyParts().move(1).carry(2),
                    priority: CONFIG$K.spawnPriority,
                    role: CONFIG$K.roleName,
                    memory: { homeRoom: room.name }
                });
            }
        });
    }
    static goIdle(creep) {
        if (creep.store.getUsedCapacity() > 0) {
            return;
        }
        creep.memory.idleUntill =
            Game.time + (creep.room.mem.labOutputResource ? REACTION_TIME[creep.room.mem.labOutputResource] : 50);
    }
    static followBoostedRecyclingCreep(creep) {
        const recyclingCreep = creep.pos.findClosestByRange(FIND_MY_CREEPS, {
            filter: c => c.memory.recycling && c.body.filter(b => b.boost).length > 0
        });
        if (!recyclingCreep) {
            return false;
        }
        creep.say("🙏");
        creep.travel(recyclingCreep);
        return true;
    }
    static handleAction(creep) {
        if (!creep.memory.action) {
            creep.memory.action = creep.store.getUsedCapacity() > 0 ? Action$2.UNLOAD : Action$2.PICKUP;
        }
        else if (creep.memory.action === Action$2.UNLOAD && creep.store.getUsedCapacity() === 0) {
            creep.memory.action = Action$2.PICKUP;
        }
        else if (creep.memory.action === Action$2.PICKUP && creep.store.getFreeCapacity() === 0) {
            creep.memory.action = Action$2.UNLOAD;
        }
    }
    static setAction(creep, action) {
        creep.memory.action = action;
    }
    static pickFromLabContainer(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        const container = creep.pos.findClosestByRange(FIND_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_CONTAINER &&
                s.store.getUsedCapacity() > 0 &&
                s.pos.findInRange(FIND_MY_STRUCTURES, 1, { filter: fs => fs.structureType === STRUCTURE_LAB }).length > 0
        });
        if (!container) {
            return false;
        }
        const resource = Resources.firstStoreResource(container.store);
        if (!resource) {
            return false;
        }
        const distance = creep.pos.getRangeTo(container);
        if (distance > 1) {
            creep.travel(container);
        }
        else {
            creep.withdraw(container, resource);
        }
        return true;
    }
    static pickFromTombstone(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        const tombstone = creep.pos.findClosestByRange(FIND_TOMBSTONES, {
            filter: t => !!Resources.firstStoreResource(t.store, { except: [RESOURCE_ENERGY] })
        });
        if (!tombstone) {
            return false;
        }
        if (creep.room.wasRecentlyUnderAttack && tombstone.pos.inRangeToEdge(4)) {
            return false;
        }
        const resource = Resources.firstStoreResource(tombstone.store, { except: [RESOURCE_ENERGY] });
        if (!resource) {
            return false;
        }
        const distance = creep.pos.getRangeTo(tombstone);
        if (distance > 1) {
            creep.travel(tombstone);
        }
        else {
            creep.withdraw(tombstone, resource);
        }
        return true;
    }
    static pickDroppedBoosts(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        const resource = creep.room.find(FIND_DROPPED_RESOURCES)[0];
        if (!resource) {
            return false;
        }
        if (creep.room.wasRecentlyUnderAttack && resource.pos.inRangeToEdge(4)) {
            return false;
        }
        if (creep.pickup(resource) === ERR_NOT_IN_RANGE) {
            creep.travel(resource);
        }
        return true;
    }
    static withdrawMissingFactoryResourcesFromStorage(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (!creep.room.factory) {
            return false;
        }
        if (!creep.room.terminal) {
            return false;
        }
        for (const resource in CONFIG_BALANCE) {
            const resourceConfig = CONFIG_BALANCE[resource];
            if (!resourceConfig.factory) {
                continue;
            }
            if (creep.room.factory.store[resource] >= resourceConfig.factory.amount) {
                continue;
            }
            const missingAmount = resourceConfig.factory.amount - creep.room.factory.store[resource];
            if (missingAmount <= 0) {
                continue;
            }
            if (creep.room.terminal.store[resource] < missingAmount) {
                continue;
            }
            if (creep.withdraw(creep.room.terminal, resource, missingAmount) === ERR_NOT_IN_RANGE) {
                creep.travel(creep.room.terminal);
            }
            return true;
        }
        return false;
    }
    static withdrawOutputFromLab(creep, ignoreId) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (creep.room.labOutputs.length === 0) {
            return false;
        }
        const closestLabs = creep.room.labOutputs
            .filter(l => (ignoreId && l.id !== ignoreId) || !ignoreId)
            .sort((a, b) => creep.pos.getRangeTo(a) - creep.pos.getRangeTo(b));
        for (const lab of closestLabs) {
            if (!lab.mineralType) {
                continue;
            }
            if (lab.store.getUsedCapacity(lab.mineralType) < 100 && creep.store.getUsedCapacity() === 0) {
                continue;
            }
            if (lab.store.getUsedCapacity(lab.mineralType) < 80 && creep.store.getUsedCapacity() !== 0) {
                continue;
            }
            if (creep.withdraw(lab, lab.mineralType) === ERR_NOT_IN_RANGE) {
                creep.travel(lab);
            }
            return true;
        }
        return false;
    }
    static withdrawAllResourcesWhenNoReaction(creep) {
        var _a;
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (creep.room.mem.labOutputResource) {
            return false;
        }
        if (creep.room.labOutputs.length + creep.room.labInputs.length === 0) {
            return false;
        }
        const closestLabs = [...creep.room.labOutputs, ...creep.room.labInputs].sort((a, b) => creep.pos.getRangeTo(a) - creep.pos.getRangeTo(b));
        for (const lab of closestLabs) {
            if (lab.id === ((_a = creep.room.centerLab) === null || _a === void 0 ? void 0 : _a.id)) {
                continue;
            }
            if (!lab.mineralType) {
                continue;
            }
            if (creep.withdraw(lab, lab.mineralType) === ERR_NOT_IN_RANGE) {
                creep.travel(lab);
            }
            return true;
        }
        return false;
    }
    static withdrawAllResourcesFromStorageWhenAbandoning(creep) {
        if (!creep.room.isAbandoning) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        if (!creep.room.terminal) {
            return false;
        }
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        const resource = Object.keys(creep.room.storage.store).find(r => r !== RESOURCE_ENERGY);
        if (!resource) {
            return false;
        }
        if (creep.withdraw(creep.room.storage, resource) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.room.storage);
        }
        return true;
    }
    static withdrawAllResourcesFromFactoryWhenAbandoning(creep) {
        if (!creep.room.isAbandoning) {
            return false;
        }
        if (!creep.room.factory) {
            return false;
        }
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        const resource = Resources.firstStoreResource(creep.room.factory.store);
        if (!resource) {
            return false;
        }
        if (creep.withdraw(creep.room.factory, resource) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.room.factory);
        }
        return true;
    }
    static withdrawBadOutputTypeFromLab(creep) {
        var _a;
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (creep.room.labOutputs.length === 0) {
            return false;
        }
        if (!creep.room.mem.labOutputResource) {
            return false;
        }
        const closestLabs = creep.room.labOutputs.sort((a, b) => creep.pos.getRangeTo(a) - creep.pos.getRangeTo(b));
        for (const lab of closestLabs) {
            if (lab.id === ((_a = creep.room.centerLab) === null || _a === void 0 ? void 0 : _a.id)) {
                continue;
            }
            if (!lab.mineralType) {
                continue;
            }
            if (lab.mineralType === creep.room.mem.labOutputResource) {
                continue;
            }
            if (creep.withdraw(lab, lab.mineralType) === ERR_NOT_IN_RANGE) {
                creep.travel(lab);
            }
            return true;
        }
        return false;
    }
    static inputNeedsResource(lab) {
        if (!lab.mineralType) {
            return true;
        }
        return lab.store.getUsedCapacity(lab.mineralType) < LAB_MINERAL_CAPACITY * 0.7;
    }
    static storeInputResourcesToLab(creep) {
        if (creep.room.level < 8) {
            return false;
        }
        if (creep.store.getUsedCapacity() === 0) {
            return false;
        }
        if (!creep.room.mem.labOutputResource) {
            return false;
        }
        const inputResources = BOOST_REACTIONS[creep.room.mem.labOutputResource];
        if (!inputResources || inputResources.length !== 2) {
            return false;
        }
        for (let i = 0; i < creep.room.labInputs.length; i++) {
            const lab = creep.room.labInputs[i];
            if (!lab) {
                continue;
            }
            const currentInputResource = inputResources[i];
            if (!currentInputResource) {
                continue;
            }
            if (lab.mineralType && lab.mineralType !== currentInputResource) {
                continue;
            }
            if (!this.inputNeedsResource(lab)) {
                continue;
            }
            if (creep.store[currentInputResource] < LAB_REACTION_AMOUNT) {
                continue;
            }
            if (creep.transfer(lab, currentInputResource) === ERR_NOT_IN_RANGE) {
                creep.travel(lab);
            }
            return true;
        }
        return false;
    }
    static withdrawInputResourcesFromTerminal(creep) {
        if (creep.room.level < 8) {
            return false;
        }
        if (!creep.room.terminal) {
            return false;
        }
        if (creep.store.getUsedCapacity() > 0) {
            return false;
        }
        if (!creep.room.mem.labOutputResource) {
            return false;
        }
        if (creep.room.labInputs.length !== 2) {
            return false;
        }
        const inputResources = BOOST_REACTIONS[creep.room.mem.labOutputResource];
        if (!inputResources || inputResources.length !== 2) {
            return false;
        }
        for (let i = 0; i < creep.room.labInputs.length; i++) {
            const lab = creep.room.labInputs[i];
            if (!lab) {
                continue;
            }
            const currentInputResource = inputResources[i];
            if (!currentInputResource) {
                continue;
            }
            if (lab.mineralType && lab.mineralType !== currentInputResource) {
                continue;
            }
            if (!this.inputNeedsResource(lab)) {
                continue;
            }
            if (creep.room.terminal.store[currentInputResource] < LAB_REACTION_AMOUNT) {
                continue;
            }
            if (creep.withdraw(creep.room.terminal, currentInputResource) === ERR_NOT_IN_RANGE) {
                creep.travel(creep.room.terminal);
            }
            return true;
        }
        return false;
    }
    static withdrawInputResourcesFromFactory(creep) {
        if (creep.room.level < 8) {
            return false;
        }
        if (!creep.room.factory) {
            return false;
        }
        if (creep.store.getUsedCapacity() > 0) {
            return false;
        }
        if (!creep.room.mem.labOutputResource) {
            return false;
        }
        if (creep.room.labInputs.length !== 2) {
            return false;
        }
        const inputResources = BOOST_REACTIONS[creep.room.mem.labOutputResource];
        if (!inputResources || inputResources.length !== 2) {
            return false;
        }
        for (let i = 0; i < creep.room.labInputs.length; i++) {
            const lab = creep.room.labInputs[i];
            if (!lab) {
                continue;
            }
            const currentInputResource = inputResources[i];
            if (!currentInputResource) {
                continue;
            }
            if (lab.mineralType && lab.mineralType !== currentInputResource) {
                continue;
            }
            if (!this.inputNeedsResource(lab)) {
                continue;
            }
            if (creep.room.factory.store[currentInputResource] < LAB_REACTION_AMOUNT) {
                continue;
            }
            if (creep.withdraw(creep.room.factory, currentInputResource) === ERR_NOT_IN_RANGE) {
                creep.travel(creep.room.factory);
            }
            return true;
        }
        return false;
    }
    static withdrawInputResourcesFromStorage(creep) {
        if (creep.room.level < 8) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        if (creep.store.getUsedCapacity() > 0) {
            return false;
        }
        if (!creep.room.mem.labOutputResource) {
            return false;
        }
        if (creep.room.labInputs.length !== 2) {
            return false;
        }
        const inputResources = BOOST_REACTIONS[creep.room.mem.labOutputResource];
        if (!inputResources || inputResources.length !== 2) {
            return false;
        }
        for (let i = 0; i < creep.room.labInputs.length; i++) {
            const lab = creep.room.labInputs[i];
            if (!lab) {
                continue;
            }
            const currentInputResource = inputResources[i];
            if (!currentInputResource) {
                continue;
            }
            if (lab.store[currentInputResource] > 300) {
                continue;
            }
            if (lab.mineralType && lab.mineralType !== currentInputResource) {
                continue;
            }
            if (!this.inputNeedsResource(lab)) {
                continue;
            }
            if (creep.room.storage.store[currentInputResource] < LAB_REACTION_AMOUNT) {
                continue;
            }
            if (creep.withdraw(creep.room.storage, currentInputResource) === ERR_NOT_IN_RANGE) {
                creep.travel(creep.room.storage);
            }
            return true;
        }
        return false;
    }
    static withdrawBadInputResourcesFromLab(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (!creep.room.mem.labOutputResource) {
            return false;
        }
        if (creep.room.labInputs.length !== 2) {
            return false;
        }
        const inputResources = BOOST_REACTIONS[creep.room.mem.labOutputResource];
        if (!inputResources || inputResources.length !== 2) {
            return false;
        }
        for (let i = 0; i < creep.room.labInputs.length; i++) {
            const lab = creep.room.labInputs[i];
            if (!lab) {
                continue;
            }
            const currentMineralType = lab.mineralType;
            if (!currentMineralType) {
                continue;
            }
            if (currentMineralType === inputResources[i]) {
                continue;
            }
            if (creep.withdraw(lab, currentMineralType) === ERR_NOT_IN_RANGE) {
                creep.travel(lab);
            }
            return true;
        }
        return false;
    }
    static suicide(creep) {
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > 50) {
            return false;
        }
        if (creep.store.getUsedCapacity() > 0) {
            this.storeResourcesToStorage(creep);
        }
        else {
            creep.die();
        }
        return true;
    }
    static storeResourcesToStorage(creep) {
        if (!creep.room.storage) {
            return false;
        }
        if (creep.store.getUsedCapacity() === 0) {
            return false;
        }
        const resource = Object.keys(creep.store)[0];
        if (!resource) {
            return false;
        }
        if (creep.transfer(creep.room.storage, resource) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.room.storage);
        }
        return true;
    }
    static storeResourcesToTerminal(creep) {
        if (!creep.room.terminal) {
            return false;
        }
        if (creep.store.getUsedCapacity() === 0) {
            return false;
        }
        const resource = Object.keys(creep.store)[0];
        if (!resource) {
            return false;
        }
        if (creep.transfer(creep.room.terminal, resource) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.room.terminal);
        }
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseLabBalancer, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseLabBalancer, "handleSpawn", null);

const CONFIG$J = Config.BaseMineralHauler;
class BaseMineralHauler {
    static handle() {
        Creeps.getByRole(CONFIG$J.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$J.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        creep.recycleFinal(70) ||
            this.suicide(creep) ||
            this.withdrawResourcesFromContainer(creep) ||
            this.storeResourcesToStorage(creep);
    }
    static handleSpawn() {
        Rooms.myRooms.forEach(room => {
            room.find(FIND_MINERALS).forEach(mineral => {
                var _a;
                if (!mineral || mineral.mineralAmount === 0) {
                    return;
                }
                if (!room.terminal) {
                    return;
                }
                if (mineral.containers.length === 0) {
                    return;
                }
                if (mineral.containers.filter(c => c.store.getUsedCapacity() > 200).length === 0) {
                    return;
                }
                if (room.wasRecentlyUnderAttack) {
                    return;
                }
                const creepsCount = Creeps.creepsCountWithQue({
                    minTicksToLive: 100,
                    mineralId: mineral.id,
                    role: CONFIG$J.roleName
                });
                if (creepsCount >= Math.max(Math.floor(mineral.containers.length / 2), 1)) {
                    return;
                }
                const controllerLevel = (_a = room.controller) === null || _a === void 0 ? void 0 : _a.level;
                if (!controllerLevel) {
                    return;
                }
                Spawns.addToQue(room, {
                    body: BodyParts.new().move(5).carry(5),
                    optionalBody: BodyParts.new().addMultiple([MOVE, CARRY], 20),
                    priority: CONFIG$J.spawnPriority,
                    role: CONFIG$J.roleName,
                    memory: {
                        mineralId: mineral.id
                    }
                });
            });
        });
    }
    static storeResourcesToStorage(creep) {
        if (creep.store.getUsedCapacity() === 0) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        const resource = Resources.firstStoreResource(creep.store);
        if (!resource) {
            return false;
        }
        if (creep.transfer(creep.room.storage, resource) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.room.storage);
        }
        return true;
    }
    static suicide(creep) {
        if (!creep.mineral) {
            return false;
        }
        if (creep.mineral.mineralAmount > 0) {
            return false;
        }
        if (creep.mineral.containers.filter(c => c.store.getUsedCapacity() > 200).length > 0) {
            return false;
        }
        return creep.recycleFinal(1400);
    }
    static withdrawResourcesFromContainer(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (!creep.mineral) {
            return false;
        }
        if (creep.mineral.containers.length === 0) {
            return false;
        }
        const fulliestContainer = creep.mineral.containers
            .filter(c => c.store.getUsedCapacity() >= 200)
            .sort((a, b) => b.store.getUsedCapacity() - a.store.getUsedCapacity())[0];
        if (!fulliestContainer) {
            return false;
        }
        const resource = Resources.firstStoreResource(fulliestContainer.store);
        if (!resource) {
            return false;
        }
        if (creep.withdraw(fulliestContainer, resource) === ERR_NOT_IN_RANGE) {
            creep.travel(fulliestContainer);
        }
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseMineralHauler, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseMineralHauler, "handleSpawn", null);

const CONFIG$I = Config.BaseMineralMiner;
class BaseMineralMiner {
    static handle() {
        Creeps.getByRole(CONFIG$I.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$I.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        // constructRoads(creep);
        this.suicide(creep) || this.moveOnToContainer(creep) || this.harvest(creep);
    }
    static handleSpawn() {
        Rooms.myRooms.forEach(room => {
            room.find(FIND_MINERALS).forEach(mineral => {
                if (!room.terminal) {
                    return;
                }
                if (!room.storage) {
                    return;
                }
                if (mineral.containers.length === 0) {
                    return;
                }
                if (!room.controller) {
                    return;
                }
                if (room.controller.level < 6) {
                    return;
                }
                const resourceConfig = CONFIG_BALANCE[mineral.mineralType];
                if (room.terminal.store.getUsedCapacity(mineral.mineralType) >
                    resourceConfig.terminalSellInstantFrom + resourceConfig.terminalSellInstantMinAmount) {
                    return;
                }
                if (mineral.mineralAmount === 0) {
                    return;
                }
                const extractor = mineral.extractor();
                if (!extractor) {
                    return;
                }
                const creepsCount = Creeps.creepsCountWithQue({
                    minTicksToLive: 200,
                    mineralId: mineral.id,
                    role: CONFIG$I.roleName
                });
                if (creepsCount >= mineral.containers.length) {
                    return;
                }
                const bodySet = [MOVE, MOVE, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK];
                Spawns.addToQue(room, {
                    body: new BodyParts().addMultiple(bodySet, 1),
                    optionalBody: new BodyParts().addMultiple(bodySet, 4),
                    priority: CONFIG$I.spawnPriority,
                    role: CONFIG$I.roleName,
                    memory: { mineralId: mineral.id, stationary: true }
                });
            });
        });
    }
    static suicide(creep) {
        if (!creep.mineral) {
            return false;
        }
        if (creep.mineral.mineralAmount > 0) {
            return false;
        }
        creep.recycleFinal(1500);
        return true;
    }
    static constructRoads(creep) {
        var _a;
        if (creep.memory.constructionsCreated) {
            return;
        }
        if (!creep.mineral) {
            return;
        }
        if (!((_a = creep.homeRoom) === null || _a === void 0 ? void 0 : _a.storage)) {
            return;
        }
        creep.mineral.pos.createRoadConstructionsFrom(creep.homeRoom.storage.pos);
        creep.memory.constructionsCreated = true;
    }
    static moveOnToContainer(creep) {
        if (!creep.mineral) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.mineral);
        if (distance <= 1) {
            return false;
        }
        const openContainer = creep.mineral.containers.filter(c => !c.pos.hasCreep)[0];
        if (!openContainer) {
            return false;
        }
        creep.travel(openContainer, { range: 0 });
        return true;
    }
    static harvest(creep) {
        if (!creep.mineral) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.mineral);
        if (distance > 1) {
            return false;
        }
        const container = creep.pos
            .lookFor(LOOK_STRUCTURES)
            .find(s => s.structureType === STRUCTURE_CONTAINER);
        if (!container) {
            return false;
        }
        if (container.store.getFreeCapacity() < creep.harvestPower) {
            return false;
        }
        creep.harvest(creep.mineral);
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseMineralMiner, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseMineralMiner, "handleSpawn", null);

const CONFIG$H = Config.BaseNewbie;
const CONFIG_BASE_UPGRADER_HAULER = Config.BaseUpgradeHauler;
const UPGRADE_RAMPARTS_UP_TO = 300000;
class BaseNewbie {
    static handle() {
        Creeps.getByRole(CONFIG$H.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$H.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        if (creep.memory.stationary) {
            return;
        }
        this.clearTarget(creep);
        this.setTarget(creep);
        this.constructRoads(creep);
        if (creep.memory.targetRoom !== creep.memory.homeRoom) {
            if (creep.escapeAnyTargetRoomHostilesToHomeRoom()) {
                return;
            }
        }
        if ((creep.room.name === creep.memory.targetRoom || creep.room.name === creep.memory.homeRoom) && creep.kite()) {
            return;
        }
        // this.buildRoadsAround(creep) ||
        this.repairRoadsAround(creep) || this.repairContainersAround(creep);
        if (creep.hitsMax - creep.hits >= 100 && this.runToHealer(creep)) {
            return;
        }
        // if (creep.ticksToLive && creep.ticksToLive < 1_300 && !creep.isBoosted()) {
        //   const spawn = creep.pos.findInRange(FIND_MY_SPAWNS, 1, { filter: s => s.store.energy > 100 })[0];
        //
        //   if (spawn) {
        //     spawn.renewCreepV2(creep);
        //   }
        // }
        if (creep.store.getUsedCapacity() === 0 &&
            creep.room.my &&
            creep.room.level >= 8 &&
            creep.room.storage &&
            creep.room.storage.store.energy > 50000) {
            this.withdrawEnergyFromStorage(creep, creep.room.storage);
        }
        else if (creep.target instanceof StructureSpawn) {
            this.storeEnergyTo(creep, creep.target);
        }
        else if (creep.target instanceof ConstructionSite) {
            this.buildStructure(creep, creep.target);
        }
        else if (creep.target instanceof StructureTower) {
            this.storeEnergyTo(creep, creep.target);
        }
        else if (creep.target instanceof StructureStorage) {
            this.withdrawEnergyFromStorage(creep, creep.target) || this.storeEnergyTo(creep, creep.target);
        }
        else if (creep.target instanceof StructureTerminal) {
            this.withdrawEnergyFromTerminal(creep, creep.target);
        }
        else if (creep.target instanceof StructureExtension) {
            this.storeEnergyTo(creep, creep.target);
        }
        else if (creep.target instanceof StructureController) {
            this.upgradeController(creep, creep.target);
        }
        else if (creep.target instanceof Resource) {
            this.pickResource(creep, creep.target);
        }
        else if (creep.target instanceof Ruin) {
            this.withdrawFromRuin(creep, creep.target);
        }
        else if (creep.target instanceof Source) {
            this.mineSource(creep, creep.target);
        }
        else if (creep.target instanceof Tombstone) {
            this.withdrawEnergyFromTombstone(creep, creep.target);
        }
        else if (creep.target instanceof StructureContainer) {
            this.storeEnergyTo(creep, creep.target);
        }
        else if (creep.target instanceof StructureLink) {
            this.withdrawEnergyFromLink(creep, creep.target);
        }
        else if (creep.target instanceof StructureRampart) {
            this.repairRampart(creep, creep.target);
        }
        else {
            this.moveToTargetRoom(creep);
        }
    }
    static handleSpawn() {
        if (!General.expansionWithSupport()) {
            return;
        }
        Rooms.myRooms.forEach(room => {
            this.spawnSpawnBuilders(room);
        });
    }
    static runToHealer(creep) {
        const healer = creep.room
            .find(FIND_MY_CREEPS, { filter: c => c.healPower })
            .sort((a, b) => b.healPower - a.healPower)[0];
        if (!healer) {
            return false;
        }
        creep.travel(healer);
        return true;
    }
    static spawnSpawnBuilders(room) {
        const que = Creeps.queByRole(CONFIG$H.roleName);
        const creeps = Creeps.getByRole(CONFIG$H.roleName);
        if (room.isGclFarm && room.storage && room.terminal) {
            return;
        }
        if (room.level >= 8 && room.myActiveSpawns.length > 0) {
            return;
        }
        // if (room.level >= 6 && room.labs.length > 0) {
        //   return;
        // }
        //
        // if (room.myActiveSpawns.length > 0 && room.terminal && room.storage && room.labs.length >= 3) {
        //   return;
        // }
        if (room.isAbandoning) {
            return;
        }
        if (!room.center) {
            return;
        }
        room.find(FIND_SOURCES).forEach(source => {
            const spawnRooms = Geo.closestHomeRoomsByRange(room.name, 3, {
                maxDistance: MAX_EXPANSION_RANGE * 1.5,
                room: r => r.level >= 8
            });
            if (spawnRooms.length === 0) {
                return;
            }
            // if (creepsCountWithQue >= (room.mySpawns.length === 0 ? 2 : 4)) {
            //   return;
            // }
            const sourceQue = que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.sourceId) === source.id; });
            const sourceCreep = creeps
                .filter(c => c.memory.sourceId === source.id)
                .filter(c => !c.ticksToLive || c.ticksToLive > 700);
            const maxCreeps = room.level < 6 ? 5 : 6;
            if (sourceQue.length + sourceCreep.length >= maxCreeps) {
                return;
            }
            Spawns.addToQue(spawnRooms, {
                body: BodyParts.new().work(15).carry(10).move(25),
                role: CONFIG$H.roleName,
                priority: CONFIG$H.spawnPriority,
                memory: { targetRoom: room.name, homeRoom: room.name, sourceId: source.id }
            });
        });
    }
    static withdrawEnergyFromContainer(creep, container) {
        const distance = creep.pos.getRangeTo(container);
        if (distance > 1) {
            creep.travel(container, { ignoreHostiles: false });
        }
        else {
            creep.withdraw(container, RESOURCE_ENERGY);
        }
    }
    static withdrawEnergyFromLink(creep, link) {
        const distance = creep.pos.getRangeTo(link);
        if (distance > 1) {
            creep.travel(link, { ignoreHostiles: false });
        }
        else {
            creep.withdraw(link, RESOURCE_ENERGY);
        }
    }
    static withdrawEnergyFromTombstone(creep, tombstone) {
        const distance = creep.pos.getRangeTo(tombstone);
        if (distance > 1) {
            creep.travel(tombstone, { ignoreHostiles: false });
        }
        else {
            creep.withdraw(tombstone, RESOURCE_ENERGY);
        }
    }
    static pickResource(creep, resource) {
        const distance = creep.pos.getRangeTo(resource);
        if (distance > 1) {
            creep.travel(resource, { ignoreHostiles: false });
        }
        else {
            creep.pickup(resource);
        }
    }
    static withdrawFromRuin(creep, ruin) {
        const distance = creep.pos.getRangeTo(ruin);
        if (distance > 1) {
            creep.travel(ruin, { ignoreHostiles: false });
        }
        else {
            creep.withdraw(ruin, RESOURCE_ENERGY);
        }
    }
    static withdrawEnergyFromStorage(creep, storage) {
        if (!this.storageCanTakeEnergy(storage)) {
            return false;
        }
        const distance = creep.pos.getRangeTo(storage);
        if (distance > 2) {
            creep.travel(storage, { ignoreHostiles: false });
        }
        else if (distance === 2) {
            const openSpot = storage.pos.openSpots
                .filter(pos => !pos.creep)
                .sort((a, b) => a.getRangeTo(creep) - b.getRangeTo(creep))[0];
            if (openSpot) {
                creep.moveTo(openSpot);
                return true;
            }
            const swapSpot = storage.pos.openSpots.filter(pos => { var _a; return pos.getRangeTo(creep) === 1 && ((_a = pos.creep) === null || _a === void 0 ? void 0 : _a.memory.role) === CONFIG$H.roleName; })[0];
            if (swapSpot && swapSpot.creep) {
                creep.move(swapSpot.creep);
                swapSpot.creep.move(creep);
                creep.say("-");
                swapSpot.creep.say("-");
                return true;
            }
            creep.travel(storage, { ignoreHostiles: true });
        }
        else {
            creep.withdraw(storage, RESOURCE_ENERGY);
        }
        return true;
    }
    static withdrawEnergyFromTerminal(creep, terminal) {
        if (!this.terminalCanTakeEnergy(terminal)) {
            return false;
        }
        const distance = creep.pos.getRangeTo(terminal);
        if (distance > 1) {
            creep.travel(terminal, { ignoreHostiles: false });
        }
        else {
            creep.withdraw(terminal, RESOURCE_ENERGY);
        }
        return true;
    }
    static storeEnergyTo(creep, storage) {
        const distance = creep.pos.getRangeTo(storage);
        if (distance > 1) {
            creep.travel(storage, { ignoreHostiles: false });
        }
        else {
            creep.transfer(storage, RESOURCE_ENERGY);
        }
        return true;
    }
    static setTarget(creep) {
        var _a;
        if (creep.target) {
            return;
        }
        if (creep.store.getUsedCapacity() === 0) {
            creep.target =
                // this.findLinkWithdrawTarget(creep) ||
                // this.findContainerWithdrawTarget(creep) ||
                this.findDroppedEnergyTarget(creep) ||
                    this.findTombstoneEnergyTarget(creep) ||
                    this.findRuinEnergyTarget(creep) ||
                    this.findStorageWithdrawTarget(creep) ||
                    this.findGclPowerlevelMasterStorage(creep) ||
                    this.findTerminalWithdrawTarget(creep) ||
                    this.findSource(creep) ||
                    null;
        }
        else {
            creep.target =
                this.findSpawnTarget(creep) ||
                    this.findTowerTarget(creep) ||
                    this.findExtensionTarget(creep) ||
                    // this.findStorageTarget(creep) ||
                    // this.findContainerTarget(creep) ||
                    this.findLowControllerTarget(creep) ||
                    // this.findRampartTarget(creep.targetRoom) ||
                    this.findConstructionTarget(creep, creep.homeRoom) ||
                    this.findConstructionTarget(creep, creep.targetRoom) ||
                    this.findControllerTarget(creep) ||
                    null;
        }
        if (creep.target && creep.room.name === ((_a = creep.target.room) === null || _a === void 0 ? void 0 : _a.name)) {
            creep.room.visual.line(creep.pos, creep.target.pos, { lineStyle: "dashed", width: 0.15 });
        }
    }
    static findSource(creep) {
        if (!creep.source) {
            return;
        }
        return creep.source;
    }
    static findTombstoneEnergyTarget(creep) {
        const rooms = [creep.memory.homeRoom, creep.memory.targetRoom];
        if (!rooms.includes(creep.room.name)) {
            return;
        }
        if (creep.room.centerLeveling &&
            creep.room.storage &&
            creep.room.storage.store.energy > 50000 &&
            creep.room.controller &&
            creep.room.storage.pos.getRangeTo(creep.room.controller) <= 3) {
            return;
        }
        return creep.room.find(FIND_TOMBSTONES, {
            filter: r => !this.posHasCloseHostile(r.pos) &&
                r.store[RESOURCE_ENERGY] >=
                    this.creepsHavingTargetId(creep.room, r.id).reduce((total, cr) => total + cr.store.getFreeCapacity(RESOURCE_ENERGY), 0) +
                        CONFIG$H.minAmountToPickup
        })[0];
    }
    static findRuinEnergyTarget(creep) {
        const rooms = [creep.memory.homeRoom, creep.memory.targetRoom];
        if (!rooms.includes(creep.room.name)) {
            return;
        }
        if (creep.room.centerLeveling &&
            creep.room.storage &&
            creep.room.storage.store.energy > 50000 &&
            creep.room.controller &&
            creep.room.storage.pos.getRangeTo(creep.room.controller) <= 3) {
            return;
        }
        return creep.room.find(FIND_RUINS, {
            filter: r => !this.posHasCloseHostile(r.pos) && r.store[RESOURCE_ENERGY] >= CONFIG$H.minAmountToPickup
        })[0];
    }
    static posHasCloseHostile(pos) {
        return pos.findInRange(FIND_HOSTILE_CREEPS, 4, { filter: c => c.attackPower + c.rangedAttackPower > 0 }).length > 0;
    }
    static findDroppedEnergyTarget(creep) {
        const rooms = [creep.memory.homeRoom, creep.memory.targetRoom];
        if (!rooms.includes(creep.room.name)) {
            return;
        }
        return creep.room.find(FIND_DROPPED_RESOURCES, {
            filter: r => r.resourceType === RESOURCE_ENERGY &&
                r.amount >=
                    this.creepsHavingTargetId(creep.room, r.id).reduce((total, cr) => total + cr.store.getFreeCapacity(RESOURCE_ENERGY), 0) +
                        CONFIG$H.minAmountToPickup &&
                !this.posHasCloseHostile(r.pos)
        })[0];
    }
    static findLowControllerTarget(creep) {
        if (!creep.homeRoom) {
            return;
        }
        if (!creep.homeRoom.controller) {
            return;
        }
        if (creep.homeRoom.controller.upgradeBlocked > 0) {
            return;
        }
        if (creep.homeRoom.controller.ticksToDowngrade > 5000) {
            return;
        }
        return creep.homeRoom.controller;
    }
    static findControllerTarget(creep) {
        if (!creep.homeRoom) {
            return;
        }
        if (!creep.homeRoom.controller) {
            return;
        }
        if (creep.homeRoom.controller.upgradeBlocked > 0) {
            return;
        }
        return creep.homeRoom.controller;
    }
    static findStorageTarget(creep) {
        if (!creep.homeRoom) {
            return;
        }
        if (!creep.homeRoom.storage) {
            return;
        }
        if (!creep.homeRoom.storage.cachedIsActive()) {
            return;
        }
        if (creep.homeRoom.myActiveSpawns.length === 0) {
            return;
        }
        if (!this.storageNeedsEnergy(creep.homeRoom.storage)) {
            return;
        }
        return creep.homeRoom.storage;
    }
    static findContainerTarget(creep) {
        if (!creep.homeRoom) {
            return;
        }
        const container = creep.homeRoom
            .find(FIND_STRUCTURES)
            .find(c => c.structureType === STRUCTURE_CONTAINER && c.store.getFreeCapacity(RESOURCE_ENERGY) > 0);
        if (!(container instanceof StructureContainer)) {
            return;
        }
        return container;
    }
    static findContainerWithdrawTarget(creep) {
        if (!creep.homeRoom) {
            return;
        }
        const container = creep.homeRoom.controllerContainers
            .filter(c => creep.pos.getRangeTo(c) <= 4 && c.store.energy >= CONFIG$H.minAmountToWithdrawFromContainer)
            .sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0];
        if (!container) {
            return;
        }
        return container;
    }
    static findGclPowerlevelMasterStorage(creep) {
        if (!creep.homeRoom) {
            return;
        }
        if (!creep.homeRoom.isGclFarm) {
            return;
        }
        const storage = creep.homeRoom.gclMasterRooms
            .map(room => room.storage)
            .sort((a, b) => ((b === null || b === void 0 ? void 0 : b.store.energy) || 0) - ((a === null || a === void 0 ? void 0 : a.store.energy) || 0))[0];
        if (!storage) {
            return;
        }
        if (storage.store.energy < 90000) {
            return;
        }
        return storage;
    }
    static findLinkWithdrawTarget(creep) {
        if (!creep.homeRoom) {
            return;
        }
        if (!creep.homeRoom.controllerLink) {
            return;
        }
        if (!creep.pos.isNearTo(creep.homeRoom.controllerLink)) {
            return;
        }
        if (creep.homeRoom.controllerLink.store.energy < CONFIG$H.minAmountToWithdrawFromLink) {
            return;
        }
        return creep.homeRoom.controllerLink;
    }
    static findTerminalWithdrawTarget(creep) {
        if (!creep.homeRoom) {
            return;
        }
        if (!creep.homeRoom.terminal) {
            return;
        }
        if (!this.terminalCanTakeEnergy(creep.homeRoom.terminal)) {
            return;
        }
        return creep.homeRoom.terminal;
    }
    static findStorageWithdrawTarget(creep) {
        if (!creep.homeRoom) {
            return;
        }
        if (!creep.homeRoom.storage) {
            return;
        }
        if (!this.storageCanTakeEnergy(creep.homeRoom.storage)) {
            return;
        }
        return creep.homeRoom.storage;
    }
    static findRampartTarget(room) {
        if (!room) {
            return;
        }
        const rampart = room
            .find(FIND_MY_STRUCTURES)
            .filter(c => c.structureType === STRUCTURE_RAMPART && c.hits < UPGRADE_RAMPARTS_UP_TO && c.hitsMax - c.hits > 10000)
            .sort((a, b) => a.hits - b.hits)[0];
        if (!rampart) {
            return;
        }
        return rampart;
    }
    static findConstructionTarget(creep, room) {
        if (!room) {
            return;
        }
        const constructions = room.find(FIND_MY_CONSTRUCTION_SITES).filter(c => c.structureType !== STRUCTURE_RAMPART);
        if (constructions.length === 0) {
            return;
        }
        return (constructions.filter(c => c.structureType === STRUCTURE_TERMINAL)[0] ||
            constructions.filter(c => c.structureType === STRUCTURE_STORAGE)[0] ||
            constructions.filter(c => c.structureType === STRUCTURE_SPAWN)[0] ||
            constructions
                .filter(c => c.structureType !== STRUCTURE_LAB)
                .sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0] ||
            constructions[0]);
    }
    static findExtensionTarget(creep) {
        if (!creep.homeRoom) {
            return;
        }
        if (creep.homeRoom.energyBalancerCreeps.length > 0) {
            return;
        }
        return creep.homeRoom.extensions.find(e => this.extensionNeedsEnergy(e) && !this.creepsHaveTargetId(e.id));
    }
    static findTowerTarget(creep) {
        if (!creep.homeRoom) {
            return;
        }
        return creep.homeRoom.towers.find(t => this.towerNeedsEnergy(t) && !this.creepsHaveTargetId(t.id));
    }
    static findSpawnTarget(creep) {
        if (!creep.homeRoom) {
            return;
        }
        return creep.homeRoom.myActiveSpawns.find(s => this.spawnNeedsEnergy(s) && this.creepsEnergyWithTargetId(s.id) < s.store.getFreeCapacity(RESOURCE_ENERGY));
    }
    static storageNeedsEnergy(storage) {
        return storage.my && storage.store.energy < 5000;
    }
    static terminalAndStorageEnergyAmount(room) {
        var _a, _b;
        return (((_a = room.terminal) === null || _a === void 0 ? void 0 : _a.store.energy) || 0) + (((_b = room.storage) === null || _b === void 0 ? void 0 : _b.store.energy) || 0);
    }
    static storageCanTakeEnergy(storage) {
        return ((!storage.my && storage.store.energy > 100) ||
            (storage.store.energy > 5000 && this.terminalAndStorageEnergyAmount(storage.room) >= 50000));
    }
    static terminalCanTakeEnergy(terminal) {
        return terminal.store.energy > 5000 && this.terminalAndStorageEnergyAmount(terminal.room) >= 20000;
    }
    static extensionNeedsEnergy(extension) {
        return extension.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
    }
    static spawnNeedsEnergy(spawn) {
        return spawn.store.getFreeCapacity(RESOURCE_ENERGY) >= 50;
    }
    static towerNeedsEnergy(tower) {
        return tower.store.getFreeCapacity(RESOURCE_ENERGY) >= TOWER_CAPACITY / 2;
    }
    static creepsHavingTargetId(room, id) {
        return room.find(FIND_MY_CREEPS).filter(c => c.memory.targetId === id);
    }
    static creepsHaveTargetId(id) {
        return !!Creeps.myCreeps.find(c => c.memory.targetId === id);
    }
    static creepsEnergyWithTargetId(id) {
        return Creeps.myCreeps
            .filter(c => c.memory.targetId === id)
            .reduce((total, creep) => total + creep.store.energy, 0);
    }
    static clearTarget(creep) {
        if (creep.target instanceof StructureSpawn) {
            this.clearSpawn(creep, creep.target);
        }
        else if (creep.target instanceof StructureTower) {
            this.clearTower(creep, creep.target);
        }
        else if (creep.target instanceof StructureStorage) {
            this.clearStorage(creep, creep.target);
        }
        else if (creep.target instanceof StructureTerminal) {
            this.clearTerminal(creep, creep.target);
        }
        else if (creep.target instanceof StructureExtension) {
            this.clearExtension(creep, creep.target);
        }
        else if (creep.target instanceof Resource) {
            this.clearResource(creep, creep.target);
        }
        else if (creep.target instanceof Tombstone) {
            this.clearTombstone(creep, creep.target);
        }
        else if (creep.target instanceof Ruin) {
            this.clearRuin(creep, creep.target);
        }
        else if (creep.target instanceof Source) {
            this.clearSource(creep);
        }
        else if (creep.target instanceof StructureController) {
            this.clearController(creep, creep.target);
        }
        else if (creep.target instanceof ConstructionSite) {
            this.clearConstructionSite(creep);
        }
        else if (creep.target instanceof StructureContainer) {
            this.clearContainer(creep, creep.target);
        }
        else if (creep.target instanceof StructureLink) {
            this.clearLink(creep, creep.target);
        }
        else if (creep.target instanceof StructureRampart) {
            this.clearRampart(creep, creep.target);
        }
    }
    static clearController(creep, controller) {
        if (creep.isEmpty(RESOURCE_ENERGY)) {
            creep.target = null;
        }
        if (controller.upgradeBlocked) {
            creep.target = null;
        }
        if (controller.level === 8) {
            creep.target = null;
        }
    }
    static clearSource(creep) {
        if (creep.store.getFreeCapacity(RESOURCE_ENERGY) < creep.harvestPower) {
            creep.target = null;
        }
    }
    static clearConstructionSite(creep) {
        if (creep.isEmpty(RESOURCE_ENERGY)) {
            creep.target = null;
        }
    }
    static clearTombstone(creep, tombstone) {
        if (tombstone.store[RESOURCE_ENERGY] < CONFIG$H.minAmountToPickup) {
            creep.target = null;
        }
        if (creep.isFull()) {
            creep.target = null;
        }
    }
    static clearRuin(creep, ruin) {
        if (ruin.store[RESOURCE_ENERGY] < CONFIG$H.minAmountToPickup) {
            creep.target = null;
        }
        if (creep.isFull()) {
            creep.target = null;
        }
    }
    static clearResource(creep, resource) {
        if (resource.amount < CONFIG$H.minAmountToPickup) {
            creep.target = null;
        }
        if (creep.isFull()) {
            creep.target = null;
        }
    }
    static clearExtension(creep, extension) {
        if (!this.extensionNeedsEnergy(extension)) {
            creep.target = null;
        }
        if (creep.isEmpty(RESOURCE_ENERGY)) {
            creep.target = null;
        }
    }
    static clearStorage(creep, storage) {
        if (creep.isEmpty(RESOURCE_ENERGY) && !this.storageCanTakeEnergy(storage)) {
            creep.target = null;
        }
        if (creep.isFull() && !this.storageNeedsEnergy(storage)) {
            creep.target = null;
        }
    }
    static clearTerminal(creep, terminal) {
        if (creep.isFull() && this.terminalCanTakeEnergy(terminal)) {
            creep.target = null;
        }
        if (!this.terminalCanTakeEnergy(terminal)) {
            creep.target = null;
        }
    }
    static clearContainer(creep, container) {
        if (container.store.getFreeCapacity() < 100) {
            creep.target = null;
        }
        if (creep.isEmpty(RESOURCE_ENERGY)) {
            creep.target = null;
        }
    }
    static clearRampart(creep, rampart) {
        if (rampart.hits > UPGRADE_RAMPARTS_UP_TO * 1.05) {
            creep.target = null;
        }
        if (rampart.hits === rampart.hitsMax) {
            creep.target = null;
        }
        if (creep.isEmpty(RESOURCE_ENERGY)) {
            creep.target = null;
        }
    }
    static clearLink(creep, link) {
        if (link.store.energy < CONFIG$H.minAmountToWithdrawFromLink) {
            creep.target = null;
        }
        if (creep.isFull()) {
            creep.target = null;
        }
    }
    static clearTower(creep, tower) {
        if (!this.towerNeedsEnergy(tower)) {
            creep.target = null;
        }
        if (creep.isEmpty(RESOURCE_ENERGY)) {
            creep.target = null;
        }
    }
    static clearSpawn(creep, spawn) {
        if (!this.spawnNeedsEnergy(spawn)) {
            creep.target = null;
        }
        if (creep.isEmpty(RESOURCE_ENERGY)) {
            creep.target = null;
        }
    }
    static constructRoads(creep) {
        if (!creep.source) {
            return;
        }
        if (!creep.homeRoom) {
            return;
        }
        if (creep.homeRoom.level < 8) {
            return;
        }
        if (creep.memory.homeRoom === creep.memory.targetRoom) {
            return;
        }
        if (!creep.homeRoom.shouldConstruct) {
            return;
        }
        if (creep.memory.constructionsCreated && (creep.source.container || creep.source.containerConstruction)) {
            return;
        }
        if (!creep.homeRoom.storage) {
            return;
        }
        creep.source.pos.createRoadConstructionsFrom(creep.homeRoom.storage.pos);
        creep.memory.constructionsCreated = true;
    }
    static repairRoadsAround(creep) {
        var _a, _b, _c, _d;
        if (((_b = (_a = creep.room.controller) === null || _a === void 0 ? void 0 : _a.owner) === null || _b === void 0 ? void 0 : _b.username) !== USERNAME.ME &&
            ((_d = (_c = creep.room.controller) === null || _c === void 0 ? void 0 : _c.reservation) === null || _d === void 0 ? void 0 : _d.username) !== USERNAME.ME) {
            return false;
        }
        if (creep.store.energy / creep.store.getCapacity() <= 0.5) {
            return false;
        }
        const road = creep.pos.findInRange(FIND_STRUCTURES, 3, {
            filter: s => s.structureType === STRUCTURE_ROAD && s.hits / s.hitsMax < 0.9
        })[0];
        if (!road) {
            return false;
        }
        creep.repair(road);
        return true;
    }
    static repairContainersAround(creep) {
        if (creep.store.energy / creep.store.getCapacity() <= 0.5) {
            return false;
        }
        const container = creep.pos.findInRange(FIND_STRUCTURES, 3, {
            filter: s => s.structureType === STRUCTURE_CONTAINER && s.hits / s.hitsMax < 0.9
        })[0];
        if (!container) {
            return false;
        }
        creep.repair(container);
        return true;
    }
    static buildRoadsAround(creep) {
        if (creep.store.energy / creep.store.getCapacity() <= 0.5) {
            return false;
        }
        const construction = creep.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 3, {
            filter: s => s.structureType === STRUCTURE_ROAD
        })[0];
        if (!construction) {
            return false;
        }
        creep.build(construction);
        return true;
    }
    static buildStructure(creep, construction) {
        const distance = creep.pos.getRangeTo(construction);
        if (distance > 3) {
            creep.travel(construction, { ignoreHostiles: false });
        }
        else if (distance > 1) {
            creep.travel(construction, {
                ignoreCreeps: false,
                freshPath: true,
                maxOps: 200
            });
        }
        if (distance <= 3) {
            creep.build(construction);
        }
        return true;
    }
    static repairRampart(creep, rampart) {
        const distance = creep.pos.getRangeTo(rampart);
        if (distance > 3) {
            creep.travel(rampart, { ignoreCreeps: false, ignoreHostiles: false, freshPath: distance <= 5 });
        }
        if (distance <= 3) {
            creep.repair(rampart);
        }
        return true;
    }
    static withdrawEnergyFromUpgradeHauler(creep) {
        if (creep.store.energy > 100) {
            return false;
        }
        const hauler = creep.pos.findInRange(FIND_MY_CREEPS, 1, {
            filter: c => c.memory.role === CONFIG_BASE_UPGRADER_HAULER.roleName && c.store.energy > 0
        })[0];
        if (!hauler) {
            return false;
        }
        hauler.transfer(creep, RESOURCE_ENERGY);
        return true;
    }
    static moveToBestStorageControllerPos(creep, storage, controller) {
        const bestPositions = [...storage.pos.getOpenSpots(1), ...storage.pos.getOpenSpots(2)]
            .filter(pos => pos.getRangeTo(controller) <= 3 && (!pos.creep || pos.creep.id === creep.id))
            .sort((a, b) => {
            if (a.getRangeTo(controller) === b.getRangeTo(controller)) {
                return a.getRangeTo(controller) - b.getRangeTo(controller);
            }
            return a.getRangeTo(creep) - b.getRangeTo(creep);
        });
        if (bestPositions.find(pos => { var _a; return ((_a = pos.creep) === null || _a === void 0 ? void 0 : _a.id) === creep.id; })) {
            return true;
        }
        const bestPos = bestPositions[0];
        if (bestPos) {
            creep.travel({ pos: bestPos }, { range: 0, ignoreCreeps: false, freshPath: creep.pos.getRangeTo(bestPos) <= 4 });
            return true;
        }
        return false;
    }
    static upgradeController(creep, controller) {
        const distance = creep.pos.getRangeTo(controller);
        // this.withdrawEnergyFromUpgradeHauler(creep);
        if (distance <= 3) {
            creep.upgradeController(controller);
        }
        if (creep.room.storage && controller.pos.getRangeTo(creep.room.storage) <= 3) {
            return this.moveToBestStorageControllerPos(creep, creep.room.storage, controller);
        }
        else {
            if (distance > 3) {
                creep.travel(controller, { range: 3, ignoreCreeps: false, freshPath: distance <= 4 });
            }
            else {
                let range = 1;
                if (distance === 3) {
                    range = 2;
                }
                else if (distance === 2) {
                    range = 1;
                }
                const ret = PathFinder.search(creep.pos, { pos: controller.pos, range }, {
                    maxRooms: 1,
                    maxOps: 200,
                    roomCallback(roomName) {
                        if (roomName !== creep.room.name) {
                            return false;
                        }
                        const matrix = new PathFinder.CostMatrix();
                        for (let x = 0; x <= 49; x++) {
                            for (let y = 0; y <= 49; y++) {
                                if (controller.pos.getRangeTo(x, y) <= 3) {
                                    continue;
                                }
                                matrix.set(x, y, 256);
                            }
                        }
                        return matrix;
                    }
                });
                if (ret.incomplete) {
                    return false;
                }
                creep.moveByPath(ret.path);
            }
        }
        return true;
    }
    static moveToTargetRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        creep.travelToRoom(creep.memory.targetRoom, { ignoreHostiles: false });
        return true;
    }
    static mineSource(creep, source) {
        const distance = creep.pos.getRangeTo(source);
        if (distance === 2) {
            const freeSpots = source.pos.openSpots.filter(p => !p.hasCreep);
            if (freeSpots.length === 0) {
                return true;
            }
        }
        if (distance > 1) {
            const shouldRepath = distance <= 3;
            creep.travel(source, {
                // maxOps: shouldRepath ? 200 : undefined,
                ignoreCreeps: !shouldRepath,
                freshPath: shouldRepath,
                ignoreHostiles: false
            });
        }
        else {
            if (creep.isFull()) {
                return false;
            }
            if (source.energy === 0) {
                return false;
            }
            creep.harvest(source);
        }
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseNewbie, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseNewbie, "handleSpawn", null);

const CONFIG$G = Config.BaseNukerGhodiumFiller;
class BaseNukerGhodiumFiller {
    static handle() {
        Creeps.getByRole(CONFIG$G.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$G.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        if (creep.store.getUsedCapacity() === 0) {
            this.suicide(creep) || this.withdrawGhodiumFromStorage(creep);
        }
        else {
            this.suicide(creep) || this.storeGhodiumToNuker(creep);
        }
    }
    static handleSpawn() {
        Rooms.myRooms.forEach(room => {
            if (!room.storage) {
                return;
            }
            if (room.storage.store.getUsedCapacity(RESOURCE_GHODIUM) < 5000) {
                return;
            }
            if (!room.nuker) {
                return;
            }
            if (room.nuker.store.getFreeCapacity(RESOURCE_GHODIUM) === 0) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({ homeRoom: room.name, role: CONFIG$G.roleName });
            if (creepsCount >= 1) {
                return;
            }
            Spawns.addToQue(room, {
                body: new BodyParts().addMultiple([MOVE, CARRY], 5),
                priority: CONFIG$G.spawnPriority,
                role: CONFIG$G.roleName
            });
        });
    }
    static suicide(creep) {
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > 50) {
            return false;
        }
        return creep.recycleFinal();
    }
    static withdrawGhodiumFromStorage(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        if (!creep.room.nuker) {
            return false;
        }
        if (creep.room.nuker.store.getFreeCapacity(RESOURCE_GHODIUM) === 0) {
            return false;
        }
        if (creep.withdraw(creep.room.storage, RESOURCE_GHODIUM) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.room.storage);
        }
        return true;
    }
    static storeGhodiumToNuker(creep) {
        if (!creep.room.nuker) {
            return false;
        }
        if (creep.transfer(creep.room.nuker, RESOURCE_GHODIUM) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.room.nuker);
        }
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseNukerGhodiumFiller, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseNukerGhodiumFiller, "handleSpawn", null);

class PowerCreeps {
    static getByRole(role) {
        return this.getMyCreeps().filter(creep => creep.memory.role === role);
    }
    static getMyCreeps() {
        return Object.values(Game.powerCreeps);
    }
    static visualCreepCpu(creep, callback) {
        var _a, _b;
        const start = Game.cpu.getUsed();
        callback();
        const end = Game.cpu.getUsed();
        const cpuUsed = end - start;
        (_a = creep.room) === null || _a === void 0 ? void 0 : _a.visual.circle(creep.pos.x, creep.pos.y, {
            radius: 0.75,
            fill: "transparent",
            stroke: getCreepCpuColor(cpuUsed),
            strokeWidth: 0.2,
            opacity: 0.3
            // color: getCreepCpuTextColor(cpuUsed)
        });
        if (cpuUsed > 0.6) {
            (_b = creep.room) === null || _b === void 0 ? void 0 : _b.visual.text(cpuUsed.toFixed(2), creep.pos.x, creep.pos.y - 0.75 + 0.1, {
                font: 0.2,
                // stroke: getCreepCpuColor(cpuUsed),
                align: "center",
                color: getCreepCpuTextColor(cpuUsed)
            });
        }
    }
}

const CONFIG$F = Config.BasePowerCreep;
const QUE_CACHE = [];
class BasePowerCreep {
    static handle() {
        PowerCreeps.getByRole(CONFIG$F.roleName).forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$F.spawnInterval, () => this.handleSpawn());
        // General.interval(CREATE_INTERVAL, () => creator());
        General.interval(5000, () => this.upgrader());
        // todo create creep for boosting storage
        this.assignRole();
    }
    static assignRole() {
        for (let i = 0; i < QUE_CACHE.length; i++) {
            const name = QUE_CACHE[i];
            const creep = Game.powerCreeps[name];
            if (!creep) {
                return;
            }
            creep.memory.role = CONFIG$F.roleName;
            delete QUE_CACHE[i];
        }
    }
    static upgrader() {
        var _a;
        const freePoints = Game.gpl.level - this.gplUsed();
        if (freePoints <= 0) {
            return;
        }
        for (const powerCreep of PowerCreeps.getByRole(CONFIG$F.roleName)) {
            const desiredPower = CONFIG$F.creepLevelSkills[powerCreep.level];
            if (!desiredPower) {
                continue;
            }
            powerCreep.upgrade(desiredPower);
            console.log(`upgrading creep '${powerCreep.name}' in room ${Helpers.roomLink(String((_a = powerCreep.room) === null || _a === void 0 ? void 0 : _a.name))} power ${desiredPower}`);
            return;
        }
    }
    static creator() {
        if (Game.gpl.level <= this.gplUsed()) {
            return;
        }
        const totalCreeps = PowerCreeps.getByRole(CONFIG$F.roleName).length;
        if (totalCreeps >= ROOM_COUNT_GOAL) {
            return;
        }
        const hasUnleveledCreeps = PowerCreeps.getByRole(CONFIG$F.roleName).filter(c => c.level < 14).length > 0;
        if (hasUnleveledCreeps) {
            return;
        }
        const newName = `diana-${General.uniqueId()}`;
        const response = PowerCreep.create(newName, POWER_CLASS.OPERATOR);
        if (response !== OK) {
            return;
        }
        QUE_CACHE.push(newName);
        console.log("Created new power creep");
    }
    static handleCreep(creep) {
        if (!creep.hits) {
            return;
        }
        this.showOnMap(creep);
        this.suicide(creep) ||
            this.travelToHomeRoom(creep) ||
            this.prepareForNukes(creep) ||
            this.refresh(creep) ||
            this.enableRoomPower(creep) ||
            this.generateOps(creep) ||
            this.regenSource(creep) ||
            this.operateSpawn(creep) ||
            this.operateLab(creep) ||
            this.storeOpsToStorage(creep) ||
            this.withdrawOpsFromStorage(creep) ||
            this.withdrawOpsFromTerminal(creep) ||
            creep.travelToIdlePlace();
    }
    static showOnMap(creep) {
        if (!creep.room) {
            return;
        }
        Game.map.visual.text(String(creep.level), new RoomPosition(40, 40, creep.room.name));
    }
    static suicide(creep) {
        if (!creep.room) {
            return false;
        }
        const powerCreeps = creep.room
            .find(FIND_MY_POWER_CREEPS, { filter: c => c.memory.role === CONFIG$F.roleName })
            .sort((a, b) => a.level - b.level);
        if (powerCreeps.length <= 1) {
            return false;
        }
        const lowest = powerCreeps[0];
        if (creep.id !== lowest.id) {
            return false;
        }
        creep.suicide();
        return true;
    }
    static handleSpawn() {
        for (const powerCreep of Object.values(Game.powerCreeps).sort((a, b) => b.level - a.level)) {
            if (powerCreep.memory.role !== CONFIG$F.roleName) {
                continue;
            }
            if (powerCreep.deleteTime) {
                continue;
            }
            if (powerCreep.spawnCooldownTime) {
                continue;
            }
            if (powerCreep.room) {
                continue;
            }
            const room = Rooms.myRooms.find(r => r.myCenterPowerSpawn &&
                r.level >= 8 &&
                r.find(FIND_MY_POWER_CREEPS, { filter: p => p.memory.role === CONFIG$F.roleName }).length === 0);
            if (!room) {
                continue;
            }
            if (!room.myCenterPowerSpawn) {
                continue;
            }
            powerCreep.spawn(room.myCenterPowerSpawn);
            powerCreep.memory.homeRoom = room.name;
            console.log("spawning power creep in " + room.name);
            return;
        }
    }
    static gplUsed() {
        return PowerCreeps.getMyCreeps().reduce((total, creep) => total + creep.level + 1, 0);
    }
    static prepareForNukes(creep) {
        if (!creep.room) {
            return false;
        }
        const nuke = creep.room.find(FIND_NUKES).sort((a, b) => a.timeToLand - b.timeToLand)[0];
        if (!nuke) {
            return false;
        }
        if (nuke.timeToLand > 50) {
            return false;
        }
        if (nuke.timeToLand <= 3) {
            const exit = creep.pos.findClosestByPath(FIND_EXIT);
            if (!exit) {
                return false;
            }
            creep.moveTo(exit, { range: 0 });
        }
        else {
            const rampart = creep.pos.findClosestByRange(FIND_MY_STRUCTURES, {
                filter: s => s.structureType === STRUCTURE_RAMPART && s.pos.findInRange(FIND_EXIT, 2).length > 0
            });
            if (!rampart) {
                return false;
            }
            creep.moveTo(rampart, { range: 0, visualizePathStyle: {} });
        }
        return true;
    }
    static travelToHomeRoom(creep) {
        if (!creep.memory.homeRoom) {
            return false;
        }
        if (creep.pos.roomName === creep.memory.homeRoom) {
            return false;
        }
        const hasCloseCreeps = creep.pos.findInRange(FIND_CREEPS, 2).length > 0;
        creep.travel({ pos: new RoomPosition(25, 25, creep.memory.homeRoom) }, { range: 20, ignoreCreeps: hasCloseCreeps, freshPath: hasCloseCreeps });
        return true;
    }
    static operateSpawn(creep) {
        const power = creep.powers[PWR_OPERATE_SPAWN];
        if (!creep.room) {
            return false;
        }
        if (creep.store.ops < 100) {
            return false;
        }
        if (!creep.room.isSiegeBase &&
            (!creep.room.mem.increasedSpawnUntil || creep.room.mem.increasedSpawnUntil < Game.time)) {
            return false;
        }
        if (!power) {
            return false;
        }
        if (!power.level) {
            return false;
        }
        if (power.cooldown) {
            return false;
        }
        if (creep.store.ops < 100) {
            return false;
        }
        const spawn = creep.room
            .find(FIND_MY_SPAWNS)
            .filter(s => !s.effects || s.effects.filter(e => e.effect === PWR_OPERATE_SPAWN && e.ticksRemaining > 50).length === 0)[0];
        if (!spawn) {
            return false;
        }
        if (creep.usePower(PWR_OPERATE_SPAWN, spawn) === ERR_NOT_IN_RANGE) {
            creep.moveTo(spawn, {
                range: 3,
                swampCost: 1,
                maxRooms: 1,
                ignoreRoads: true,
                costCallback: (roomName, costMatrix) => {
                    Geo.roomEdges(2).forEach(pos => costMatrix.set(pos.x, pos.y, 254));
                    return costMatrix;
                },
                visualizePathStyle: {}
            });
        }
        return true;
    }
    static regenSource(creep) {
        const power = creep.powers[PWR_REGEN_SOURCE];
        if (!creep.room) {
            return false;
        }
        if (!power) {
            return false;
        }
        if (!power.level) {
            return false;
        }
        if (power.cooldown) {
            return false;
        }
        const source = creep.room.find(FIND_SOURCES, {
            filter: s => !s.effects || s.effects.filter(e => e.effect === PWR_REGEN_SOURCE && e.ticksRemaining > 50).length === 0
        })[0];
        if (!source) {
            return false;
        }
        if (creep.usePower(PWR_REGEN_SOURCE, source) === ERR_NOT_IN_RANGE) {
            creep.moveTo(source, {
                range: 3,
                swampCost: 1,
                maxRooms: 1,
                ignoreRoads: true,
                costCallback: (roomName, costMatrix) => {
                    Geo.roomEdges(2).forEach(pos => costMatrix.set(pos.x, pos.y, 254));
                    return costMatrix;
                },
                visualizePathStyle: {}
            });
        }
        return true;
    }
    static withdrawOpsFromTerminal(creep) {
        if (!creep.room) {
            return false;
        }
        if (!creep.room.terminal) {
            return false;
        }
        if (creep.room.terminal.store[RESOURCE_OPS] < 30) {
            return false;
        }
        if (creep.store.getUsedCapacity(RESOURCE_OPS) / creep.store.getCapacity(RESOURCE_OPS) > 0.3) {
            return false;
        }
        const amountToTransfer = Math.min(creep.store.getCapacity(RESOURCE_OPS) / 2 - creep.store.getUsedCapacity(RESOURCE_OPS), creep.room.terminal.store[RESOURCE_OPS]);
        if (amountToTransfer <= 0) {
            return false;
        }
        if (creep.withdraw(creep.room.terminal, RESOURCE_OPS, amountToTransfer) === ERR_NOT_IN_RANGE) {
            creep.moveTo(creep.room.terminal, {
                range: 1,
                swampCost: 1,
                maxRooms: 1,
                ignoreRoads: true,
                costCallback: (roomName, costMatrix) => {
                    Geo.roomEdges(2).forEach(pos => costMatrix.set(pos.x, pos.y, 254));
                    return costMatrix;
                },
                visualizePathStyle: {}
            });
        }
        return true;
    }
    static withdrawOpsFromStorage(creep) {
        if (!creep.room) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        if (creep.room.storage.store[RESOURCE_OPS] < 30) {
            return false;
        }
        if (creep.store.getUsedCapacity(RESOURCE_OPS) / creep.store.getCapacity(RESOURCE_OPS) > 0.3) {
            return false;
        }
        const amountToTransfer = Math.min(creep.store.getCapacity(RESOURCE_OPS) / 2 - creep.store.getUsedCapacity(RESOURCE_OPS), creep.room.storage.store[RESOURCE_OPS]);
        if (amountToTransfer <= 0) {
            return false;
        }
        if (creep.withdraw(creep.room.storage, RESOURCE_OPS, amountToTransfer) === ERR_NOT_IN_RANGE) {
            creep.moveTo(creep.room.storage, {
                range: 1,
                swampCost: 1,
                maxRooms: 1,
                ignoreRoads: true,
                costCallback: (roomName, costMatrix) => {
                    Geo.roomEdges(2).forEach(pos => costMatrix.set(pos.x, pos.y, 254));
                    return costMatrix;
                },
                visualizePathStyle: {}
            });
        }
        return true;
    }
    static storeOpsToStorage(creep) {
        if (!creep.room) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        if (creep.store.getUsedCapacity(RESOURCE_OPS) / creep.store.getCapacity(RESOURCE_OPS) < 0.7) {
            return false;
        }
        const amountToTransfer = creep.store.getUsedCapacity(RESOURCE_OPS) - creep.store.getCapacity() / 2;
        if (amountToTransfer <= 0) {
            return false;
        }
        if (creep.transfer(creep.room.storage, RESOURCE_OPS, amountToTransfer) === ERR_NOT_IN_RANGE) {
            creep.moveTo(creep.room.storage, {
                range: 1,
                swampCost: 1,
                maxRooms: 1,
                ignoreRoads: true,
                costCallback: (roomName, costMatrix) => {
                    Geo.roomEdges(2).forEach(pos => costMatrix.set(pos.x, pos.y, 254));
                    return costMatrix;
                },
                visualizePathStyle: {}
            });
        }
        return true;
    }
    static operateLab(creep) {
        const power = creep.powers[PWR_OPERATE_LAB];
        if (!creep.room) {
            return false;
        }
        if (!power) {
            return false;
        }
        if (!power.level) {
            return false;
        }
        if (power.cooldown) {
            return false;
        }
        if (creep.store[RESOURCE_OPS] / creep.store.getCapacity() < 0.5) {
            return false;
        }
        if (!creep.room.mem.labOutputResource) {
            return false;
        }
        const labsWithLowInputs = creep.room.labInputs.filter(l => l.mineralAmount < 30);
        if (labsWithLowInputs.length > 0) {
            return false;
        }
        const lab = creep.room.labOutputs
            .filter(l => !l.cooldown || l.cooldown <= 60)
            .filter(l => !l.effects || l.effects.filter(e => e.effect === PWR_OPERATE_LAB).length === 0)
            .sort((a, b) => creep.pos.getRangeTo(a) - creep.pos.getRangeTo(b))[0];
        if (!lab) {
            return false;
        }
        if (creep.usePower(PWR_OPERATE_LAB, lab) === ERR_NOT_IN_RANGE) {
            creep.moveTo(lab, {
                range: 3,
                swampCost: 1,
                maxRooms: 1,
                ignoreRoads: true,
                costCallback: (roomName, costMatrix) => {
                    Geo.roomEdges(2).forEach(pos => costMatrix.set(pos.x, pos.y, 254));
                    return costMatrix;
                },
                visualizePathStyle: {}
            });
        }
        return true;
    }
    static enableRoomPower(creep) {
        if (!creep.room) {
            return false;
        }
        if (!creep.room.controller) {
            return false;
        }
        if (creep.room.controller.isPowerEnabled) {
            return false;
        }
        if (creep.enableRoom(creep.room.controller) === ERR_NOT_IN_RANGE) {
            creep.moveTo(creep.room.controller, {
                range: 1,
                swampCost: 1,
                maxRooms: 1,
                ignoreRoads: true,
                costCallback: (roomName, costMatrix) => {
                    Geo.roomEdges(2).forEach(pos => costMatrix.set(pos.x, pos.y, 254));
                    return costMatrix;
                },
                visualizePathStyle: {}
            });
        }
        return true;
    }
    static generateOps(creep) {
        const power = creep.powers[PWR_GENERATE_OPS];
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (!power) {
            return false;
        }
        if (!power.level) {
            return false;
        }
        if (power.cooldown) {
            return false;
        }
        creep.usePower(PWR_GENERATE_OPS);
        return true;
    }
    static refresh(creep) {
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > 2300) {
            return false;
        }
        if (!creep.room) {
            return false;
        }
        if (!creep.room.myCenterPowerSpawn) {
            return false;
        }
        if (creep.renew(creep.room.myCenterPowerSpawn) === ERR_NOT_IN_RANGE) {
            creep.moveTo(creep.room.myCenterPowerSpawn, {
                range: 1,
                swampCost: 1,
                maxRooms: 1,
                ignoreRoads: true,
                costCallback: (roomName, costMatrix) => {
                    Geo.roomEdges(2).forEach(pos => costMatrix.set(pos.x, pos.y, 254));
                    return costMatrix;
                },
                visualizePathStyle: {}
            });
        }
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BasePowerCreep, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BasePowerCreep, "handleSpawn", null);

const CONFIG$E = Config.BaseRoadRepairer;
const REPAIRABLE_STRUCTURES = [STRUCTURE_ROAD, STRUCTURE_CONTAINER];
class BaseRoadRepairer {
    static handle() {
        Creeps.getByRole(CONFIG$E.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$E.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        this.clearTarget(creep);
        this.setTarget(creep);
        this.repairAround(creep);
        creep.recycleFinal(100) || this.pickEnergyFromStorage(creep) || this.moveToTarget(creep); // moveToClosestRoad(creep) || moveToClosestContainer(creep);
    }
    static handleSpawn() {
        const creeps = Creeps.getByRole(CONFIG$E.roleName);
        const que = Creeps.queByRole(CONFIG$E.roleName);
        Rooms.myRooms.forEach(room => {
            var _a;
            if (!room.storage && room.centerContainers.length === 0) {
                return;
            }
            if (room.isGclFarm) {
                return;
            }
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.homeRoom) === room.name; }).length > 0) {
                return;
            }
            if (creeps.filter(c => !c.ticksToLive || c.ticksToLive > 300).length > 0) {
                return;
            }
            if (!this.doesAnyRoomsNeedRepairs(room)) {
                return;
            }
            Spawns.addToQue(room, {
                body: BodyParts.new().addMultiple([MOVE, WORK, CARRY, MOVE], 2),
                optionalBody: BodyParts.new().addMultiple([MOVE, MOVE, WORK, CARRY], 20),
                priority: (((_a = room.storage) === null || _a === void 0 ? void 0 : _a.store.energy) || 0) >= 10000 ? 2 /* High */ : 4 /* Low */,
                role: CONFIG$E.roleName,
                memory: { homeRoom: room.name }
            });
        });
    }
    static doesAnyRoomsNeedRepairs(homeRoom) {
        const structure = homeRoom
            .find(FIND_STRUCTURES)
            .find(s => REPAIRABLE_STRUCTURES.includes(s.structureType) && s.hits / s.hitsMax < 0.5);
        if (structure) {
            return true;
        }
        return false;
    }
    static setTarget(creep) {
        if (creep.target) {
            return;
        }
        if (!creep.homeRoom) {
            Log.object(creep, "BaseRoadRepairer", "missing home room");
            return;
        }
        const targets = [];
        const repairableStructures = creep.homeRoom
            .find(FIND_STRUCTURES, { filter: s => this.isTargetRepairable(s) })
            .sort((a, b) => a.hits / a.hitsMax - b.hits / b.hitsMax);
        targets.push(...repairableStructures);
        const lowest = targets.sort((a, b) => a.hits / a.hitsMax - b.hits / b.hitsMax)[0];
        if (!lowest) {
            return;
        }
        creep.target = lowest;
    }
    static clearTarget(creep) {
        if (!creep.target) {
            return;
        }
        if (creep.target instanceof Structure && this.isTargetRepairable(creep.target)) {
            return;
        }
        creep.target = null;
        creep.targetRoom = null;
    }
    static isTargetRepairable(structure) {
        return REPAIRABLE_STRUCTURES.includes(structure.structureType) && structure.hits / structure.hitsMax < 0.9;
    }
    static repairAround(creep) {
        const lowestStructure = creep.pos
            .findInRange(FIND_STRUCTURES, 3, { filter: s => this.isTargetRepairable(s) })
            .filter(s => s.hitsMax - s.hits > 200)
            .sort((a, b) => a.hits / a.hitsMax - b.hits / b.hitsMax)[0];
        if (!lowestStructure) {
            return;
        }
        creep.repair(lowestStructure);
    }
    static pickEnergyFromStorage(creep) {
        if (!creep.homeRoom) {
            return false;
        }
        if (creep.store.getUsedCapacity() > 0) {
            return false;
        }
        const storage = creep.homeRoom.storage || creep.homeRoom.centerContainers.find(c => c.store.energy > 0);
        if (!storage) {
            return false;
        }
        if (storage.store.energy < 500) {
            return false;
        }
        if (creep.withdraw(storage, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
            creep.travel(storage);
        }
        return true;
    }
    static moveToTarget(creep) {
        if (!creep.target) {
            return false;
        }
        creep.travel(creep.target, { range: 2, costRoad: 1, costPlain: 2, costSwamp: 5 });
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseRoadRepairer, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseRoadRepairer, "handleSpawn", null);

const CONFIG$D = Config.BaseTowerFiller;
class BaseTowerFiller {
    static handle() {
        Creeps.getByRole(CONFIG$D.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$D.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        creep.recycleFinal(50) || this.fillTower(creep) || this.withdrawEnergy(creep);
    }
    static handleSpawn() {
        Rooms.myRooms.forEach(room => {
            if (!room.storage) {
                return;
            }
            if (room.storage.store.energy < CONFIG$D.spawnMinStorageEnergy) {
                return;
            }
            const towers = room
                .find(FIND_MY_STRUCTURES)
                .filter(structure => structure.structureType === STRUCTURE_TOWER &&
                structure.store.getFreeCapacity(RESOURCE_ENERGY) > 500 &&
                structure.cachedIsActive());
            if (towers.length === 0) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({
                minTicksToLive: 100,
                homeRoom: room.name,
                role: CONFIG$D.roleName
            });
            if (creepsCount >= 1) {
                return;
            }
            Spawns.addToQue(room, {
                body: BodyParts.new().move().carry(2),
                optionalBody: BodyParts.new().addMultiple([MOVE, CARRY, CARRY], 10),
                priority: CONFIG$D.spawnPriority,
                role: CONFIG$D.roleName
            });
        });
    }
    static fillTower(creep) {
        if (!creep.store.energy) {
            return false;
        }
        const tower = creep.room.towers
            .filter(t => t.store.getFreeCapacity(RESOURCE_ENERGY) > 0)
            .sort((a, b) => a.store.energy - b.store.energy)[0];
        if (!tower) {
            return false;
        }
        const distance = creep.pos.getRangeTo(tower);
        if (distance > 1) {
            creep.travel(tower);
        }
        else {
            creep.transfer(tower, RESOURCE_ENERGY);
        }
        return true;
    }
    static withdrawEnergy(creep) {
        if (creep.store.energy) {
            return false;
        }
        return creep.withdrawFromStorage(RESOURCE_ENERGY) || creep.withdrawFromTerminal(RESOURCE_ENERGY);
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseTowerFiller, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseTowerFiller, "handleSpawn", null);

const CONFIG_BASE_UPGRADE_HAULER = Config.BaseUpgradeHauler;
const CONFIG$C = Config.BaseUpgrader;
class BaseUpgrader {
    static handle() {
        Creeps.getByRole(CONFIG$C.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$C.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        // buildRoads(creep);
        creep.memory.recycling === true ||
            this.withdrawFromLink(creep) ||
            this.withdrawFromContainer(creep) ||
            this.withdrawFromHauler(creep);
        this.buildAround(creep) || this.upgradeController(creep);
        creep.boost() ||
            this.suicide(creep) ||
            this.suicideWhenTooBig(creep) ||
            this.moveNearStorage(creep) ||
            this.moveNearController(creep) ||
            // withdrawEnergyFromContainerOrLink(creep) ||
            this.repairContainer(creep) ||
            this.moveToController(creep);
    }
    static withdrawFromLink(creep) {
        if (creep.ticksToLive && creep.ticksToLive < 50) {
            return false;
        }
        if (creep.store.energy > creep.body.filter(b => b.type === WORK).length * 2) {
            return false;
        }
        const link = creep.pos.findInRange(FIND_STRUCTURES, 1, {
            filter: s => s.structureType === STRUCTURE_LINK && s.store.energy >= 100
        })[0];
        if (!link) {
            return false;
        }
        creep.withdraw(link, RESOURCE_ENERGY);
        return true;
    }
    static withdrawFromContainer(creep) {
        if (creep.store.energy > creep.body.filter(b => b.type === WORK).length * 2) {
            return false;
        }
        const container = creep.pos.findInRange(FIND_STRUCTURES, 1, {
            filter: s => s.structureType === STRUCTURE_CONTAINER && s.store.energy >= 100
        })[0];
        if (!container) {
            return false;
        }
        creep.withdraw(container, RESOURCE_ENERGY);
        return true;
    }
    static withdrawFromHauler(creep) {
        if (creep.store.energy > creep.body.filter(b => b.type === WORK).length * 2) {
            return false;
        }
        const hauler = creep.pos.findInRange(FIND_MY_CREEPS, 1, {
            filter: c => c.memory.role === CONFIG_BASE_UPGRADE_HAULER.roleName && c.store.energy >= 100
        })[0];
        if (!hauler) {
            return false;
        }
        hauler.transfer(creep, RESOURCE_ENERGY);
        return true;
    }
    static buildRoads(creep) {
        if (!creep.room.my) {
            return;
        }
        if (creep.room.level >= 8) {
            return;
        }
        if (creep.room.level <= 5) {
            return;
        }
        if (creep.memory.constructionsCreated) {
            return;
        }
        if (!creep.room.controller) {
            return;
        }
        if (!creep.room.storage) {
            return;
        }
        creep.room.controller.pos.createRoadConstructionsFrom(creep.room.storage.pos);
        creep.memory.constructionsCreated = true;
    }
    static buildAround(creep) {
        if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {
            return false;
        }
        if (!creep.room.my) {
            return false;
        }
        if (creep.room.level >= 8) {
            return false;
        }
        if (!creep.room.controller) {
            return false;
        }
        const construction = creep.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 3)[0];
        if (!construction) {
            return false;
        }
        creep.build(construction);
        return true;
    }
    static handleSpawn() {
        const creeps = Creeps.getByRole(CONFIG$C.roleName).filter(c => !c.ticksToLive || c.ticksToLive > 150);
        const que = Creeps.queByRole(CONFIG$C.roleName);
        Rooms.myRooms.forEach(room => {
            if (room.isGclFarm) {
                return;
            }
            if (room.isAbandoning) {
                return;
            }
            if (General.expansionWithSupport() && room.level < 6) {
                return;
            }
            if (room.level >= 4 && !room.storage) {
                return;
            }
            // if (room.find(FIND_MY_CONSTRUCTION_SITES).length > 0) {
            //   return;
            // }
            if (!room.storage && room.centerContainers.length === 0) {
                return;
            }
            if (room.storage && room.storage.store.energy < 5000) {
                return;
            }
            if (!room.controller) {
                return;
            }
            if (!this.shouldUpgrade(room)) {
                return;
            }
            if (!room.controllerLink && !room.controllerContainer) {
                return;
            }
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.homeRoom) === room.name; }).length > 0) {
                return;
            }
            if (creeps.filter(c => c.memory.homeRoom === room.name).length >= this.expectedCreepCountInRoom(room)) {
                return;
            }
            const configuration = room.level === 8
                ? {
                    body: BodyParts.new().move().work().carry(2),
                    optionalBody: BodyParts.new().addMultiple([MOVE, WORK, WORK], 7).carry(12)
                }
                : {
                    body: BodyParts.new().move().work(2).carry(),
                    optionalBody: BodyParts.new().work().work().carry().addMultiple([MOVE, WORK, WORK], 16)
                };
            Spawns.addToQue(room, Object.assign(Object.assign({}, configuration), { boosts: this.roomBoosts(room), memory: {
                    homeRoom: room.name
                }, priority: room.level === 8 ? 0 /* Highest */ : 4 /* Low */, role: CONFIG$C.roleName }));
        });
    }
    static roomBoosts(room) {
        if (room.level < 8) {
            return [BOOST_ALIAS.UPGRADE_1, BOOST_ALIAS.UPGRADE_2, BOOST_ALIAS.UPGRADE_3];
        }
        const boosts = [];
        if (Game.market.credits > 1000000000) {
            if (room.storage && room.storage.store[BOOST_ALIAS.UPGRADE_3] > 1000) {
                boosts.push(BOOST_ALIAS.UPGRADE_3);
            }
            if (room.storage && room.storage.store[BOOST_ALIAS.UPGRADE_2] > 1000) {
                boosts.push(BOOST_ALIAS.UPGRADE_2);
            }
            if (room.storage && room.storage.store[BOOST_ALIAS.UPGRADE_1] > 1000) {
                boosts.push(BOOST_ALIAS.UPGRADE_1);
            }
        }
        return boosts;
    }
    static shouldUpgrade(room) {
        if (!room.controller) {
            return false;
        }
        if (room.level < 8) {
            return true;
        }
        if (room.controller.ticksToDowngrade < 60000) {
            return true;
        }
        if (room.storage && room.storage.store.power > CONFIG_BALANCE[RESOURCE_POWER].storageMaxAmount / 2) {
            return false;
        }
        if (room.storage && room.storage.store.energy < 150000) {
            return false;
        }
        if (Game.gcl.level < ROOM_COUNT_GOAL && Rooms.myRooms.length > 10) {
            return true;
        }
        return false;
    }
    static shouldBoostInRoom(room) {
        if (room.level >= 8) {
            return room.store[RESOURCE_CATALYZED_GHODIUM_ACID] > 2000 && Rooms.myRooms.length < ROOM_COUNT_GOAL;
        }
        else {
            return room.store[RESOURCE_CATALYZED_GHODIUM_ACID] > 300;
        }
    }
    static expectedCreepCountInRoom(room) {
        if (!room.controllerContainer) {
            return 1;
        }
        if (room.wasRecentlyUnderAttack) {
            return 1;
        }
        if (!room.controller) {
            return 0;
        }
        if (room.controller.level >= 8 && General.farmingGcl() && room.controller.ticksToDowngrade > 20000) {
            return 0;
        }
        if (room.controller.level >= 8) {
            return 1;
        }
        if (!room.storage) {
            if (room.centerContainers.filter(c => c.store.getFreeCapacity(RESOURCE_ENERGY) === 0).length > 0) {
                return 6;
            }
            return 3;
        }
        const creepsPerStorage = room.shouldConstruct ? 10000 : 20000;
        const openSpots = Object.values(room.controllerContainers.reduce((positions, container) => {
            const key = function (pos) {
                return `${pos.x}-${pos.y}`;
            };
            positions[key(container.pos)] = null;
            container.pos.openSpots.forEach(p => {
                positions[key(p)] = null;
            });
            return positions;
        }, {})).length;
        return Math.min(Math.ceil(room.storage.store.energy / creepsPerStorage), openSpots - 1, 4);
    }
    static moveNearStorage(creep) {
        if (!creep.room.controller) {
            return false;
        }
        const storages = creep.room.controller.pos.findInRange(FIND_STRUCTURES, 3, {
            filter: s => (s.structureType === STRUCTURE_CONTAINER || s.structureType === STRUCTURE_LINK) && s.store.energy > 100
        });
        if (storages.length === 0) {
            return false;
        }
        const closeContainers = storages.filter(c => c.pos.isNearTo(creep) && c.store.energy >= 100);
        if (closeContainers.length > 0) {
            return false;
        }
        const controller = creep.room.controller;
        const posiblePositions = storages
            .map(p => {
            const positions = p.pos.openSpots;
            if (p.structureType === STRUCTURE_CONTAINER) {
                positions.push(p.pos);
            }
            return positions;
        })
            .reduce((value, poses) => {
            value.push(...poses);
            return value;
        }, [])
            .filter(pos => !pos.isRoomEdge)
            .filter(pos => pos.lookFor(LOOK_CREEPS).length === 0)
            .sort((a, b) => a.getRangeTo(controller) - b.getRangeTo(controller))[0];
        if (!posiblePositions) {
            return false;
        }
        // if (creep.pos.getRangeTo(controller) <= posiblePositions.getRangeTo(controller)) {
        //   return false;
        // }
        creep.travel({ pos: posiblePositions }, { range: 0 });
        return true;
    }
    static moveNearController(creep) {
        if (!creep.room.controller) {
            return false;
        }
        if (creep.room.controller.level >= 8) {
            return false;
        }
        const storages = creep.room.controller.pos.findInRange(FIND_STRUCTURES, 3, {
            filter: s => (s.structureType === STRUCTURE_CONTAINER || s.structureType === STRUCTURE_LINK) && s.store.energy > 100
        });
        if (storages.length === 0) {
            return false;
        }
        const controller = creep.room.controller;
        const posiblePositions = storages
            .map(p => [...p.pos.openSpots, p.pos])
            .reduce((value, poses) => {
            value.push(...poses);
            return value;
        }, [])
            .filter(pos => !pos.isRoomEdge)
            .filter(pos => pos.lookFor(LOOK_CREEPS).length === 0)
            .filter(pos => pos.isNearTo(creep))
            .sort((a, b) => a.getRangeTo(controller) - b.getRangeTo(controller))[0];
        if (!posiblePositions) {
            return false;
        }
        if (creep.pos.getRangeTo(controller) <= posiblePositions.getRangeTo(controller)) {
            return false;
        }
        creep.travel({ pos: posiblePositions }, { range: 0 });
        return true;
    }
    static moveToController(creep) {
        if (!creep.room.controller) {
            return false;
        }
        if (!creep.room.controller.my) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.controller);
        if (distance > 4) {
            creep.travel(creep.room.controller, { range: 3 });
        }
        else if (distance > 3) {
            creep.travel(creep.room.controller, { range: 3, ignoreCreeps: false, freshPath: true });
        }
        return true;
    }
    static upgradeController(creep) {
        if (creep.store.energy === 0) {
            return false;
        }
        if (!creep.room.controller) {
            return false;
        }
        if (!creep.room.controller.my) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.controller);
        if (distance > 3) {
            return false;
        }
        creep.upgradeController(creep.room.controller);
        return true;
    }
    static repairContainer(creep) {
        if (creep.store.energy === 0) {
            return false;
        }
        if (!creep.room.controller) {
            return false;
        }
        if (creep.room.controller.level >= 8) {
            return false;
        }
        if (!creep.room.controllerContainer) {
            return false;
        }
        if (creep.room.controllerContainer.hits > 200000) {
            return false;
        }
        if (creep.repair(creep.room.controllerContainer) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.room.controllerContainer, { range: 3 });
        }
        return true;
    }
    static withdrawEnergyFromContainerOrLink(creep) {
        if (creep.store.energy > creep.body.filter(c => c.type === WORK).length * 2) {
            return false;
        }
        const storages = [creep.room.controllerLink, ...creep.room.controllerContainers].filter(structure => structure !== null && structure.store.energy > 0);
        const storage = storages.sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0];
        if (!storage) {
            return false;
        }
        if (!storage.store.energy) {
            return false;
        }
        const distance = creep.pos.getRangeTo(storage);
        if (distance > 1) {
            creep.travel(storage);
        }
        else {
            creep.withdraw(storage, RESOURCE_ENERGY);
            return false;
        }
        return true;
    }
    static suicide(creep) {
        // if (creep.room.level >= 4 && !creep.room.storage) {
        //   creep.recycleFinal(1500);
        //
        //   return true;
        // }
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > 20) {
            return false;
        }
        if (creep.store.energy > 0) {
            return false;
        }
        creep.die();
        return true;
    }
    static suicideWhenTooBig(creep) {
        if (creep.room.level < 8) {
            return false;
        }
        const workPartCount = creep.body.filter(b => b.type === WORK).length;
        if (workPartCount <= 15) {
            return false;
        }
        creep.recycleFinal(1500);
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseUpgrader, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseUpgrader, "handleSpawn", null);

const CONFIG$B = Config.BaseUpgradeHauler;
const CONFIG_BASE_UPGRADER = Config.BaseUpgrader;
class BaseUpgradeHauler {
    static handle() {
        Creeps.getByRole(CONFIG$B.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$B.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
        // General.interval(CONFIG.spawnInterval, () => spawnerRemoteLevel6());
    }
    static handleCreep(creep) {
        this.repurpouseRole(creep) ||
            this.suicide(creep) ||
            this.travelToHomeRoom(creep) ||
            this.withdrawFromStorage(creep) ||
            this.withdrawFromCenterContainer(creep) ||
            this.storeEnergyToContainer(creep) ||
            // storeEnergyToNearbyUpgrader(creep) ||
            this.moveNearContainer(creep) ||
            this.moveAwayFromContainer(creep);
    }
    static suicide(creep) {
        // if (creep.room.level >= 4 && !creep.room.storage) {
        //   creep.recycleFinal(1500);
        //
        //   return true;
        // }
        return creep.recycleFinal(70);
    }
    static repurpouseRole(creep) {
        if (Game.time % 10 !== 0) {
            return false;
        }
        if (!creep.homeRoom) {
            return false;
        }
        if (creep.homeRoom.level !== 8) {
            return false;
        }
        creep.memory.role = Config.BaseEnergyBalancer.roleName;
        return true;
    }
    static travelToHomeRoom(creep) {
        if (!creep.memory.homeRoom) {
            return false;
        }
        if (creep.room.name === creep.memory.homeRoom) {
            return false;
        }
        return creep.travelToRoom(creep.memory.homeRoom);
    }
    static spawnerRemoteLevel6() {
        Rooms.myRooms.forEach(room => {
            if (room.isAbandoning) {
                return;
            }
            if (!room.controller) {
                return;
            }
            if (room.controller.level !== 6) {
                return;
            }
            if (!room.storage) {
                return;
            }
            if (room.storage.store.energy < CONFIG$B.spawnMinStorageEnergy) {
                return;
            }
            if (room.controllerContainers.length === 0) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({
                minTicksToLive: 300,
                homeRoom: room.name,
                role: CONFIG$B.roleName
            });
            const upgraderCount = Creeps.creepsCountWithQue({
                minTicksToLive: 300,
                homeRoom: room.name,
                role: CONFIG_BASE_UPGRADER.roleName
            });
            if (creepsCount >= 2 + upgraderCount) {
                return;
            }
            const spawnRooms = Geo.closestHomeRoomsByRange(room.name, 3, {
                maxDistance: 10,
                room: r => r.level >= 8
            });
            if (spawnRooms.length === 0) {
                return;
            }
            Spawns.addToQue(spawnRooms, {
                body: BodyParts.new().addMultiple([MOVE, CARRY], 3),
                optionalBody: BodyParts.new().addMultiple([MOVE, CARRY, CARRY], 15),
                priority: CONFIG$B.spawnPriority,
                role: CONFIG$B.roleName,
                memory: {
                    homeRoom: room.name,
                    targetRoom: room.name
                }
            });
        });
    }
    static handleSpawn() {
        Rooms.myRooms.forEach(room => {
            var _a;
            if (room.isAbandoning) {
                return;
            }
            if (!room.controller) {
                return;
            }
            if (room.controller.level >= 8) {
                return;
            }
            if (General.expansionWithSupport() && room.level < 6) {
                return;
            }
            // if (room.underAttack) {
            //   return;
            // }
            if (room.controllerContainers.length === 0) {
                return;
            }
            const center = ((_a = room.storage) === null || _a === void 0 ? void 0 : _a.pos) || room.center;
            if (!center) {
                return;
            }
            const que = Creeps.que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.homeRoom) === room.name && q.memory.role === CONFIG$B.roleName; });
            if (que.length >= 2) {
                return;
            }
            const creeps = Creeps.getByRole(CONFIG$B.roleName).filter(c => c.memory.homeRoom === room.name && (!c.ticksToLive || c.ticksToLive > 500));
            const upgraderCreeps = room
                .find(FIND_MY_CREEPS)
                .filter(creep => creep.memory.role === CONFIG_BASE_UPGRADER.roleName && (!creep.ticksToLive || creep.ticksToLive > 300));
            const upgradeUsesEnergyPerTick = upgraderCreeps.reduce((total, creep) => total + creep.body.filter(b => b.type === WORK).length, 0);
            const distance = room.distanceToTarget(room.controller, 1);
            if (!distance) {
                Log.object(room.controller, "BaseUpgradeHauler", "cant find distance");
                return;
            }
            const carryPartPerTick = CARRY_CAPACITY / (distance * 2);
            const currentCarryPerTick = creeps.reduce((total, creep) => total + creep.body.filter(b => b.type === CARRY).length, 0) * carryPartPerTick;
            if (upgradeUsesEnergyPerTick <= currentCarryPerTick * 0.7) {
                return;
            }
            Spawns.addToQue(room, {
                body: BodyParts.new().addMultiple([MOVE, CARRY], 3),
                optionalBody: BodyParts.new().addMultiple([MOVE, CARRY, CARRY], 15),
                priority: 3 /* Medium */,
                role: CONFIG$B.roleName,
                memory: {
                    homeRoom: room.name,
                    targetRoom: room.name
                }
            });
        });
    }
    static moveAwayFromContainer(creep) {
        return creep.idleAwayFrom([STRUCTURE_CONTAINER, STRUCTURE_STORAGE, STRUCTURE_TERMINAL], 4);
    }
    static moveNearContainer(creep) {
        if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {
            return false;
        }
        const container = creep.room.controllerContainers
            // .filter(c => c.store.energy <= 1500)
            .sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0];
        if (!container) {
            return false;
        }
        const distance = creep.pos.getRangeTo(container);
        if (distance <= 5) {
            return false;
        }
        creep.travel(container, {
            range: 1,
            freshPath: distance <= 3,
            ignoreCreeps: distance > 3,
            maxOps: distance <= 3 ? 200 : undefined
        });
        return true;
    }
    static storeEnergyToNearbyUpgrader(creep) {
        if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {
            return false;
        }
        const nearbyUpgrader = creep.pos
            .findInRange(FIND_MY_CREEPS, 1)
            .find(c => c.memory.role === CONFIG_BASE_UPGRADER.roleName && c.store.getFreeCapacity(RESOURCE_ENERGY) >= 100);
        if (!nearbyUpgrader) {
            return false;
        }
        creep.transfer(nearbyUpgrader, RESOURCE_ENERGY);
        return true;
    }
    static storeEnergyToContainer(creep) {
        if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {
            return false;
        }
        if (!creep.room.controllerContainers) {
            return false;
        }
        const container = creep.room.controllerContainers
            .filter(c => c.store.energy < 1000)
            .sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0];
        if (!container) {
            return false;
        }
        const distance = creep.pos.getRangeTo(container);
        if (distance > 3) {
            creep.travel(container, {
                ignoreCreeps: false,
                freshPath: true
            });
        }
        else {
            creep.travel(container, {
                maxOps: 200,
                freshPath: true,
                ignoreCreeps: false
            });
        }
        if (distance <= 1) {
            creep.transfer(container, RESOURCE_ENERGY);
        }
        return true;
    }
    static withdrawFromStorage(creep) {
        if (creep.store.getUsedCapacity() > 0) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        if (creep.room.storage.store.energy < 1000) {
            return false;
        }
        if (creep.withdraw(creep.room.storage, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.room.storage);
        }
        return true;
    }
    static withdrawFromCenterContainer(creep) {
        if (creep.store.getUsedCapacity() > 0) {
            return false;
        }
        const container = creep.room.centerContainers.find(c => c.store.energy >= 50);
        if (!container) {
            return false;
        }
        if (creep.withdraw(container, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
            creep.travel(container);
        }
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseUpgradeHauler, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseUpgradeHauler, "handleSpawn", null);

const ROLE_NAME$e = roles.BaseWallRepairer;
const SPAWN_MIN_STORAGE_ENERGY = 60000;
const MIN_BOOSTS_IN_STORAGE = 5000;
const NUKE_DAMAGE_RANGE = { 0: 10000000, 1: 5000000, 2: 5000000 };
const HITS_PER_COMPLETE_ROOM = 500000;
class BaseWallRepairer {
    static handle() {
        Creeps.getByRole(ROLE_NAME$e)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(56, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        if (!creep.target) {
            creep.target = this.findTarget(creep);
        }
        this.build(creep) || this.repair(creep);
        this.moveToHomeRoom(creep) ||
            creep.boost({ minTicksToLive: 1400 }) ||
            creep.recycleFinal(70) ||
            this.withdrawEnergy(creep) ||
            this.moveToTarget(creep);
    }
    static moveToHomeRoom(creep) {
        if (!creep.memory.homeRoom) {
            return false;
        }
        return creep.travelToRoom(creep.memory.homeRoom);
    }
    static handleSpawn() {
        const creeps = Creeps.getByRole(ROLE_NAME$e);
        const que = Creeps.queByRole(ROLE_NAME$e);
        Rooms.myRooms.forEach(room => {
            if (room.isAbandoning) {
                return;
            }
            if (!room.storage) {
                return;
            }
            if (room.storage.store.energy < SPAWN_MIN_STORAGE_ENERGY) {
                return;
            }
            const constructions = room.find(FIND_MY_CONSTRUCTION_SITES).filter(s => s.structureType === STRUCTURE_RAMPART);
            const nukes = room.find(FIND_NUKES);
            const defenses = room
                .find(FIND_STRUCTURES)
                .filter(s => s.structureType === STRUCTURE_RAMPART && this.rampartHits(s, nukes) < this.maxRampartHits(room));
            if (constructions.length === 0 && defenses.length === 0) {
                return;
            }
            if (que.find(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.homeRoom) === room.name; })) {
                return;
            }
            if (creeps.filter(c => (!c.ticksToLive || c.ticksToLive > 160) && c.memory.homeRoom === room.name).length >=
                this.getExpectedCreepCount(room, nukes)) {
                return;
            }
            Spawns.addToQue(room, {
                body: new BodyParts().addMultiple([MOVE, WORK, CARRY]).get(),
                optionalBody: new BodyParts().addMultiple([MOVE, WORK, CARRY], 20).get(),
                memory: { targetRoom: room.name, homeRoom: room.name },
                boosts: this.roomBoosts(room, nukes),
                priority: 2 /* High */,
                role: ROLE_NAME$e
            });
        });
    }
    static maxRampartHits(room) {
        switch (room.level) {
            case 8: {
                return General.myCompleteRoomCount * HITS_PER_COMPLETE_ROOM;
            }
            case 7:
                return 1000000;
            case 6:
            case 5:
            case 4:
            case 3: {
                return 300000;
            }
            case 2:
            case 1: {
                return 100000;
            }
        }
        return General.myCompleteRoomCount * HITS_PER_COMPLETE_ROOM;
    }
    static roomBoosts(room, nukes) {
        const boosts = [];
        if (!room.storage) {
            return boosts;
        }
        if (nukes.length > 0 || room.wasRecentlyUnderAttack) {
            boosts.push(BOOST_ALIAS.REPAIR_BUILD_3, BOOST_ALIAS.REPAIR_BUILD_2, BOOST_ALIAS.REPAIR_BUILD_1, BOOST_ALIAS.CARRY_3, BOOST_ALIAS.CARRY_2, BOOST_ALIAS.CARRY_1);
        }
        else {
            if (room.storage.store[BOOST_ALIAS.REPAIR_BUILD_3] > MIN_BOOSTS_IN_STORAGE) {
                boosts.push(BOOST_ALIAS.REPAIR_BUILD_3);
            }
            if (room.storage.store[BOOST_ALIAS.REPAIR_BUILD_2] > MIN_BOOSTS_IN_STORAGE) {
                boosts.push(BOOST_ALIAS.REPAIR_BUILD_2);
            }
            if (room.storage.store[BOOST_ALIAS.REPAIR_BUILD_1] > MIN_BOOSTS_IN_STORAGE) {
                boosts.push(BOOST_ALIAS.REPAIR_BUILD_1);
            }
            if (boosts.length > 0) {
                if (room.storage.store[BOOST_ALIAS.CARRY_3] > MIN_BOOSTS_IN_STORAGE) {
                    boosts.push(BOOST_ALIAS.CARRY_3);
                }
                if (room.storage.store[BOOST_ALIAS.CARRY_2] > MIN_BOOSTS_IN_STORAGE) {
                    boosts.push(BOOST_ALIAS.CARRY_2);
                }
                if (room.storage.store[BOOST_ALIAS.CARRY_1] > MIN_BOOSTS_IN_STORAGE) {
                    boosts.push(BOOST_ALIAS.CARRY_1);
                }
            }
        }
        return boosts;
    }
    static roomSpawnBoosts(room) {
        const boosts = [];
        if (room.store[RESOURCE_CATALYZED_LEMERGIUM_ACID] >= 5000) {
            boosts.push(RESOURCE_CATALYZED_LEMERGIUM_ACID);
        }
        else if (room.store[RESOURCE_LEMERGIUM_ACID] >= 5000) {
            boosts.push(RESOURCE_LEMERGIUM_ACID);
        }
        if (room.level > 6 && room.labs.length > 4) {
            if (room.store[RESOURCE_CATALYZED_KEANIUM_ACID] >= 5000) {
                boosts.push(RESOURCE_CATALYZED_KEANIUM_ACID);
            }
            else if (room.store[RESOURCE_KEANIUM_ACID] >= 5000) {
                boosts.push(RESOURCE_KEANIUM_ACID);
            }
        }
        return boosts;
    }
    static getExpectedCreepCount(room, nukes) {
        if (!room.storage) {
            return 0;
        }
        if (room.storage.store.energy < 10000) {
            return 0;
        }
        if (room.wasRecentlyUnderAttack) {
            return 3;
        }
        if (room.find(FIND_NUKES).length > 0) {
            return 5;
        }
        if (room.storage.store.energy >= 150000) {
            return 5;
        }
        // if (room.storage.store.energy >= 200_000 && room.storage.store.power < 1_000) {
        //   return 3;
        // }
        if (nukes.length > 0) {
            return 3;
        }
        if (room.level === 6) {
            return room.storage.store.energy > 100000 ? 2 : 1;
        }
        if (room.level === 7) {
            return room.storage.store.energy > 100000 ? 2 : 1;
        }
        return 1;
    }
    static findTarget(creep) {
        return this.findJustBuiltRampart(creep) || this.findRampartConstruction(creep) || this.findLowestRampart(creep);
    }
    static findLowestRampart(creep) {
        const nukes = creep.room.find(FIND_NUKES);
        const ramparts = creep.room.find(FIND_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_WALL
        });
        return ramparts.sort((a, b) => this.rampartHits(a, nukes) - this.rampartHits(b, nukes))[0] || null;
    }
    static rampartHits(rampart, nukes) {
        let hits = rampart instanceof StructureWall ? rampart.hits * 1.5 : rampart.hits;
        nukes.forEach(nuke => {
            const distance = nuke.pos.getRangeTo(rampart);
            const damage = NUKE_DAMAGE_RANGE[distance];
            if (damage) {
                hits -= damage;
            }
        });
        return hits;
    }
    static findRampartConstruction(creep) {
        return creep.pos.findClosestByRange(FIND_MY_CONSTRUCTION_SITES, {
            filter: c => c.structureType === STRUCTURE_RAMPART || c.structureType === STRUCTURE_WALL
        });
    }
    static findJustBuiltRampart(creep) {
        var _a;
        return ((_a = creep.pos.findInRange(FIND_STRUCTURES, 3, {
            filter: s => s.structureType === STRUCTURE_RAMPART && !s.pos.isRoomEdge && s.hits === 1
        })[0]) !== null && _a !== void 0 ? _a : null);
    }
    static build(creep) {
        if (!(creep.target instanceof ConstructionSite)) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.target);
        if (distance > 3) {
            return false;
        }
        creep.build(creep.target);
        return true;
    }
    static repair(creep) {
        if (!(creep.target instanceof StructureRampart) && !(creep.target instanceof StructureWall)) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.target);
        if (distance <= 3) {
            creep.repair(creep.target);
        }
        return true;
    }
    static withdrawEnergy(creep) {
        if (creep.store.energy > 0) {
            return false;
        }
        creep.target = null;
        return creep.withdrawFromStorage(RESOURCE_ENERGY) || creep.withdrawFromTerminal(RESOURCE_ENERGY);
    }
    static moveToTarget(creep) {
        if (creep.store.energy === 0) {
            return false;
        }
        if (!creep.target) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.target);
        const isClose = distance <= 4;
        if (creep.room.wasRecentlyUnderAttack) {
            return creep.travel(creep.target, {
                range: 3,
                ignoreCreeps: !isClose,
                freshPath: isClose,
                maxOps: isClose ? 200 : undefined,
                roomCallback: (room, matrix) => {
                    room.edgeDangerPositions.forEach(p => {
                        if (p.pos.x === 0 || p.pos.y === 0 || p.pos.x === 49 || p.pos.y === 49) {
                            matrix.set(p.pos.x, p.pos.y, 256);
                        }
                        else {
                            matrix.set(p.pos.x, p.pos.y, 200);
                        }
                    });
                    return matrix;
                }
            });
        }
        else {
            if (distance > 3) {
                return (creep.travel(creep.target, {
                    range: 1,
                    ignoreCreeps: true,
                    freshPath: false,
                    roomCallback: (room, matrix) => {
                        room.edgeDangerPositions.forEach(p => {
                            if (p.pos.x === 0 || p.pos.y === 0 || p.pos.x === 49 || p.pos.y === 49) {
                                matrix.set(p.pos.x, p.pos.y, 256);
                            }
                            else {
                                matrix.set(p.pos.x, p.pos.y, 10);
                            }
                        });
                        return matrix;
                    }
                }) ||
                    creep.travel(creep.target, {
                        range: 3,
                        ignoreCreeps: true,
                        freshPath: false,
                        roomCallback: (room, matrix) => {
                            room.edgeDangerPositions.forEach(p => {
                                if (p.pos.x === 0 || p.pos.y === 0 || p.pos.x === 49 || p.pos.y === 49) {
                                    matrix.set(p.pos.x, p.pos.y, 256);
                                }
                                else {
                                    matrix.set(p.pos.x, p.pos.y, 10);
                                }
                            });
                            return matrix;
                        }
                    }));
            }
            else if (distance > 1) {
                return creep.travel(creep.target, {
                    range: distance - 1,
                    ignoreCreeps: false,
                    freshPath: true,
                    maxOps: 20,
                    roomCallback: (room, matrix) => {
                        room.edgeDangerPositions.forEach(p => {
                            if (p.pos.x === 0 || p.pos.y === 0 || p.pos.x === 49 || p.pos.y === 49) {
                                matrix.set(p.pos.x, p.pos.y, 256);
                            }
                            else {
                                matrix.set(p.pos.x, p.pos.y, 10);
                            }
                        });
                        return matrix;
                    }
                });
            }
            return true;
        }
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseWallRepairer, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseWallRepairer, "handleSpawn", null);

const CONFIG$A = Config.BaseRampartDefender;
class BaseRampartDefender {
    static handle() {
        Creeps.getByRole(CONFIG$A.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$A.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        creep.rangedBestAttack();
        this.attack(creep);
        this.boost(creep) ||
            // this.moveToFlag(creep) ||
            this.moveToAnyHostiles(creep) ||
            this.recycle(creep) ||
            this.escapeEdge(creep) ||
            this.moveToHostiles(creep) ||
            this.moveToFlag(creep) ||
            this.moveToGreenFlag(creep) ||
            creep.idleAwayFrom([STRUCTURE_SPAWN, STRUCTURE_LAB], 6);
    }
    static recycle(creep) {
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > 100) {
            return false;
        }
        if (creep.room.wasRecentlyUnderAttack) {
            return false;
        }
        return creep.recycleFinal();
    }
    static escapeEdge(creep) {
        var _a;
        if (creep.body.filter(b => b.type === TOUGH).length === 0) {
            return false;
        }
        if (creep.toughReducedHits) {
            return false;
        }
        if (creep.pos.hasRampart) {
            return true;
        }
        if (creep.pos.x !== 48 && creep.pos.x !== 1 && creep.pos.y !== 48 && creep.pos.y !== 1) {
            return false;
        }
        if (!((_a = creep.homeRoom) === null || _a === void 0 ? void 0 : _a.center)) {
            return false;
        }
        creep.travel({ pos: creep.homeRoom.center });
        return true;
    }
    static moveAwayFromSpawns(creep) {
        const closeSpawns = creep.pos.findInRange(FIND_MY_SPAWNS, 2);
        if (closeSpawns.length === 0) {
            return false;
        }
        const ret = PathFinder.search(creep.pos, closeSpawns.map(s => ({ pos: s.pos, range: 4 })), {
            flee: true,
            roomCallback(roomName) {
                return creep.room.matrix();
            }
        });
        if (ret.incomplete) {
            return false;
        }
        creep.moveByPath(ret.path);
        return true;
    }
    static moveToFlag(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        creep.travel(creep.targetFlag, { range: 0 });
        return true;
    }
    static moveToGreenFlag(creep) {
        if (creep.memory.stationary) {
            return false;
        }
        const flag = creep.room
            .find(FIND_FLAGS)
            .filter(f => f.color === COLOR_GREEN && f.secondaryColor === COLOR_GREEN)[0];
        if (!flag) {
            return false;
        }
        creep.travel(flag);
        return true;
    }
    static boost(creep) {
        if (!creep.room.underAttack) {
            return false;
        }
        // const offensivePower =
        //   creep.room.hostileDismantlePower + creep.room.hostileAttackPower + creep.room.hostileRangedAttackPower;
        //
        // if (offensivePower < 500) {
        //   return false;
        // }
        return creep.boost({ minTicksToLive: 300 });
    }
    static moveToAnyHostiles(creep) {
        if (!creep.toughReducedHits) {
            return false;
        }
        const hostile = creep.targetFlag
            ? creep.targetFlag.pos.findClosestByRange(FIND_HOSTILE_CREEPS)
            : creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
        if (!hostile) {
            return false;
        }
        if (creep.targetFlag && creep.targetFlag.pos.getRangeTo(creep.targetFlag) > 8) {
            return false;
        }
        const distance = creep.pos.getRangeTo(hostile);
        if (hostile.pos.isRoomEdge && distance <= 1) {
            return true;
        }
        creep.travel(hostile);
        return true;
    }
    static attack(creep) {
        const hostile = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 1)[0];
        if (!hostile) {
            return;
        }
        creep.attack(hostile);
    }
    static handleSpawn() {
        const creeps = Creeps.getByRole(CONFIG$A.roleName).filter(c => !c.ticksToLive || c.ticksToLive > 400);
        const que = Creeps.queByRole(CONFIG$A.roleName);
        Rooms.myRooms.forEach(room => {
            this.handleRoom(room, que, creeps);
            // if (room.level < 8) {
            //   this.handleLowRoomSpawn(room);
            // } else {
            //   this.handleCompleteRoomSpawn(room);
            // }
        });
    }
    static handleLowRoomSpawn(room) {
        if (room.isGclFarm) {
            return;
        }
        if (room.level < 6) {
            return;
        }
        const creepsCount = Creeps.creepsCountWithQue({
            minTicksToLive: 400,
            homeRoom: room.name,
            role: CONFIG$A.roleName
        });
        if (creepsCount > 0) {
            return;
        }
        if (room.energyCapacityAvailable >= 3770) {
            Spawns.addToQue(room, {
                body: BodyParts.new().rangedAttack().attack(39).move(10),
                boosts: [RESOURCE_CATALYZED_UTRIUM_ACID, RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE],
                priority: CONFIG$A.spawnPriority,
                role: CONFIG$A.roleName
            });
        }
        else if (room.energyCapacityAvailable >= 3320) {
            Spawns.addToQue(room, {
                body: BodyParts.new().rangedAttack().attack(24).move(25),
                boosts: [RESOURCE_CATALYZED_UTRIUM_ACID, RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE],
                priority: CONFIG$A.spawnPriority,
                role: CONFIG$A.roleName
            });
        }
        else {
            Spawns.addToQue(room, {
                body: new BodyParts().addMultiple([MOVE, RANGED_ATTACK], 1),
                optionalBody: new BodyParts().addMultiple([MOVE, ATTACK], 24),
                boosts: [RESOURCE_CATALYZED_UTRIUM_ACID],
                priority: CONFIG$A.spawnPriority,
                role: CONFIG$A.roleName
            });
        }
    }
    static handleRoom(room, que, creeps) {
        if (!room.center) {
            return;
        }
        if (room.isGclFarm) {
            return;
        }
        if (!room.controller) {
            return;
        }
        const lowSafeMode = room.controller.safeMode && room.controller.safeMode < 500;
        if (!room.wasRecentlyUnderAttack && !room.controller.safeModeCooldown && !lowSafeMode) {
            return;
        }
        const roomQue = que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.homeRoom) === room.name; });
        const roomCreeps = creeps.filter(c => c.memory.homeRoom === room.name);
        const creepsCount = roomQue.length + roomCreeps.length;
        if (room.energyCapacityAvailable >= 3770) {
            if (creepsCount >= 2) {
                return;
            }
            Spawns.addToQue(room, {
                body: BodyParts.new().rangedAttack().attack(39).move(10),
                boosts: [RESOURCE_CATALYZED_UTRIUM_ACID, RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE],
                priority: CONFIG$A.spawnPriority,
                role: CONFIG$A.roleName,
                memory: {
                    homeRoom: room.name
                }
            });
        }
        else if (room.energyCapacityAvailable >= 3320) {
            if (creepsCount >= 2) {
                return;
            }
            Spawns.addToQue(room, {
                body: BodyParts.new().rangedAttack().attack(24).move(25),
                boosts: [RESOURCE_CATALYZED_UTRIUM_ACID, RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE],
                priority: CONFIG$A.spawnPriority,
                role: CONFIG$A.roleName,
                memory: {
                    homeRoom: room.name
                }
            });
        }
        else {
            if (creepsCount >= 3) {
                return;
            }
            Spawns.addToQue(room, {
                body: new BodyParts().addMultiple([MOVE, RANGED_ATTACK], 1),
                optionalBody: new BodyParts().addMultiple([MOVE, ATTACK], 24),
                boosts: [RESOURCE_CATALYZED_UTRIUM_ACID],
                priority: CONFIG$A.spawnPriority,
                role: CONFIG$A.roleName,
                memory: {
                    homeRoom: room.name
                }
            });
        }
    }
    static moveToHostiles(creep) {
        if (creep.memory.stationary) {
            return false;
        }
        const meleHostile = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 1);
        if (meleHostile.length > 0) {
            return true;
        }
        const target = creep.targetFlag
            ? creep.targetFlag.pos
                .findInRange(FIND_HOSTILE_CREEPS, 9)
                .filter(c => c.pos.findInRange(FIND_MY_STRUCTURES, 1, { filter: s => s.structureType === STRUCTURE_RAMPART }).length >
                0 && c.dismantlePower > 300)
                .sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0] ||
                creep.targetFlag.pos
                    .findInRange(FIND_HOSTILE_CREEPS, 9)
                    .filter(c => c.pos.findInRange(FIND_MY_STRUCTURES, 1, { filter: s => s.structureType === STRUCTURE_RAMPART }).length >
                    0 && c.attackPower + c.rangedAttackPower + c.healPower + c.dismantlePower > 300
                // c.healPower + c.harvestPower > 0
                // c.harvestPower > 0
                )
                    .sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0]
            : creep.room
                .find(FIND_HOSTILE_CREEPS)
                .filter(c => c.pos.findInRange(FIND_MY_STRUCTURES, 1, { filter: s => s.structureType === STRUCTURE_RAMPART }).length >
                0 && c.dismantlePower > 300)
                .sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0] ||
                creep.room
                    .find(FIND_HOSTILE_CREEPS)
                    .filter(c => c.pos.findInRange(FIND_MY_STRUCTURES, 1, { filter: s => s.structureType === STRUCTURE_RAMPART }).length >
                    0 && c.attackPower + c.rangedAttackPower + c.healPower + c.dismantlePower > 300
                // c.healPower + c.harvestPower > 0
                // c.harvestPower > 0
                )
                    .sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0];
        if (!target) {
            return false;
        }
        const terrain = creep.room.getTerrain();
        const ret = PathFinder.search(creep.pos, target.pos, {
            maxRooms: 1,
            maxOps: 5000,
            swampCost: 5,
            roomCallback(roomName) {
                const costMatrix = creep.room.matrix();
                if (roomName !== creep.room.name) {
                    return false;
                }
                creep.room.find(FIND_HOSTILE_CREEPS).forEach(c => {
                    if (c.rangedAttackPower) {
                        General.squareCoordinatesFilled(c.pos.roomName, c.pos.x, c.pos.y, 2).forEach(p => {
                            if (terrain.get(p.x, p.y) === TERRAIN_MASK_WALL) {
                                return;
                            }
                            if (p.hasRampart) {
                                return;
                            }
                            costMatrix.set(p.x, p.y, 30);
                        });
                        General.squarePositions(c.pos.roomName, c.pos.x, c.pos.y, 3).forEach(p => {
                            if (terrain.get(p.x, p.y) === TERRAIN_MASK_WALL) {
                                return;
                            }
                            if (p.hasRampart) {
                                return;
                            }
                            costMatrix.set(p.x, p.y, 5);
                        });
                    }
                    if (c.attackPower) {
                        General.squareCoordinatesFilled(c.pos.roomName, c.pos.x, c.pos.y, 1).forEach(p => {
                            if (terrain.get(p.x, p.y) === TERRAIN_MASK_WALL) {
                                return;
                            }
                            if (p.hasRampart) {
                                return;
                            }
                            costMatrix.set(p.x, p.y, 90);
                        });
                    }
                });
                creep.room.find(FIND_MY_STRUCTURES, { filter: s => s.structureType === STRUCTURE_RAMPART }).forEach(rampart => {
                    if (costMatrix.get(rampart.pos.x, rampart.pos.y) >= 200) {
                        return;
                    }
                    costMatrix.set(rampart.pos.x, rampart.pos.y, 1);
                });
                creep.room.find(FIND_MY_CREEPS).forEach(c => {
                    costMatrix.set(c.pos.x, c.pos.y, 256);
                });
                creep.room.edgeDangerPositions.forEach(pos => {
                    costMatrix.set(pos.pos.x, pos.pos.y, 256);
                });
                costMatrix.set(target.pos.x, target.pos.y, 0);
                return costMatrix;
            }
        });
        if (ret.incomplete) {
            ret.path.forEach(p => {
                new RoomVisual(p.roomName).circle(p.x, p.y, { radius: 0.2 });
            });
            // Log.object(creep, "incomplete");
            return false;
        }
        creep.moveByPath(ret.path);
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseRampartDefender, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseRampartDefender, "handleSpawn", null);

const ROLE_NAME$d = "sourceKeeperEnergyHauler";
const SPAWN_PRIORITY$5 = 6 /* Lowest */;
const SPAWN_INTERVAL$5 = 63;
const MAX_HOSTILE_POWER$5 = 500;
class SKEnergyHauler {
    static handle() {
        Creeps.getByRole(ROLE_NAME$d)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.worker(creep);
        });
        General.interval(SPAWN_INTERVAL$5, () => TickAction.add(() => this.spawner()));
    }
    static worker(creep) {
        creep.recycleFinal(200) ||
            creep.kiteSk() ||
            this.pickEnergyFromUnderneath(creep) ||
            this.withdrawEnergyFromContainer(creep) ||
            this.storeEnergy(creep);
    }
    static spawner() {
        const creeps = Creeps.getByRole(ROLE_NAME$d).filter(c => !c.ticksToLive || c.ticksToLive > 300);
        const que = Creeps.queByRole(ROLE_NAME$d);
        Rooms.skMiningRooms.forEach(({ homeRoomModel, targetRoomModel }) => {
            if (homeRoomModel.level < 8) {
                return;
            }
            if (!homeRoomModel.room) {
                return;
            }
            if (homeRoomModel.room.wasRecentlyUnderAttack) {
                return;
            }
            if (homeRoomModel.room.isSiegeBase) {
                return;
            }
            if (homeRoomModel.room.isAbandoning) {
                return;
            }
            if (!targetRoomModel.room) {
                return;
            }
            if (targetRoomModel.pvpDeaths > 50) {
                return;
            }
            if (targetRoomModel.hostilePower(ATTACK, RANGED_ATTACK) > MAX_HOSTILE_POWER$5) {
                return;
            }
            targetRoomModel.room.find(FIND_SOURCES).forEach(source => {
                if (!homeRoomModel.room) {
                    return;
                }
                const containers = source.pos
                    .findInRange(FIND_STRUCTURES, 1)
                    .filter(s => s.structureType === STRUCTURE_CONTAINER);
                if (containers.length === 0) {
                    return;
                }
                if (que.filter(c => { var _a; return ((_a = c.memory) === null || _a === void 0 ? void 0 : _a.targetId) === source.id; }).length >= 1) {
                    return;
                }
                if (creeps.filter(c => c.memory.targetId === source.id).length >= 1) {
                    return;
                }
                Spawns.addToQue(homeRoomModel.room, {
                    body: BodyParts.new().addMultiple([MOVE, CARRY, CARRY, CARRY, CARRY], 10).get(),
                    priority: SPAWN_PRIORITY$5,
                    role: ROLE_NAME$d,
                    memory: {
                        targetId: source.id,
                        targetRoom: targetRoomModel.roomName
                    }
                });
            });
        });
    }
    static withdrawEnergyFromContainer(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (!(creep.target instanceof Source)) {
            return false;
        }
        if (!creep.target.container) {
            return false;
        }
        if (creep.target.container.store.energy < Math.min(1000, creep.store.getFreeCapacity())) {
            return false;
        }
        if (creep.withdraw(creep.target.container, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.target.container);
        }
        return true;
    }
    static storeEnergy(creep) {
        if (creep.store.getFreeCapacity() > 0) {
            return false;
        }
        if (!creep.homeRoom) {
            return false;
        }
        if (!creep.homeRoom.storage) {
            return false;
        }
        if (creep.transfer(creep.homeRoom.storage, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.homeRoom.storage);
        }
        return true;
    }
    static pickEnergyFromUnderneath(creep) {
        if (creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {
            return false;
        }
        const resource = creep.pos.lookFor(LOOK_RESOURCES).filter(r => r.resourceType === RESOURCE_ENERGY)[0];
        if (!resource) {
            return false;
        }
        creep.pickup(resource);
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], SKEnergyHauler, "worker", null);
__decorate([
    Profiler.subprofile("spawn")
], SKEnergyHauler, "spawner", null);

const ROLE_NAME$c = "sourceKeeperEnergyMiner";
const SPAWN_PRIORITY$4 = 4 /* Low */;
const SPAWN_INTERVAL$4 = 64;
const MAX_HOSTILE_POWER$4 = 500;
class SKEnergyMiner {
    static handle() {
        Creeps.getByRole(ROLE_NAME$c)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.worker(creep);
        });
        General.interval(SPAWN_INTERVAL$4, () => TickAction.add(() => this.spawner()));
    }
    static worker(creep) {
        this.constructRoads(creep);
        this.suicideWhenReplacementClose(creep) ||
            creep.kiteSk() ||
            this.moveToSource(creep) ||
            this.build(creep) ||
            this.repairContainer(creep) ||
            this.pickEnergyFromUnder(creep) ||
            this.mine(creep);
    }
    static constructRoads(creep) {
        if (!(creep.target instanceof Source)) {
            return;
        }
        if (creep.memory.constructionsCreated && (creep.target.container || creep.target.containerConstruction)) {
            return;
        }
        if (!creep.homeRoom) {
            return;
        }
        if (!creep.homeRoom.storage) {
            return;
        }
        creep.target.pos.createRoadConstructionsFrom(creep.homeRoom.storage.pos);
        creep.memory.constructionsCreated = true;
    }
    static spawner() {
        const creeps = Creeps.getByRole(ROLE_NAME$c).filter(c => !c.ticksToLive || c.ticksToLive > 300);
        const que = Creeps.queByRole(ROLE_NAME$c);
        Rooms.skMiningRooms.forEach(({ homeRoomModel, targetRoomModel }) => {
            if (homeRoomModel.level < 8) {
                return;
            }
            if (!homeRoomModel.room) {
                return;
            }
            if (homeRoomModel.room.wasRecentlyUnderAttack) {
                return;
            }
            if (homeRoomModel.room.isSiegeBase) {
                return;
            }
            if (homeRoomModel.room.isAbandoning) {
                return;
            }
            if (!targetRoomModel.room) {
                return;
            }
            if (targetRoomModel.pvpDeaths > 50) {
                return;
            }
            if (targetRoomModel.hostilePower(ATTACK, RANGED_ATTACK) > MAX_HOSTILE_POWER$4) {
                return;
            }
            targetRoomModel.room.find(FIND_SOURCES).forEach(source => {
                if (!homeRoomModel.room) {
                    return;
                }
                if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetId) === source.id; }).length > 0) {
                    return;
                }
                if (creeps.filter(c => c.memory.targetId === source.id).length > 0) {
                    return;
                }
                Spawns.addToQue(homeRoomModel.room, {
                    body: new BodyParts().add(MOVE, 12).add(WORK, 10).add(CARRY, 2).get(),
                    priority: SPAWN_PRIORITY$4,
                    role: ROLE_NAME$c,
                    memory: {
                        targetId: source.id,
                        sourceId: source.id,
                        targetRoom: targetRoomModel.roomName
                    }
                });
            });
        });
    }
    static suicideWhenReplacementClose(creep) {
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > 300) {
            return false;
        }
        const replacemenet = creep.pos.findInRange(FIND_MY_CREEPS, 2, {
            filter: c => c.memory.sourceId === creep.memory.sourceId && c.memory.role === ROLE_NAME$c && c.id !== creep.id
        })[0];
        if (!replacemenet) {
            return false;
        }
        if (!replacemenet.ticksToLive) {
            return false;
        }
        if (replacemenet.ticksToLive < creep.ticksToLive) {
            return false;
        }
        creep.die();
        return true;
    }
    static moveToSource(creep) {
        if (!(creep.target instanceof Source)) {
            return false;
        }
        if (creep.target.container) {
            if (creep.target.container.pos.isEqualTo(creep.pos)) {
                return false;
            }
            creep.travel(creep.target.container, { range: 0 });
        }
        else {
            if (creep.pos.inRangeTo(creep.target, 1)) {
                return false;
            }
            creep.travel(creep.target);
        }
        return true;
    }
    static build(creep) {
        if (creep.store.energy / creep.store.getCapacity() < 0.5) {
            return false;
        }
        if (!(creep.target instanceof Source)) {
            return false;
        }
        if (!creep.target.containerConstruction) {
            return false;
        }
        creep.build(creep.target.containerConstruction);
        return true;
    }
    static repairContainer(creep) {
        if (!(creep.target instanceof Source)) {
            return false;
        }
        if (creep.store.energy / creep.store.getCapacity() < 0.5) {
            return false;
        }
        if (!creep.target.container) {
            return false;
        }
        if (creep.target.container.hits > 200000) {
            return false;
        }
        if (creep.repair(creep.target.container) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.target.container);
        }
        return true;
    }
    static pickEnergyFromUnder(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        const droppedResource = creep.pos.lookFor(LOOK_RESOURCES)[0];
        if (!droppedResource) {
            return false;
        }
        creep.pickup(droppedResource);
        return true;
    }
    static mine(creep) {
        if (!(creep.target instanceof Source)) {
            return false;
        }
        if (!creep.target.container && !creep.target.containerConstruction) {
            return false;
        }
        if (creep.target.container &&
            creep.target.container.store.getFreeCapacity() < creep.harvestPower &&
            creep.store.getFreeCapacity() < creep.harvestPower) {
            return false;
        }
        if (!creep.target.container && creep.store.getFreeCapacity() < creep.harvestPower) {
            return false;
        }
        creep.harvest(creep.target);
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], SKEnergyMiner, "worker", null);
__decorate([
    Profiler.subprofile("spawn")
], SKEnergyMiner, "spawner", null);

const ROLE_NAME$b = "sourceKeeperLooter";
const SPAWN_PRIORITY$3 = 6 /* Lowest */;
const SPAWN_INTERVAL$3 = 64;
const MAX_HOSTILE_POWER$3 = 500;
class SKLooter {
    static handle() {
        Creeps.getByRole(ROLE_NAME$b)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.worker(creep);
        });
        General.interval(SPAWN_INTERVAL$3, () => TickAction.add(() => this.spawner()));
    }
    static worker(creep) {
        this.clearTarget(creep);
        this.setTarget(creep);
        creep.recycleFinal(100) ||
            creep.kiteSk() ||
            this.pickResources(creep) ||
            this.moveToRoom(creep) ||
            this.storeResources(creep);
    }
    static spawner() {
        Rooms.skMiningRooms.forEach(({ homeRoomModel, targetRoomModel }) => {
            if (homeRoomModel.level < 8) {
                return;
            }
            if (!homeRoomModel.room) {
                return;
            }
            if (homeRoomModel.room.wasRecentlyUnderAttack) {
                return;
            }
            if (homeRoomModel.room.isSiegeBase) {
                return;
            }
            if (homeRoomModel.room.isAbandoning) {
                return;
            }
            if (!targetRoomModel.room) {
                return;
            }
            if (targetRoomModel.pvpDeaths > 50) {
                return;
            }
            if (targetRoomModel.hostilePower(ATTACK, RANGED_ATTACK) > MAX_HOSTILE_POWER$3) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({
                minTicksToLive: 300,
                targetRoom: targetRoomModel.roomName,
                role: ROLE_NAME$b
            });
            if (creepsCount >= 1) {
                return;
            }
            if (!targetRoomModel.room.hasSkDefenders) {
                return;
            }
            const loot = targetRoomModel.room.find(FIND_TOMBSTONES).filter(t => t.store.energy > 200);
            if (loot.length === 0) {
                return;
            }
            Spawns.addToQue(homeRoomModel.room, {
                body: new BodyParts().add(MOVE, 25).add(CARRY, 25).get(),
                priority: SPAWN_PRIORITY$3,
                role: ROLE_NAME$b,
                memory: {
                    targetRoom: targetRoomModel.roomName
                }
            });
        });
    }
    static moveToRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        if (creep.store.getUsedCapacity() > 0) {
            return false;
        }
        return creep.travelToRoom(creep.memory.targetRoom);
    }
    static findTarget(creep) {
        const ruin = creep.pos.findClosestByRange(FIND_RUINS, {
            filter: r => r.store.getUsedCapacity() > 0
        });
        const tombstone = creep.pos.findClosestByRange(FIND_TOMBSTONES, {
            filter: t => t.store.getUsedCapacity() > 0
        });
        const resource = creep.pos.findClosestByRange(FIND_DROPPED_RESOURCES);
        return ([ruin, tombstone, resource].filter(Boolean).sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0] || null);
    }
    static storeResources(creep) {
        if (creep.store.getUsedCapacity() === 0) {
            return false;
        }
        if (!creep.homeRoom) {
            return false;
        }
        if (!creep.homeRoom.storage) {
            return false;
        }
        const resource = Resources.firstStoreResource(creep.store);
        if (!resource) {
            return false;
        }
        if (creep.transfer(creep.homeRoom.storage, resource) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.homeRoom.storage);
        }
        return true;
    }
    static pickResources(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (!creep.target) {
            return false;
        }
        if (creep.target instanceof Ruin) {
            const resource = Resources.firstStoreResource(creep.target.store);
            if (!resource) {
                return false;
            }
            if (creep.withdraw(creep.target, resource)) {
                creep.travel(creep.target);
            }
        }
        else if (creep.target instanceof Tombstone) {
            const resource = Resources.firstStoreResource(creep.target.store);
            if (!resource) {
                return false;
            }
            if (creep.withdraw(creep.target, resource)) {
                creep.travel(creep.target);
            }
        }
        else if (creep.target instanceof Resource) {
            if (creep.pickup(creep.target)) {
                creep.travel(creep.target);
            }
        }
        return true;
    }
    static setTarget(creep) {
        if (creep.target) {
            return;
        }
        creep.target = this.findTarget(creep);
    }
    static clearTarget(creep) {
        if (!creep.target) {
            return;
        }
        if (creep.target instanceof Ruin) {
            if (creep.target.store.getUsedCapacity() === 0) {
                creep.target = null;
            }
        }
        if (creep.target instanceof Tombstone) {
            if (creep.target.store.getUsedCapacity() === 0) {
                creep.target = null;
            }
        }
    }
}
__decorate([
    Profiler.subprofile("creep")
], SKLooter, "worker", null);
__decorate([
    Profiler.subprofile("spawn")
], SKLooter, "spawner", null);

const ROLE_NAME$a = "sourceKeeperMaintainer";
const SPAWN_PRIORITY$2 = 6 /* Lowest */;
const SPAWN_INTERVAL$2 = 65;
const MAX_HOSTILE_POWER$2 = 500;
const DANGER_CONTAINER_HITS = 150000;
const DANGER_ROAD_HITS = 1000;
const REPAIRABLE_HIT_RATIO = 0.9;
class SKMaintainer {
    static handle() {
        Creeps.getByRole(ROLE_NAME$a)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.worker(creep);
        });
        General.interval(SPAWN_INTERVAL$2, () => TickAction.add(() => this.spawner()));
    }
    static worker(creep) {
        if (creep.recycleFinal(100) || creep.kiteSk()) {
            return;
        }
        this.manageState(creep);
        this.buildAround(creep) || this.repairAround(creep);
        this.pickResource(creep);
        this.moveToTargetRoom(creep) || this.moveToTarget(creep); // || pickResource(creep) || moveToConstruction(creep) || moveToLowestBuilding(creep);
    }
    static moveToTarget(creep) {
        if (!creep.target) {
            return;
        }
        creep.travel(creep.target, { range: 1 });
    }
    static moveToTargetRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        return creep.travelToRoom(creep.memory.targetRoom);
    }
    static spawner() {
        Rooms.skMiningRooms.forEach(({ homeRoomModel, targetRoomModel }) => {
            if (homeRoomModel.level < 8) {
                return;
            }
            if (!homeRoomModel.room) {
                return;
            }
            if (homeRoomModel.room.wasRecentlyUnderAttack) {
                return;
            }
            if (homeRoomModel.room.isSiegeBase) {
                return;
            }
            if (homeRoomModel.room.isAbandoning) {
                return;
            }
            if (!targetRoomModel.room) {
                return;
            }
            if (targetRoomModel.pvpDeaths > 50) {
                return;
            }
            if (targetRoomModel.hostilePower(ATTACK, RANGED_ATTACK) > MAX_HOSTILE_POWER$2) {
                return;
            }
            if (!targetRoomModel.room.hasSkDefenders) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({
                minTicksToLive: 300,
                targetRoom: targetRoomModel.roomName,
                role: ROLE_NAME$a
            });
            if (creepsCount >= 1) {
                return;
            }
            const containers = targetRoomModel.room.find(FIND_STRUCTURES, {
                filter: s => s.structureType === STRUCTURE_CONTAINER
            });
            if (containers.length === 0) {
                return;
            }
            const lowContainers = targetRoomModel.room.find(FIND_STRUCTURES, {
                filter: s => s.structureType === STRUCTURE_CONTAINER && s.hits < DANGER_CONTAINER_HITS && s.ticksToDecay < 1000
            });
            const lowRoads = targetRoomModel.room.find(FIND_STRUCTURES, {
                filter: s => s.structureType === STRUCTURE_ROAD && s.hits < DANGER_ROAD_HITS && s.ticksToDecay < 1000
            });
            const constructions = targetRoomModel.room.find(FIND_MY_CONSTRUCTION_SITES);
            if (lowContainers.length === 0 && lowRoads.length === 0 && constructions.length === 0) {
                return;
            }
            Spawns.addToQue(homeRoomModel.room, {
                body: new BodyParts().addMultiple([MOVE, MOVE, WORK, CARRY], constructions.length > 0 ? 15 : 8).get(),
                priority: SPAWN_PRIORITY$2,
                role: ROLE_NAME$a,
                memory: {
                    targetRoom: targetRoomModel.roomName
                }
            });
        });
    }
    static manageState(creep) {
        this.clearTarget(creep);
        this.setTarget(creep);
    }
    static setTarget(creep) {
        if (creep.target) {
            return;
        }
        if (!creep.targetRoom) {
            return;
        }
        if (creep.isEmpty(RESOURCE_ENERGY)) {
            creep.target = this.findPickupTarget(creep) || null;
        }
        else {
            creep.target = this.findSpendTarget(creep) || null;
        }
    }
    static findSpendTarget(creep) {
        var _a;
        return ((_a = creep.targetRoom) === null || _a === void 0 ? void 0 : _a.find(FIND_MY_CONSTRUCTION_SITES)[0]) || this.findLowestStructure(creep);
    }
    static findLowestStructure(creep) {
        if (!creep.targetRoom) {
            return;
        }
        const structures = creep.targetRoom.find(FIND_STRUCTURES, {
            filter: s => (s.structureType === STRUCTURE_ROAD || s.structureType === STRUCTURE_CONTAINER) &&
                s.ticksToDecay < 1000 &&
                this.isRepairable(s)
        });
        return structures.sort((a, b) => a.hits / a.hitsMax - b.hits / b.hitsMax)[0];
    }
    static isRepairable(structure) {
        return structure.hits / structure.hitsMax < REPAIRABLE_HIT_RATIO;
    }
    static clearTarget(creep) {
        if (!creep.target) {
            return;
        }
        if (creep.target instanceof Ruin) {
            if (creep.target.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {
                creep.target = null;
            }
            if (creep.isFull()) {
                creep.target = null;
            }
        }
        if (creep.target instanceof Tombstone) {
            if (creep.target.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {
                creep.target = null;
            }
            if (creep.isFull()) {
                creep.target = null;
            }
        }
        if (creep.target instanceof StructureContainer) {
            if (!this.isRepairable(creep.target)) {
                creep.target = null;
            }
            if (creep.isEmpty(RESOURCE_ENERGY)) {
                creep.target = null;
            }
        }
        if (creep.target instanceof Resource) {
            if (creep.target.resourceType !== RESOURCE_ENERGY) {
                creep.target = null;
            }
        }
        if (creep.target instanceof StructureRoad) {
            if (!this.isRepairable(creep.target)) {
                creep.target = null;
            }
            if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {
                creep.target = null;
            }
        }
        if (creep.target instanceof StructureContainer) {
            if (!this.isRepairable(creep.target) && creep.target.store.energy === 0) {
                creep.target = null;
            }
            else if (this.isRepairable(creep.target) && creep.store.energy === 0) {
                creep.target = null;
            }
        }
        if (creep.target instanceof ConstructionSite) {
            if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {
                creep.target = null;
            }
        }
    }
    static findPickupTarget(creep) {
        if (!creep.targetRoom) {
            return;
        }
        const ruin = creep.targetRoom.find(FIND_RUINS, {
            filter: r => r.store.getUsedCapacity(RESOURCE_ENERGY) > 0
        })[0];
        const tombstone = creep.targetRoom.find(FIND_TOMBSTONES, {
            filter: t => t.store.getUsedCapacity(RESOURCE_ENERGY) > 0
        })[0];
        const droppedResource = creep.targetRoom.find(FIND_DROPPED_RESOURCES)[0];
        const container = creep.targetRoom.find(FIND_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_CONTAINER && s.store.energy
        })[0];
        return [ruin, tombstone, droppedResource, container]
            .filter(i => i)
            .sort((a, b) => creep.pos.getRangeTo(a) - creep.pos.getRangeTo(b))[0];
    }
    static repairAround(creep) {
        if (creep.store.energy === 0) {
            return false;
        }
        const repairNeedingBuilding = creep.pos.findInRange(FIND_STRUCTURES, 3, {
            filter: c => (c.structureType === STRUCTURE_ROAD || c.structureType === STRUCTURE_CONTAINER) &&
                this.isRepairable(c) &&
                "ticksToDecay" in c &&
                c.ticksToDecay < 2000
        })[0];
        if (!repairNeedingBuilding) {
            return false;
        }
        creep.repair(repairNeedingBuilding);
        return true;
    }
    static buildAround(creep) {
        if (creep.store.energy === 0) {
            return false;
        }
        const construction = creep.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 3, {
            filter: c => c.structureType === STRUCTURE_CONTAINER || c.structureType === STRUCTURE_ROAD
        })[0];
        if (!construction) {
            return false;
        }
        creep.build(construction);
        return true;
    }
    static pickResource(creep) {
        if (!creep.target) {
            return false;
        }
        if (creep.pos.getRangeTo(creep.target) > 1) {
            return false;
        }
        if (creep.target instanceof Ruin) {
            creep.withdraw(creep.target, RESOURCE_ENERGY);
            return true;
        }
        else if (creep.target instanceof Resource) {
            creep.pickup(creep.target);
            return true;
        }
        else if (creep.target instanceof Tombstone) {
            creep.withdraw(creep.target, RESOURCE_ENERGY);
            return true;
        }
        else if (creep.target instanceof StructureContainer) {
            creep.withdraw(creep.target, RESOURCE_ENERGY);
            return true;
        }
        return false;
    }
}
__decorate([
    Profiler.subprofile("creep")
], SKMaintainer, "worker", null);
__decorate([
    Profiler.subprofile("spawn")
], SKMaintainer, "spawner", null);

const ROLE_NAME$9 = "sourceKeeperMineralHauler";
const SPAWN_PRIORITY$1 = 6 /* Lowest */;
const SPAWN_INTERVAL$1 = 64;
const MAX_HOSTILE_POWER$1 = 500;
class SKMineralHauler {
    static handle() {
        Creeps.getByRole(ROLE_NAME$9)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.worker(creep);
        });
        General.interval(SPAWN_INTERVAL$1, () => TickAction.add(() => this.spawner()));
    }
    static worker(creep) {
        creep.recycleFinal(100) || creep.kiteSk() || this.withdrawResources(creep) || this.storeResources(creep);
    }
    static spawner() {
        Rooms.skMiningRooms.forEach(({ homeRoomModel, targetRoomModel }) => {
            if (homeRoomModel.level < 8) {
                return;
            }
            if (!homeRoomModel.room) {
                return;
            }
            if (homeRoomModel.room.wasRecentlyUnderAttack) {
                return;
            }
            if (homeRoomModel.room.isSiegeBase) {
                return;
            }
            if (homeRoomModel.room.isAbandoning) {
                return;
            }
            if (!targetRoomModel.room) {
                return;
            }
            if (!targetRoomModel.room.hasSkDefenders) {
                return;
            }
            if (targetRoomModel.pvpDeaths > 50) {
                return;
            }
            if (targetRoomModel.hostilePower(ATTACK, RANGED_ATTACK) > MAX_HOSTILE_POWER$1) {
                return;
            }
            targetRoomModel.room.find(FIND_MINERALS).forEach(mineral => {
                if (!homeRoomModel.room) {
                    return;
                }
                if (!mineral.container) {
                    return;
                }
                if (mineral.container.store.getUsedCapacity() < 500) {
                    return;
                }
                const screepsCount = Creeps.creepsCountWithQue({
                    minTicksToLive: 300,
                    targetId: mineral.id,
                    role: ROLE_NAME$9
                });
                if (screepsCount >= 1) {
                    return;
                }
                Spawns.addToQue(homeRoomModel.room, {
                    body: BodyParts.new().move(16).carry(32),
                    priority: SPAWN_PRIORITY$1,
                    role: ROLE_NAME$9,
                    memory: {
                        targetId: mineral.id,
                        targetRoom: targetRoomModel.roomName
                    }
                });
            });
        });
    }
    static withdrawResources(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (!(creep.target instanceof Mineral)) {
            return false;
        }
        if (!creep.target.container) {
            return false;
        }
        const resource = Resources.firstStoreResource(creep.target.container.store);
        if (!resource) {
            return false;
        }
        if (creep.withdraw(creep.target.container, resource) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.target.container);
        }
        return true;
    }
    static storeResources(creep) {
        if (!creep.homeRoom) {
            return false;
        }
        if (!creep.homeRoom.storage) {
            return false;
        }
        if (creep.store.getUsedCapacity() === 0) {
            return false;
        }
        const resource = Resources.firstStoreResource(creep.store);
        if (!resource) {
            return false;
        }
        if (creep.transfer(creep.homeRoom.storage, resource) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.homeRoom.storage);
        }
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], SKMineralHauler, "worker", null);
__decorate([
    Profiler.subprofile("spawn")
], SKMineralHauler, "spawner", null);

const ROLE_NAME$8 = "sourceKeeperMineralMiner";
const SPAWN_PRIORITY = 6 /* Lowest */;
const SPAWN_INTERVAL = 64;
const MAX_HOSTILE_POWER = 500;
const MAX_TERMINAL_AMOUNT = 30000;
class SKMineralMiner {
    static handle() {
        Creeps.getByRole(ROLE_NAME$8)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.worker(creep);
        });
        General.interval(SPAWN_INTERVAL, () => TickAction.add(() => this.spawner()));
    }
    static worker(creep) {
        creep.kiteSk() || this.moveToMineral(creep) || this.mine(creep);
    }
    static spawner() {
        Rooms.skMiningRooms.forEach(({ homeRoomModel, targetRoomModel }) => {
            if (homeRoomModel.level < 8) {
                return;
            }
            if (!homeRoomModel.room) {
                return;
            }
            if (homeRoomModel.room.wasRecentlyUnderAttack) {
                return;
            }
            if (homeRoomModel.room.isSiegeBase) {
                return;
            }
            if (homeRoomModel.room.isAbandoning) {
                return;
            }
            if (!targetRoomModel.room) {
                return;
            }
            if (!targetRoomModel.room.hasSkDefenders) {
                return;
            }
            if (targetRoomModel.pvpDeaths > 50) {
                return;
            }
            if (targetRoomModel.hostilePower(ATTACK, RANGED_ATTACK) > MAX_HOSTILE_POWER) {
                return;
            }
            targetRoomModel.room.find(FIND_MINERALS).forEach(mineral => {
                if (!homeRoomModel.room) {
                    return;
                }
                if (!homeRoomModel.room.terminal) {
                    return;
                }
                const resourceConfig = CONFIG_BALANCE[mineral.mineralType];
                if (homeRoomModel.room.terminal.store.getUsedCapacity(mineral.mineralType) >
                    resourceConfig.terminalSellInstantFrom + resourceConfig.terminalSellInstantMinAmount) {
                    return;
                }
                if (mineral.mineralAmount === 0) {
                    return;
                }
                if (!homeRoomModel.room) {
                    return;
                }
                if (!mineral.container) {
                    if (mineral.containerConstruction) {
                        return;
                    }
                    if (!homeRoomModel.room.storage) {
                        return;
                    }
                    mineral.pos.createRoadConstructionsFrom(homeRoomModel.room.storage.pos);
                    return;
                }
                if (!homeRoomModel.room.terminal) {
                    return;
                }
                if (homeRoomModel.room.terminal.store[mineral.mineralType] > MAX_TERMINAL_AMOUNT) {
                    return;
                }
                const screepsCount = Creeps.creepsCountWithQue({
                    minTicksToLive: 300,
                    targetId: mineral.id,
                    role: ROLE_NAME$8
                });
                if (screepsCount >= 1) {
                    return;
                }
                Spawns.addToQue(homeRoomModel.room, {
                    body: BodyParts.new().move(9).work(40).move(),
                    priority: SPAWN_PRIORITY,
                    role: ROLE_NAME$8,
                    memory: {
                        targetId: mineral.id,
                        targetRoom: targetRoomModel.roomName,
                        stationary: true
                    }
                });
                if (homeRoomModel.room.storage) {
                    mineral.pos.createRoadConstructionsFrom(homeRoomModel.room.storage.pos);
                }
            });
        });
    }
    static moveToMineral(creep) {
        if (!(creep.target instanceof Mineral)) {
            return false;
        }
        if (!creep.target.container) {
            return false;
        }
        if (creep.pos.isEqualTo(creep.target.container.pos)) {
            return false;
        }
        creep.travel(creep.target.container, { range: 0 });
        return true;
    }
    static mine(creep) {
        if (!(creep.target instanceof Mineral)) {
            return false;
        }
        if (!creep.target.container) {
            return false;
        }
        if (creep.target.container.store.getFreeCapacity() < creep.harvestPower) {
            return false;
        }
        creep.harvest(creep.target);
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], SKMineralMiner, "worker", null);
__decorate([
    Profiler.subprofile("spawn")
], SKMineralMiner, "spawner", null);

const CONFIG$z = Config.BaseRampartRangedDefender;
class BaseRampartRangedDefender {
    static handle() {
        Creeps.getByRole(CONFIG$z.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$z.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        creep.rangedBestAttack();
        // attack(creep);
        this.boost(creep) ||
            this.moveToFlag(creep) ||
            this.moveToHostiles(creep) || // || moveToAnyHostiles(creep) ||
            this.moveToGreenFlag(creep);
    }
    static moveToFlag(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        creep.travel(creep.targetFlag, { range: 0 });
        return true;
    }
    static moveToGreenFlag(creep) {
        if (creep.memory.stationary) {
            return false;
        }
        const flag = creep.room
            .find(FIND_FLAGS)
            .filter(f => f.color === COLOR_GREEN && f.secondaryColor === COLOR_GREEN)[0];
        if (!flag) {
            return false;
        }
        creep.travel(flag);
        return true;
    }
    static boost(creep) {
        if (!creep.room.underAttack) {
            return false;
        }
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive < 300) {
            return false;
        }
        return creep.boost();
    }
    static moveToAnyHostiles(creep) {
        const hostile = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
        if (!hostile) {
            return false;
        }
        creep.travel(hostile);
        return true;
    }
    static attack(creep) {
        const hostile = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 1)[0];
        if (!hostile) {
            return;
        }
        creep.attack(hostile);
    }
    static handleSpawn() {
        Rooms.myRooms.forEach(room => {
            {
                return; // todo remove
            }
        });
    }
    static moveToHostiles(creep) {
        const hasHostileInRange = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3).length > 0;
        if (hasHostileInRange && creep.isUnderRampart) {
            return true;
        }
        const target = creep.room
            .find(FIND_HOSTILE_CREEPS)
            .filter(c => c.pos.findInRange(FIND_MY_STRUCTURES, 3, {
            filter: s => s.structureType === STRUCTURE_RAMPART && s.pos.lookFor(LOOK_CREEPS).length === 0
        }).length > 0 && c.attackPower + c.rangedAttackPower + c.healPower + c.harvestPower > 0
        // c.healPower + c.harvestPower > 0
        // c.harvestPower > 0
        )
            .sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0];
        if (!target) {
            return false;
        }
        const rampart = target.pos
            .findInRange(FIND_MY_STRUCTURES, 3, {
            filter: s => s.structureType === STRUCTURE_RAMPART && s.pos.lookFor(LOOK_CREEPS).length === 0
        })
            .sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0];
        if (!rampart) {
            return false;
        }
        const terrain = creep.room.getTerrain();
        creep.moveTo(rampart, {
            maxRooms: 1,
            maxOps: 5000,
            ignoreCreeps: false,
            reusePath: 0,
            costCallback: (roomName, costMatrix) => {
                if (roomName !== creep.room.name) {
                    return;
                }
                creep.room.find(FIND_HOSTILE_CREEPS).forEach(c => {
                    if (c.rangedAttackPower) {
                        General.squareCoordinatesFilled(c.pos.roomName, c.pos.x, c.pos.y, 3).forEach(p => {
                            if (terrain.get(p.x, p.y) === TERRAIN_MASK_WALL) {
                                return;
                            }
                            if (p.hasRampart) {
                                return;
                            }
                            costMatrix.set(p.x, p.y, 30);
                        });
                    }
                    if (c.attackPower) {
                        General.squareCoordinatesFilled(c.pos.roomName, c.pos.x, c.pos.y, 1).forEach(p => {
                            if (terrain.get(p.x, p.y) === TERRAIN_MASK_WALL) {
                                return;
                            }
                            if (p.hasRampart) {
                                return;
                            }
                            costMatrix.set(p.x, p.y, 90);
                        });
                    }
                });
                creep.room.edgeDangerPositions.forEach(pos => {
                    costMatrix.set(pos.pos.x, pos.pos.y, 256);
                });
                return costMatrix;
            },
            visualizePathStyle: {
                stroke: "#f00"
            }
        });
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseRampartRangedDefender, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseRampartRangedDefender, "handleSpawn", null);

class ProfilerLegacy2 {
    static enable() {
        this.enabled = true;
    }
    static disable() {
        this.enabled = false;
    }
    static creepTick(name) {
        if (this.stats[name]) {
            this.stats[name].creepTicks += 1;
        }
        else {
            this.stats[name] = {
                name,
                cpu: 0,
                creepTicks: 1
            };
        }
    }
    static profile(name, callable) {
        const start = Game.cpu.getUsed();
        callable();
        const end = Game.cpu.getUsed();
        const cpuUsed = end - start;
        if (this.stats[name]) {
            this.stats[name].cpu += cpuUsed;
        }
        else {
            this.stats[name] = {
                name,
                cpu: cpuUsed,
                creepTicks: 1
            };
        }
        return cpuUsed;
    }
    static quick(callable, msg) {
        const start = Game.cpu.getUsed();
        callable();
        const end = Game.cpu.getUsed();
        const cpuUsed = end - start;
        console.log("CPU used", msg, cpuUsed);
    }
    static visualize() {
        // console.log(
        //   "<script>angular.element(document.getElementsByClassName('fa fa-trash ng-scope')[0].parentNode).scope().Console.clear()</script>"
        // );
        Object.values(this.stats)
            .sort((a, b) => b.cpu - a.cpu)
            .forEach(stat => {
            const perCreep = stat.creepTicks > 1 ? (stat.cpu / stat.creepTicks).toFixed(2).padEnd(9) : "-";
            console.log(`${stat.name.padEnd(40, " ")} : ${stat.cpu.toFixed(2).padEnd(9)} : ${(stat.cpu / this.profilingForTicks())
                .toFixed(2)
                .padEnd(9)} : ${perCreep}`);
        });
    }
    static profilingForTicks() {
        return Game.time - this.statsFrom + 1;
    }
}
ProfilerLegacy2.enabled = false;
ProfilerLegacy2.stats = {};
ProfilerLegacy2.statsFrom = Game.time;

class BaseCenterLabConstruction {
    static handle() {
        General.interval(Config.BaseCenterLabConstruction.interval, () => {
            Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            });
        });
    }
    static handleRoom(room) {
        if (room.isGclFarm) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (room.level < 6) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (!room.center) {
            return;
        }
        if (!room.terminal && General.myRooms.filter(r => r.controller && r.controller.level > 6).length > 1) {
            return;
        }
        if (!Constructor.canBuildMore()) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_LAB)) {
            return;
        }
        const pos = { x: room.center.x + 1, y: room.center.y + 1 };
        const blockingStructures = room
            .lookForAt(LOOK_STRUCTURES, pos.x, pos.y)
            .filter(s => s.structureType !== STRUCTURE_RAMPART && s.structureType !== STRUCTURE_ROAD);
        if (blockingStructures.length > 0) {
            return;
        }
        const constructionSites = room.lookForAt(LOOK_CONSTRUCTION_SITES, pos.x, pos.y);
        if (constructionSites.length > 0) {
            return;
        }
        const road = room.lookForAt(LOOK_STRUCTURES, pos.x, pos.y).filter(s => s.structureType !== STRUCTURE_ROAD)[0];
        if (road) {
            road.destroy();
        }
        Constructor.createConstructionSite(room, room.center.x + 1, room.center.y + 1, STRUCTURE_LAB);
    }
}

class BaseCenterLinkConstruction {
    static handle() {
        General.interval(Config.BaseCenterLinkConstruction.interval, () => {
            Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            });
        });
    }
    static handleRoom(room) {
        if (room.isGclFarm) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (!room.center) {
            return;
        }
        // if (!room.terminal && General.myRooms.filter(r => r.controller && r.controller.level > 6).length > 1) {
        //   return;
        // }
        if (!Constructor.canBuildMore()) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_LINK)) {
            return;
        }
        const blockingStructures = room
            .lookForAt(LOOK_STRUCTURES, room.center.x - 1, room.center.y)
            .filter(s => s.structureType !== STRUCTURE_ROAD && s.structureType !== STRUCTURE_RAMPART);
        if (blockingStructures.length > 0) {
            return;
        }
        if (room.lookForAt(LOOK_CONSTRUCTION_SITES, room.center.x - 1, room.center.y).length > 0) {
            return;
        }
        room.lookForAt(LOOK_STRUCTURES, room.center.x - 1, room.center.y).forEach(structure => {
            if (structure.structureType !== STRUCTURE_ROAD) {
                return;
            }
            structure.destroy();
        });
        Constructor.createConstructionSite(room, room.center.x - 1, room.center.y, STRUCTURE_LINK);
    }
}

const COORDINATES$5 = { x: 1, y: -1 };
class BaseCenterPowerSpawnConstruction {
    static handle() {
        General.interval(Config.BaseCenterPowerSpawnConstruction.interval, () => {
            Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            });
        });
    }
    static handleRoom(room) {
        if (room.isGclFarm) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (!room.center) {
            return;
        }
        if (!Constructor.canBuildMore()) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_POWER_SPAWN)) {
            return;
        }
        const x = room.center.x + COORDINATES$5.x;
        const y = room.center.y + COORDINATES$5.y;
        if (room
            .lookForAt(LOOK_STRUCTURES, x, y)
            .filter(s => s.structureType !== STRUCTURE_ROAD &&
            s.structureType !== STRUCTURE_RAMPART &&
            s.structureType !== STRUCTURE_CONTAINER).length > 0) {
            return;
        }
        if (room.lookForAt(LOOK_CONSTRUCTION_SITES, x, y).length > 0) {
            return;
        }
        room
            .lookForAt(LOOK_STRUCTURES, x, y)
            .filter(s => s.structureType === STRUCTURE_ROAD || s.structureType === STRUCTURE_CONTAINER)
            .forEach(s => s.destroy());
        Constructor.createConstructionSite(room, x, y, STRUCTURE_POWER_SPAWN);
    }
}

const COORDINATES$4 = [
    { x: 0, y: 0 },
    { x: -2, y: 2 },
    { x: -1, y: 2 },
    { x: 0, y: 2 },
    { x: 1, y: 2 },
    { x: 2, y: 2 },
    { x: -2, y: -2 },
    { x: -1, y: -2 },
    { x: 0, y: -2 },
    { x: 1, y: -2 },
    { x: 2, y: -2 },
    { x: -2, y: 1 },
    { x: -2, y: 0 },
    { x: -2, y: -1 },
    { x: 2, y: 1 },
    { x: 2, y: 0 },
    { x: 2, y: -1 },
    { x: 3, y: 0 },
    { x: 3, y: 1 },
    { x: 3, y: 2 },
    { x: 3, y: 3 },
    { x: 2, y: 3 },
    { x: 1, y: 3 },
    { x: 0, y: 3 }
];
class BaseCenterRoadConstruction {
    static handle() {
        General.interval(Config.BaseCenterRoadConstruction.interval, () => {
            Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            });
        });
    }
    static handleRoom(room) {
        if (room.isGclFarm) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (room.controller.level < 6) {
            return;
        }
        if (!room.center) {
            return;
        }
        if (!Constructor.canBuildMore(COORDINATES$4.length)) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_ROAD, COORDINATES$4.length)) {
            return;
        }
        const terrain = room.getTerrain();
        COORDINATES$4.forEach(offset => {
            if (!room.center) {
                return;
            }
            const x = room.center.x + offset.x;
            const y = room.center.y + offset.y;
            if (terrain.get(x, y) === TERRAIN_MASK_WALL) {
                return;
            }
            if (room.lookForAt(LOOK_STRUCTURES, x, y).length > 0) {
                return;
            }
            if (room.lookForAt(LOOK_CONSTRUCTION_SITES, x, y).length > 0) {
                return;
            }
            Constructor.createConstructionSite(room, x, y, STRUCTURE_ROAD);
        });
    }
}

const COORDINATES$3 = [
    { x: 0, y: -1 },
    { x: 0, y: 1 },
    { x: 1, y: 0 }
];
class BaseCenterSpawnConstruction {
    static handle() {
        General.interval(Config.BaseCenterSpawnConstruction.interval, () => {
            Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            });
        });
    }
    static handleRoom(room) {
        if (room.isGclFarm) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (!room.center) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_SPAWN)) {
            return;
        }
        if (!Constructor.canBuildMore(COORDINATES$3.length)) {
            return;
        }
        COORDINATES$3.forEach(offset => {
            if (!room.center) {
                return;
            }
            const x = room.center.x + offset.x;
            const y = room.center.y + offset.y;
            const position = new RoomPosition(x, y, room.name);
            if (position
                .lookFor(LOOK_STRUCTURES)
                .filter(s => s.structureType !== STRUCTURE_ROAD &&
                s.structureType !== STRUCTURE_RAMPART &&
                s.structureType !== STRUCTURE_CONTAINER).length > 0) {
                return;
            }
            if (position.construction) {
                return;
            }
            if (position.road) {
                position.road.destroy();
            }
            const container = position.lookFor(LOOK_STRUCTURES).filter(s => s.structureType === STRUCTURE_CONTAINER)[0];
            if (container) {
                container.destroy();
            }
            Constructor.createConstructionSite(room, x, y, STRUCTURE_SPAWN);
        });
    }
}

const COORDINATES$2 = { x: -1, y: -1 };
class BaseCenterStorageConstruction {
    static handle() {
        General.interval(Config.BaseCenterStorageConstruction.interval, () => {
            Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            });
        });
    }
    static handleRoom(room) {
        if (room.isGclFarm) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (!room.center) {
            return;
        }
        if (!Constructor.canBuildMore()) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_STORAGE)) {
            return;
        }
        const x = room.center.x + COORDINATES$2.x;
        const y = room.center.y + COORDINATES$2.y;
        if (room.lookForAt(LOOK_CONSTRUCTION_SITES, x, y).length > 0) {
            return;
        }
        if (room
            .lookForAt(LOOK_STRUCTURES, x, y)
            .filter(s => s.structureType !== STRUCTURE_ROAD &&
            s.structureType !== STRUCTURE_RAMPART &&
            s.structureType !== STRUCTURE_CONTAINER).length > 0) {
            return;
        }
        room
            .lookForAt(LOOK_STRUCTURES, x, y)
            .filter(s => s.structureType === STRUCTURE_ROAD || s.structureType === STRUCTURE_CONTAINER)
            .forEach(s => s.destroy());
        Constructor.createConstructionSite(room, x, y, STRUCTURE_STORAGE);
    }
}

const COORDINATES$1 = { x: -1, y: +1 };
class BaseCenterTerminalConstruction {
    static handle() {
        General.interval(Config.BaseCenterTerminalConstruction.interval, () => {
            Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            });
        });
    }
    static handleRoom(room) {
        if (room.isGclFarm) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (room.terminal) {
            return;
        }
        if (!room.center) {
            return;
        }
        if (!Constructor.canBuildMore()) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_TERMINAL)) {
            return;
        }
        const targetPos = new RoomPosition(room.center.x + COORDINATES$1.x, room.center.y + COORDINATES$1.y, room.name);
        const blockingStructures = targetPos.lookFor(LOOK_STRUCTURES).filter(s => s.structureType !== STRUCTURE_ROAD);
        if (blockingStructures.length > 0) {
            return;
        }
        if (targetPos.lookFor(LOOK_CONSTRUCTION_SITES).length > 0) {
            return;
        }
        targetPos.lookFor(LOOK_STRUCTURES).forEach(structure => {
            if (structure.structureType !== STRUCTURE_ROAD) {
                return;
            }
            structure.destroy();
        });
        Constructor.createConstructionSite(room, room.center.x - 1, room.center.y + 1, STRUCTURE_TERMINAL);
    }
}

class BaseControllerStorageConstruction {
    static handle() {
        General.interval(Config.BaseControllerStorageConstruction.interval, () => {
            Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            });
        });
    }
    static handleRoom(room) {
        if (room.isGclFarm) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        room.controller.level < 8 ? this.handleLowRoom(room, room.controller) : this.handleMaxRoom(room, room.controller);
    }
    static handleLowRoom(room, controller) {
        var _a;
        const center = ((_a = room.storage) === null || _a === void 0 ? void 0 : _a.pos) || room.center;
        if (!center) {
            return;
        }
        if (room.find(FIND_MY_SPAWNS).length === 0) {
            return;
        }
        if (!Constructor.canBuildMore()) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_CONTAINER)) {
            return;
        }
        const containerConstructions = controller.pos.findInRange(FIND_CONSTRUCTION_SITES, 2, {
            filter: s => s.structureType === STRUCTURE_CONTAINER
        });
        if (containerConstructions.length > 0) {
            return;
        }
        const containers = controller.pos.findInRange(FIND_STRUCTURES, 2, {
            filter: s => s.structureType === STRUCTURE_CONTAINER
        });
        if (containers.length >= 1) {
            return;
        }
        const terrain = room.getTerrain();
        const allPossibleLocations = General.squarePositions(controller.pos.roomName, controller.pos.x, controller.pos.y, 2)
            .filter(p => terrain.get(p.x, p.y) !== TERRAIN_MASK_WALL)
            .map(p => ({
            pos: p,
            score: p.openSpots.length -
                p.findInRange(FIND_MY_CONSTRUCTION_SITES, 1).filter(c => c.structureType === STRUCTURE_CONTAINER).length *
                    0.5 -
                p.findInRange(FIND_STRUCTURES, 1).filter(c => c.structureType === STRUCTURE_CONTAINER).length * 0.5
        }))
            .sort((a, b) => b.score - a.score);
        allPossibleLocations.forEach(p => {
            room.visual.text(String(p.score), p.pos.x, p.pos.y);
        });
        const position = allPossibleLocations[0];
        if (!position) {
            return;
        }
        position.pos.createRoadConstructionsFrom(center, {
            containerOnPos: true,
            costCallback: (r, matrix) => {
                General.squareCoordinatesFilled(r.name, controller.pos.x, controller.pos.y, 3).forEach(pos => {
                    if (terrain.get(pos.x, pos.y) === TERRAIN_MASK_WALL) {
                        return;
                    }
                    matrix.set(pos.x, pos.y, 100);
                });
                return matrix;
            }
        });
    }
    static destroyContainer(controller) {
        controller.pos
            .findInRange(FIND_STRUCTURES, 3, {
            filter: s => s.structureType === STRUCTURE_CONTAINER ||
                s.structureType === STRUCTURE_ROAD ||
                (s.structureType === STRUCTURE_WALL && s.hits === 1)
        })
            .forEach(s => s.destroy());
    }
    static handleMaxRoom(room, controller) {
        var _a;
        if (room.controllerContainers.length > 0) {
            this.destroyContainer(controller);
        }
        if (!Constructor.canBuildMore()) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_LINK)) {
            return;
        }
        const links = controller.pos.findInRange(FIND_STRUCTURES, 2, {
            filter: s => s.structureType === STRUCTURE_LINK
        });
        if (links.length > 0) {
            return;
        }
        const linkConstructions = controller.pos.findInRange(FIND_CONSTRUCTION_SITES, 2, {
            filter: s => s.structureType === STRUCTURE_LINK
        });
        if (linkConstructions.length > 0) {
            return;
        }
        const center = (_a = room.storage) === null || _a === void 0 ? void 0 : _a.pos;
        if (!center) {
            return;
        }
        const position = controller.pos.openSpots.length > 1
            ? controller.pos.openSpots.sort((a, b) => a.findPathTo(center, { maxRooms: 1 }).length - b.findPathTo(center, { maxRooms: 1 }).length)[0]
            : controller.pos
                .getOpenSpots(2)
                .sort((a, b) => a.findPathTo(center, { maxRooms: 1 }).length - b.findPathTo(center, { maxRooms: 1 }).length)[0];
        if (!position) {
            return;
        }
        position.createRoadConstructionsFrom(center, {
            containerOnPos: true,
            structureType: STRUCTURE_LINK
        });
    }
    static constructNextToController(room, controller, path, distance, structureType) {
        const terrain = room.getTerrain();
        const sq = this.square(controller.pos, distance);
        for (const pos of sq) {
            const miningSpot = path[0];
            if (!miningSpot)
                continue;
            if (this.isPosTerrain(terrain, pos))
                continue;
            if (this.posContainsPos(path, pos))
                continue;
            if (this.posHasBlockingStructures(room, pos))
                continue;
            if (this.posHasBlockingConstructions(room, pos))
                continue;
            if (this.getRange(miningSpot, pos) > 1)
                continue;
            room.visual.circle(pos.x, pos.y, { radius: 0.3, fill: "#fff" });
            Constructor.createConstructionSite(room, pos.x, pos.y, structureType);
            Log.room(room, `Created controller ${structureType} structure`);
            return true;
        }
        return false;
    }
    static posHasBlockingConstructions(room, pos) {
        return room.lookForAt(LOOK_CONSTRUCTION_SITES, pos.x, pos.y).length > 0;
    }
    static posHasBlockingStructures(room, pos) {
        return room.lookForAt(LOOK_STRUCTURES, pos.x, pos.y).filter(s => s.structureType !== STRUCTURE_RAMPART).length > 0;
    }
    static posContainsPos(haystack, needle) {
        return haystack.filter(p => p.x === needle.x && p.y === needle.y).length > 0;
    }
    static isPosTerrain(terrain, pos) {
        return terrain.get(pos.x, pos.y) === TERRAIN_MASK_WALL;
    }
    static getRange(from, to) {
        return Math.max(Math.abs(from.x - to.x), Math.abs(from.y - to.y));
    }
    static square(center, distance) {
        const s = [];
        for (let x = center.x - distance; x <= center.x + distance; x++) {
            if (x >= 48 || x <= 1)
                continue;
            if (center.y - distance > 0) {
                s.push({ x, y: center.y - distance });
            }
            if (center.y + distance < 49) {
                s.push({ x, y: center.y + distance });
            }
        }
        for (let y = center.y - distance + 1; y <= center.y + distance - 1; y++) {
            if (y >= 48 || y <= 1)
                continue;
            if (center.x - distance > 0) {
                s.push({ x: center.x - distance, y });
            }
            if (center.x + distance < 49) {
                s.push({ x: center.x + distance, y });
            }
        }
        return s;
    }
}

const EXTENSION_POS = [
    { x: 0, y: 0 },
    { x: 0, y: -1 },
    { x: 0, y: 1 },
    { x: -1, y: 0 },
    { x: 1, y: 0 }
];
const ROAD_POS$1 = [
    { x: 0, y: -2 },
    { x: 0, y: 2 },
    { x: 1, y: -1 },
    { x: 1, y: 1 },
    { x: 2, y: 0 },
    { x: -1, y: -1 },
    { x: -1, y: 1 },
    { x: -2, y: 0 }
];
class BaseExtensionConstruction {
    static handle() {
        General.interval(Config.BaseExtensionConstruction.intervalRebuild, () => TickAction.add(() => this.rebuild()));
        General.interval(Config.BaseExtensionConstruction.intervalBuild, () => TickAction.add(() => this.build()));
        General.interval(Config.BaseExtensionConstruction.intervalRoads, () => TickAction.add(() => this.roads()));
    }
    static roads() {
        Rooms.myRooms.forEach(room => {
            if (room.isGclFarm) {
                return;
            }
            if (!room.shouldConstruct) {
                return;
            }
            this.buildRoadsAround(room);
            // this.buildConnectingRoads(room);
        });
    }
    static build() {
        Rooms.myRooms.forEach(room => {
            if (!room.my) {
                return;
            }
            if (!room.shouldConstruct) {
                return;
            }
            if (!room.controller) {
                return;
            }
            if (!room.center) {
                return;
            }
            if (!Constructor.canBuildMore(EXTENSION_POS.length)) {
                return;
            }
            if (!Constructor.roomCanBuildMore(room, STRUCTURE_EXTENSION, 5)) {
                return;
            }
            if (this.hasMissingExtensions(room)) {
                Log.room(room, "has missing extensions");
                return;
            }
            const position = this.safePositions(room).sort((a, b) => this.sortBestPosition(room, a, b))[0];
            if (!position) {
                return;
            }
            const colors = Flags.getColors(FlagType.baseExtensionBlock);
            if (!colors) {
                console.log("missing base extension block flag colors");
                return;
            }
            position.createFlag(undefined, colors.color, colors.secondaryColor);
            EXTENSION_POS.forEach(extensionPos => {
                const newX = extensionPos.x + position.x;
                const newY = extensionPos.y + position.y;
                room.lookForAt(LOOK_STRUCTURES, newX, newY).forEach(structure => {
                    if (structure.structureType !== STRUCTURE_ROAD) {
                        return;
                    }
                    structure.destroy();
                });
                Constructor.createConstructionSite(room, newX, newY, STRUCTURE_EXTENSION);
                room.visual.circle(newX, newY, { radius: 0.5, fill: "#ff00ff" });
            });
            if (room.isGclFarm) {
                return;
            }
            ROAD_POS$1.forEach(roadPos => {
                const newX = roadPos.x + position.x;
                const newY = roadPos.y + position.y;
                Constructor.createConstructionSite(room, newX, newY, STRUCTURE_ROAD);
                room.visual.circle(newX, newY, { radius: 0.5, fill: "#ff00ff" });
            });
            Log.room(room, "Created new extension construction set");
        });
    }
    static rebuild() {
        Rooms.myRooms.forEach(room => {
            if (!room.shouldConstruct) {
                return;
            }
            if (!Constructor.canBuildMore()) {
                return;
            }
            if (!this.hasMissingExtensions(room)) {
                return;
            }
            Flags.roomFlags(room, FlagType.baseExtensionBlock).forEach(flag => {
                EXTENSION_POS.forEach(extensionPos => {
                    const newX = extensionPos.x + flag.pos.x;
                    const newY = extensionPos.y + flag.pos.y;
                    Constructor.createConstructionSite(room, newX, newY, STRUCTURE_EXTENSION);
                    room.visual.circle(newX, newY, { radius: 0.5, fill: "#ff00ff" });
                });
            });
            Log.room(room, "Created missing extension construction");
        });
    }
    static buildConnectingRoads(room) {
        const flags = Flags.roomFlags(room, FlagType.baseExtensionBlock);
        for (const fromFlag of flags) {
            for (const toFlag of flags) {
                if (fromFlag.name === toFlag.name) {
                    continue;
                }
                if (this.buildRoadsBetween(room, fromFlag.pos, toFlag.pos)) {
                    return;
                }
            }
        }
        if (room.storage) {
            for (const flag of flags) {
                if (this.buildRoadsBetween(room, flag.pos, room.storage.pos)) {
                    return;
                }
            }
        }
    }
    static buildRoadsBetween(room, pos1, pos2) {
        const ret = PathFinder.search(pos1, pos2, {
            maxCost: 600,
            maxRooms: 1,
            plainCost: 4,
            swampCost: 10,
            roomCallback(roomName) {
                const matrix = room.matrix();
                room.extensions.forEach(extension => {
                    matrix.set(extension.pos.x, extension.pos.y, 1);
                });
                room
                    .find(FIND_MY_CONSTRUCTION_SITES)
                    .filter(c => c.structureType === STRUCTURE_EXTENSION)
                    .forEach(extension => {
                    matrix.set(extension.pos.x, extension.pos.y, 1);
                });
                if (room.storage) {
                    matrix.set(room.storage.pos.x, room.storage.pos.y, 1);
                }
                return matrix;
            }
        });
        if (ret.incomplete) {
            Log.room(room, `cant find path between flags ${JSON.stringify(pos1)} and ${JSON.stringify(pos2)}`);
            return false;
        }
        const positionsWithoutStructures = ret.path.filter(pos => pos.lookFor(LOOK_STRUCTURES).length === 0 && pos.lookFor(LOOK_CONSTRUCTION_SITES).length === 0);
        if (positionsWithoutStructures.length === 0) {
            return false;
        }
        positionsWithoutStructures.forEach(pos => {
            Constructor.createConstructionSite(room, pos.x, pos.y, STRUCTURE_ROAD);
            room.visual.circle(pos, { radius: 0.2 });
        });
        return true;
    }
    static buildRoadsAround(room) {
        Flags.roomFlags(room, FlagType.baseExtensionBlock).forEach(flag => {
            ROAD_POS$1.forEach(roadPos => {
                const newX = roadPos.x + flag.pos.x;
                const newY = roadPos.y + flag.pos.y;
                Constructor.createConstructionSite(room, newX, newY, STRUCTURE_ROAD);
                room.visual.circle(newX, newY, { radius: 0.5, fill: "#ffff00" });
            });
        });
    }
    static sortBestPosition(room, a, b) {
        if (!room.center) {
            console.log(room.name, "missing center");
            return -99999;
        }
        const extensionFlags = Flags.roomFlags(room, FlagType.baseExtensionBlock);
        const aRanges = extensionFlags.reduce((totalRange, flag) => totalRange + a.getPreciseRangeTo(flag), room.center.getPreciseRangeTo(a));
        const bRanges = extensionFlags.reduce((totalRange, flag) => totalRange + b.getPreciseRangeTo(flag), room.center.getPreciseRangeTo(b));
        return aRanges - bRanges;
    }
    static safePositions(room) {
        const terrain = room.getTerrain();
        const positions = [];
        const labFlags = Flags.roomFlags(room, FlagType.baseLabBlock);
        for (let x = 2; x <= 47; x++) {
            for (let y = 2; y <= 47; y++) {
                if (this.isPositionTooCloseToCenterLab(room, x, y)) {
                    continue;
                }
                if (this.isPositionTooCloseToCenterStorage(room, x, y)) {
                    continue;
                }
                if (this.isPositionTooCloseToCenter(room, x, y))
                    continue;
                if (this.isPositionTooCloseToSource(room, x, y))
                    continue;
                if (this.isPositionTooCloseToMineral(room, x, y))
                    continue;
                if (this.isPositionTooCloseToExit(room, x, y))
                    continue;
                if (this.isPositionTooCloseToLab(x, y, labFlags))
                    continue;
                if (this.isPositionTooCloseToController(room, x, y))
                    continue;
                if (!this.isPositionValid(room, terrain, x, y))
                    continue;
                positions.push(new RoomPosition(x, y, room.name));
                room.visual.circle(x, y, { radius: 0.5, fill: "#fff" });
            }
        }
        return positions;
    }
    static isPositionTooCloseToLab(x, y, labFlags) {
        return labFlags.filter(f => f.pos.getRangeTo(x, y) <= 3).length > 0;
    }
    static isPositionTooCloseToExit(room, x, y) {
        return new RoomPosition(x, y, room.name).findInRange(FIND_EXIT, 7).length > 0;
    }
    static isPositionTooCloseToController(room, x, y) {
        return (new RoomPosition(x, y, room.name).findInRange(FIND_STRUCTURES, 6, {
            filter: s => s.structureType === STRUCTURE_CONTROLLER
        }).length > 0);
    }
    static isPositionTooCloseToCenterStorage(room, x, y) {
        if (!room.center) {
            Log.room(room, "missing center");
            return true;
        }
        if (!room.centerStoragePos) {
            return true;
        }
        for (const extensionPos of EXTENSION_POS) {
            const pos = new RoomPosition(x + extensionPos.x, y + extensionPos.y, room.name);
            if (room.centerStoragePos.getRangeTo(pos) <= 2) {
                return true;
            }
        }
        return false;
    }
    static isPositionTooCloseToCenterLab(room, x, y) {
        if (!room.center) {
            Log.room(room, "missing center");
            return true;
        }
        if (!room.centerLabPos) {
            return true;
        }
        for (const extensionPos of EXTENSION_POS) {
            const pos = new RoomPosition(x + extensionPos.x, y + extensionPos.y, room.name);
            if (room.centerLabPos.getRangeTo(pos) <= 2) {
                return true;
            }
        }
        return false;
    }
    static isPositionTooCloseToCenter(room, x, y) {
        return !room.center || room.center.getRangeTo(new RoomPosition(x, y, room.name)) < 4;
    }
    static isPositionTooCloseToSource(room, x, y) {
        return room.find(FIND_SOURCES).filter(s => s.pos.getRangeTo(new RoomPosition(x, y, room.name)) < 5).length > 0;
    }
    static isPositionTooCloseToMineral(room, x, y) {
        return room.find(FIND_MINERALS).filter(m => m.pos.getRangeTo(new RoomPosition(x, y, room.name)) < 5).length > 0;
    }
    static isPositionValid(room, terrain, x, y) {
        for (const extensionPos of EXTENSION_POS) {
            const newX = x + extensionPos.x;
            const newY = y + extensionPos.y;
            if (terrain.get(newX, newY) === TERRAIN_MASK_WALL)
                return false;
            const structures = room.lookForAt(LOOK_STRUCTURES, newX, newY).filter(s => s.structureType !== STRUCTURE_ROAD);
            if (structures.length > 0)
                return false;
            const constructions = room.lookForAt(LOOK_CONSTRUCTION_SITES, newX, newY);
            if (constructions.length > 0)
                return false;
        }
        for (const roadPos of ROAD_POS$1) {
            const newX = x + roadPos.x;
            const newY = y + roadPos.y;
            if (terrain.get(newX, newY) === TERRAIN_MASK_WALL)
                return false;
            const structures = room.lookForAt(LOOK_STRUCTURES, newX, newY).filter(s => s.structureType !== STRUCTURE_ROAD);
            if (structures.length > 0)
                return false;
            const constructions = room
                .lookForAt(LOOK_CONSTRUCTION_SITES, newX, newY)
                .filter(s => s.structureType !== STRUCTURE_ROAD);
            if (constructions.length > 0)
                return false;
        }
        return true;
    }
    static hasMissingExtensions(room) {
        const flags = Flags.roomFlags(room, FlagType.baseExtensionBlock);
        const extensions = room.find(FIND_MY_STRUCTURES, { filter: f => f.structureType === STRUCTURE_EXTENSION });
        const extensionConstructions = room.find(FIND_MY_CONSTRUCTION_SITES, {
            filter: f => f.structureType === STRUCTURE_EXTENSION
        });
        return flags.length * 5 > extensions.length + extensionConstructions.length;
    }
}

const CONFIG$y = Config.BaseExtractorConstruction;
class BaseExtractorConstruction {
    static handle() {
        General.interval(CONFIG$y.interval, () => {
            Rooms.myRooms.forEach(room => {
                if (room.isGclFarm) {
                    return;
                }
                this.handleRoom(room);
            });
        });
    }
    static handleRoom(room) {
        this.buildConstructor(room);
        this.buildContainers(room);
    }
    static buildContainers(room) {
        if (room.level < 8) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (!Constructor.canBuildMore()) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_CONTAINER)) {
            return;
        }
        room.find(FIND_MINERALS).forEach(mineral => {
            var _a;
            const currentCount = mineral.containers.length + mineral.containerConstructions.length;
            if (currentCount >= CONFIG$y.maxContainers) {
                return;
            }
            if (currentCount >= mineral.pos.openSpots.length) {
                return;
            }
            const center = (_a = room.storage) === null || _a === void 0 ? void 0 : _a.pos;
            if (!center) {
                return;
            }
            const openPosition = mineral.pos.openSpots
                .filter(pos => pos.lookFor(LOOK_STRUCTURES).filter(s => s.structureType === STRUCTURE_CONTAINER).length === 0 &&
                pos.lookFor(LOOK_CONSTRUCTION_SITES).filter(s => s.structureType === STRUCTURE_CONTAINER).length === 0 &&
                pos.isPosReachable(center))
                .sort((a, b) => a.findPathTo(center).length - b.findPathTo(center).length)[0];
            if (!openPosition) {
                return;
            }
            openPosition.createRoadConstructionsFrom(center, {
                containerOnPos: true
            });
            // Constructor.createConstructionSite(room, pos.x, pos.y, STRUCTURE_CONTAINER);
        });
    }
    static buildConstructor(room) {
        if (room.level < 8) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (!room.terminal && General.myRooms.filter(r => r.controller && r.controller.level > 6).length > 1) {
            return;
        }
        if (!Constructor.canBuildMore()) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_EXTRACTOR)) {
            return;
        }
        room.find(FIND_MINERALS).forEach(mineral => {
            const extractor = mineral.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_EXTRACTOR);
            if (extractor) {
                return;
            }
            const extractorConstruction = mineral.pos
                .lookFor(LOOK_CONSTRUCTION_SITES)
                .find(s => s.structureType === STRUCTURE_EXTRACTOR);
            if (extractorConstruction) {
                return;
            }
            Constructor.createConstructionSite(room, mineral.pos.x, mineral.pos.y, STRUCTURE_EXTRACTOR);
        });
    }
}

const CONFIG$x = Config.BaseLabConstruction;
const LAB_POS = [
    { x: 0, y: 0 },
    { x: -1, y: 1 },
    { x: -1, y: -1 },
    { x: 0, y: -1 },
    { x: 1, y: 0 },
    { x: 1, y: 1 },
    { x: -2, y: 0 },
    { x: -2, y: 1 },
    { x: -1, y: 2 }
    // { x: 0, y: 2 }
];
const ROAD_POS = [
    { x: -2, y: -1 },
    { x: -1, y: 0 },
    { x: 0, y: 1 },
    { x: 1, y: 2 },
    { x: -1, y: -2 },
    { x: 0, y: -2 },
    { x: 1, y: -1 },
    { x: 2, y: 0 },
    { x: 2, y: 1 },
    { x: -3, y: 0 },
    { x: -3, y: 1 },
    { x: -2, y: 2 },
    { x: -1, y: 3 },
    { x: 0, y: 2 }
];
class BaseLabConstruction {
    static handle() {
        General.interval(CONFIG$x.interval, () => {
            TickAction.add(() => Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            }));
        });
    }
    static handleRoom(room) {
        if (room.isAbandoning) {
            return;
        }
        if (room.isGclFarm) {
            return;
        }
        this.handleFlags(room);
        this.handleBuildingLabs(room);
        this.handleBuildingRoads(room);
    }
    static handleFlags(room) {
        if (!room.controller) {
            return;
        }
        if (!room.center) {
            return;
        }
        const flags = Flags.roomFlags(room, FlagType.baseLabBlock);
        if (flags.length === 2) {
            return;
        }
        const position = this.safePositions(room)
            .filter(p => !this.isPositionTooCloseToCenter(room, p.x, p.y))
            .sort((a, b) => this.sortBestPosition(room, a, b))[0];
        if (!position) {
            return;
        }
        room.visual.circle(position.x, position.y, { radius: 0.5, fill: "#ff00ff" });
        const flagColors = Flags.getColors(FlagType.baseLabBlock);
        LAB_POS.slice(0, 2).forEach(pos => {
            room.createFlag(position.x + pos.x, position.y + pos.y, undefined, flagColors === null || flagColors === void 0 ? void 0 : flagColors.color, flagColors === null || flagColors === void 0 ? void 0 : flagColors.secondaryColor);
            room.visual.circle(position.x + pos.x, position.y + pos.y, { radius: 0.3, fill: "#00ff00" });
        });
        ROAD_POS.forEach(pos => {
            room.visual.circle(position.x + pos.x, position.y + pos.y, { radius: 0.3, fill: "#0000ff" });
        });
    }
    static handleBuildingLabs(room) {
        if (!room.my) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (!room.centerLab) {
            return;
        }
        if (room.controller.level < 8) {
            return;
        }
        if (!room.center) {
            return;
        }
        if (!room.terminal) {
            return;
        }
        if (!room.storage) {
            return;
        }
        const flags = room.find(FIND_FLAGS).filter(f => f.color === COLOR_WHITE && f.secondaryColor === COLOR_BROWN);
        if (flags.length !== 2) {
            return;
        }
        const flag = flags.sort((a, b) => b.pos.x - a.pos.x)[0];
        if (!flag) {
            return;
        }
        if (!Constructor.canBuildMore(LAB_POS.length)) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_LAB)) {
            return;
        }
        LAB_POS.forEach(pos => {
            const newX = flag.pos.x + pos.x;
            const newY = flag.pos.y + pos.y;
            const roomPosition = new RoomPosition(newX, newY, room.name);
            const blockingStructures = roomPosition
                .lookFor(LOOK_STRUCTURES)
                .filter(s => s.structureType !== STRUCTURE_ROAD && s.structureType !== STRUCTURE_RAMPART);
            if (blockingStructures.length > 0) {
                return;
            }
            const road = roomPosition.lookFor(LOOK_STRUCTURES).filter(s => s.structureType === STRUCTURE_ROAD)[0];
            if (road) {
                road.destroy();
            }
            Constructor.createConstructionSite(room, newX, newY, STRUCTURE_LAB);
            room.visual.circle(newX, newY, { radius: 0.3, fill: "#00ff00" });
        });
    }
    static handleBuildingRoads(room) {
        if (!room.my) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (room.controller.level < 8) {
            return;
        }
        if (!room.center) {
            return;
        }
        if (!room.terminal && General.myRooms.filter(r => r.controller && r.controller.level > 6).length > 1) {
            return;
        }
        const flags = Flags.roomFlags(room, FlagType.baseLabBlock);
        if (flags.length !== 2) {
            return;
        }
        const flag = flags.sort((a, b) => b.pos.x - a.pos.x)[0];
        if (!flag) {
            return;
        }
        if (!Constructor.canBuildMore(ROAD_POS.length)) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_ROAD, ROAD_POS.length)) {
            return;
        }
        ROAD_POS.forEach(pos => {
            const newX = flag.pos.x + pos.x;
            const newY = flag.pos.y + pos.y;
            const roomPosition = new RoomPosition(newX, newY, room.name);
            if (roomPosition.lookFor(LOOK_TERRAIN).filter(t => t === "wall").length > 0) {
                return;
            }
            if (roomPosition.lookFor(LOOK_STRUCTURES).filter(s => s.structureType === STRUCTURE_ROAD).length > 0) {
                return;
            }
            Constructor.createConstructionSite(room, newX, newY, STRUCTURE_ROAD);
            room.visual.circle(newX, newY, { radius: 0.3, fill: "#0000ff" });
        });
    }
    static sortBestPosition(room, a, b) {
        if (!room.center)
            return -99999;
        let rangeA = room.center.getRangeTo(a);
        for (const roadPos of ROAD_POS) {
            const newX = a.x + roadPos.x;
            const newY = a.y + roadPos.y;
            const roads = room.lookForAt(LOOK_STRUCTURES, newX, newY).filter(s => s.structureType === STRUCTURE_ROAD);
            const roadConstructions = room
                .lookForAt(LOOK_CONSTRUCTION_SITES, newX, newY)
                .filter(s => s.structureType === STRUCTURE_ROAD);
            if (roads.length + roadConstructions.length > 0) {
                rangeA = rangeA * 0.95;
            }
        }
        let rangeB = room.center.getRangeTo(b);
        for (const roadPos of ROAD_POS) {
            const newX = b.x + roadPos.x;
            const newY = b.y + roadPos.y;
            const roads = room.lookForAt(LOOK_STRUCTURES, newX, newY).filter(s => s.structureType === STRUCTURE_ROAD);
            const roadConstructions = room
                .lookForAt(LOOK_CONSTRUCTION_SITES, newX, newY)
                .filter(s => s.structureType === STRUCTURE_ROAD);
            if (roads.length + roadConstructions.length > 0) {
                rangeB = rangeB * 0.95;
            }
        }
        return rangeA - rangeB;
    }
    static safePositions(room) {
        const terrain = room.getTerrain();
        const positions = [];
        for (let x = 2; x <= 47; x++) {
            for (let y = 2; y <= 47; y++) {
                if (this.isPositionTooCloseToExit(room, x, y))
                    continue;
                if (!this.isPositionValid(room, terrain, x, y))
                    continue;
                if (this.isPositionTooCloseToCenter(room, x, y))
                    continue;
                positions.push(new RoomPosition(x, y, room.name));
                room.visual.circle(x, y, { radius: 0.5, fill: "#fff" });
            }
        }
        return positions;
    }
    static isPositionTooCloseToExit(room, x, y) {
        return new RoomPosition(x, y, room.name).findInRange(FIND_EXIT, 7).length > 0;
    }
    static isPositionTooCloseToCenter(room, x, y) {
        if (!room.center) {
            return true;
        }
        return Math.max(Math.abs(x - room.center.x), Math.abs(y - room.center.y)) <= 5;
    }
    static isPositionValid(room, terrain, x, y) {
        for (const extensionPos of LAB_POS) {
            const newX = x + extensionPos.x;
            const newY = y + extensionPos.y;
            if (terrain.get(newX, newY) === TERRAIN_MASK_WALL) {
                return false;
            }
            const structures = room.lookForAt(LOOK_STRUCTURES, newX, newY);
            if (structures.length > 0) {
                return false;
            }
            const constructions = room.lookForAt(LOOK_CONSTRUCTION_SITES, newX, newY);
            if (constructions.length > 0) {
                return false;
            }
        }
        for (const roadPos of ROAD_POS) {
            const newX = x + roadPos.x;
            const newY = y + roadPos.y;
            if (terrain.get(newX, newY) === TERRAIN_MASK_WALL) {
                return false;
            }
            const structures = room.lookForAt(LOOK_STRUCTURES, newX, newY).filter(s => s.structureType !== STRUCTURE_ROAD);
            if (structures.length > 0) {
                return false;
            }
            const constructions = room
                .lookForAt(LOOK_CONSTRUCTION_SITES, newX, newY)
                .filter(s => s.structureType !== STRUCTURE_ROAD);
            if (constructions.length > 0) {
                return false;
            }
        }
        return true;
    }
}

const CONFIG$w = Config.BaseLinkSourceConstruction;
class BaseLinkSourceConstruction {
    static handle() {
        General.interval(CONFIG$w.interval, () => {
            Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            });
        });
    }
    static handleRoom(room) {
        if (!room.shouldConstruct) {
            return;
        }
        if (room.isGclFarm) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (room.centerLinks.length === 0) {
            return;
        }
        if (!room.terminal && General.myRooms.filter(r => r.controller && r.controller.level > 6).length > 1) {
            return;
        }
        if (!this.roomCanConstructMoreLinks(room)) {
            return;
        }
        room.find(FIND_SOURCES).forEach(source => {
            if (!room.controller) {
                return;
            }
            if (!room.center) {
                return;
            }
            if (!room.storage) {
                return;
            }
            const linksCount = source.links.length + source.linkConstructions.length;
            if (linksCount >= 2 || (room.controller.level < 7 && linksCount >= 1)) {
                return;
            }
            const roomSourceOptions = room.sourceOptions(source);
            if (!roomSourceOptions.miningPos) {
                Log.object(source, "no mining pos");
                return;
            }
            this.constructNextToSource(room, roomSourceOptions.miningPos, 1) ||
                this.constructNextToSource(room, roomSourceOptions.miningPos, 2) ||
                this.constructNextToSource(room, roomSourceOptions.miningPos, 3);
        });
    }
    static roomCanConstructMoreLinks(room) {
        if (!room.controller) {
            return false;
        }
        return Constructor.canBuildMore() && Constructor.roomCanBuildMore(room, STRUCTURE_LINK);
    }
    static constructNextToSource(room, miningPos, distance) {
        const terrain = room.getTerrain();
        const sq = this.square(miningPos, distance);
        for (const pos of sq) {
            if (this.isNearExit(new RoomPosition(pos.x, pos.y, room.name)))
                continue;
            if (this.isPosTerrain(terrain, pos))
                continue;
            if (this.posHasBlockingStructures(room, pos))
                continue;
            if (this.posHasBlockingConstructions(room, pos))
                continue;
            if (this.getRange(miningPos, pos) > 1)
                continue;
            room.visual.circle(pos.x, pos.y, { radius: 0.3, fill: "#fff" });
            Constructor.createConstructionSite(room, pos.x, pos.y, STRUCTURE_LINK);
            return true;
        }
        return false;
    }
    static posHasBlockingConstructions(room, pos) {
        return room.lookForAt(LOOK_CONSTRUCTION_SITES, pos.x, pos.y).length > 0;
    }
    static posHasBlockingStructures(room, pos) {
        return room.lookForAt(LOOK_STRUCTURES, pos.x, pos.y).filter(s => s.structureType !== STRUCTURE_RAMPART).length > 0;
    }
    static posContainsPos(haystack, needle) {
        return haystack.filter(p => p.x === needle.x && p.y === needle.y).length > 0;
    }
    static isNearExit(pos) {
        return pos.findInRange(FIND_EXIT, 1).length > 0;
    }
    static isPosTerrain(terrain, pos) {
        return terrain.get(pos.x, pos.y) === TERRAIN_MASK_WALL;
    }
    static getRange(from, to) {
        return Math.max(Math.abs(from.x - to.x), Math.abs(from.y - to.y));
    }
    static square(center, distance) {
        const sq = [];
        for (let x = center.x - distance; x <= center.x + distance; x++) {
            if (x >= 48 || x <= 1)
                continue;
            if (center.y - distance > 0) {
                sq.push({ x, y: center.y - distance });
            }
            if (center.y + distance < 49) {
                sq.push({ x, y: center.y + distance });
            }
        }
        for (let y = center.y - distance + 1; y <= center.y + distance - 1; y++) {
            if (y >= 48 || y <= 1)
                continue;
            if (center.x - distance > 0) {
                sq.push({ x: center.x - distance, y });
            }
            if (center.x + distance < 49) {
                sq.push({ x: center.x + distance, y });
            }
        }
        return sq;
    }
}

const CONFIG$v = Config.BaseNukerConstruction;
class BaseNukerConstruction {
    static handle() {
        General.interval(CONFIG$v.interval, () => {
            TickAction.add(() => Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            }));
        });
    }
    static handleRoom(room) {
        if (room.isGclFarm) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (!room.storage) {
            return;
        }
        if (!Constructor.canBuildMore()) {
            return;
        }
        if (Constructor.roomCanBuildMore(room, STRUCTURE_EXTENSION)) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_NUKER)) {
            return;
        }
        const bestPosition = this.safePositions(room).sort((a, b) => {
            if (!room.storage)
                return -99999;
            return a.getRangeTo(room.storage) - b.getRangeTo(room.storage);
        })[0];
        if (!bestPosition) {
            return;
        }
        Constructor.createConstructionSite(room, bestPosition.x, bestPosition.y, STRUCTURE_NUKER);
    }
    static safePositions(room) {
        const terrain = room.getTerrain();
        const positions = [];
        for (let x = 2; x <= 47; x++) {
            for (let y = 2; y <= 47; y++) {
                if (this.isPositionTooCloseToExit(room, x, y))
                    continue;
                if (this.isPositionTooCloseToLab(room, x, y))
                    continue;
                if (this.isPositionTooCloseToController(room, x, y))
                    continue;
                if (this.isPositionTooCloseToCenter(room, x, y))
                    continue;
                if (this.isPositionTooCloseToSource(room, x, y))
                    continue;
                if (this.isPositionTooCloseToMineral(room, x, y))
                    continue;
                if (this.isPositionTooCloseToFactory(room, x, y))
                    continue;
                if (!this.isPositionValid(room, terrain, x, y))
                    continue;
                positions.push(new RoomPosition(x, y, room.name));
            }
        }
        return positions;
    }
    static isPositionTooCloseToFactory(room, x, y) {
        return (!!room
            .find(FIND_MY_STRUCTURES, { filter: s => s.structureType === STRUCTURE_FACTORY })
            .find(s => s.pos.getRangeTo(x, y) <= 4) ||
            !!room
                .find(FIND_MY_CONSTRUCTION_SITES, { filter: s => s.structureType === STRUCTURE_FACTORY })
                .find(s => s.pos.getRangeTo(x, y) <= 4));
    }
    static isPositionTooCloseToMineral(room, x, y) {
        return !!room.find(FIND_MINERALS).find(s => s.pos.getRangeTo(x, y) <= 4);
    }
    static isPositionTooCloseToSource(room, x, y) {
        return !!room.find(FIND_SOURCES).find(s => s.pos.getRangeTo(x, y) <= 4);
    }
    static isPositionTooCloseToCenter(room, x, y) {
        if (!room.center)
            return true;
        return Math.max(Math.abs(x - room.center.x), Math.abs(y - room.center.y)) <= 4;
    }
    static isPositionTooCloseToLab(room, x, y) {
        return (new RoomPosition(x, y, room.name)
            .findInRange(FIND_FLAGS, 3)
            .filter(f => Flags.getType(f) === FlagType.baseLabBlock).length > 0);
    }
    static isPositionTooCloseToExit(room, x, y) {
        return new RoomPosition(x, y, room.name).findInRange(FIND_EXIT, 7).length > 0;
    }
    static isPositionTooCloseToController(room, x, y) {
        return (new RoomPosition(x, y, room.name).findInRange(FIND_STRUCTURES, 6, {
            filter: s => s.structureType === STRUCTURE_CONTROLLER
        }).length > 0);
    }
    static isPositionValid(room, terrain, x, y) {
        if (terrain.get(x, y) === TERRAIN_MASK_WALL)
            return false;
        const structures = room.lookForAt(LOOK_STRUCTURES, x, y);
        if (structures.length > 0)
            return false;
        const constructions = room.lookForAt(LOOK_CONSTRUCTION_SITES, x, y);
        if (constructions.length > 0)
            return false;
        return true;
    }
}

const CONFIG$u = Config.BaseObserverConstruction;
class BaseObserverConstruction {
    static handle() {
        General.interval(CONFIG$u.interval, () => {
            TickAction.add(() => Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            }));
        });
    }
    static handleRoom(room) {
        if (room.isGclFarm) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (!room.storage) {
            return;
        }
        if (!Constructor.canBuildMore()) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_OBSERVER)) {
            return;
        }
        if (Constructor.roomCanBuildMore(room, STRUCTURE_EXTENSION)) {
            return;
        }
        const bestPosition = this.safePositions(room).sort((a, b) => {
            if (!room.storage) {
                return -99999;
            }
            return a.getRangeTo(room.storage) - b.getRangeTo(room.storage);
        })[0];
        if (!bestPosition) {
            return;
        }
        Constructor.createConstructionSite(room, bestPosition.x, bestPosition.y, STRUCTURE_OBSERVER);
    }
    static safePositions(room) {
        const terrain = room.getTerrain();
        const positions = [];
        const extensionBlockFlags = Flags.roomFlags(room, FlagType.baseExtensionBlock);
        for (let x = 2; x <= 47; x++) {
            for (let y = 2; y <= 47; y++) {
                if (this.isPositionTooCloseToExit(room, x, y))
                    continue;
                if (this.isPositionTooCloseToLab(room, x, y))
                    continue;
                if (this.isPositionTooCloseToController(room, x, y))
                    continue;
                if (this.isPositionTooCloseToCenter(room, x, y))
                    continue;
                if (this.isPositionTooCloseToExtension(extensionBlockFlags, x, y))
                    continue;
                if (!this.isPositionValid(room, terrain, x, y))
                    continue;
                positions.push(new RoomPosition(x, y, room.name));
            }
        }
        return positions;
    }
    static isPositionTooCloseToCenter(room, x, y) {
        if (!room.center)
            return true;
        return Math.max(Math.abs(x - room.center.x), Math.abs(y - room.center.y)) <= 8;
    }
    static isPositionTooCloseToExtension(extensionFlags, x, y) {
        return extensionFlags.filter(flag => flag.pos.getRangeTo(x, y) < 2).length > 0;
    }
    static isPositionTooCloseToLab(room, x, y) {
        return (new RoomPosition(x, y, room.name)
            .findInRange(FIND_FLAGS, 3)
            .filter(f => Flags.getType(f) === FlagType.baseLabBlock).length > 0);
    }
    static isPositionTooCloseToExit(room, x, y) {
        return new RoomPosition(x, y, room.name).findInRange(FIND_EXIT, 7).length > 0;
    }
    static isPositionTooCloseToController(room, x, y) {
        return (new RoomPosition(x, y, room.name).findInRange(FIND_STRUCTURES, 6, {
            filter: s => s.structureType === STRUCTURE_CONTROLLER
        }).length > 0);
    }
    static isPositionValid(room, terrain, x, y) {
        if (terrain.get(x, y) === TERRAIN_MASK_WALL)
            return false;
        const structures = room.lookForAt(LOOK_STRUCTURES, x, y);
        if (structures.length > 0)
            return false;
        const constructions = room.lookForAt(LOOK_CONSTRUCTION_SITES, x, y);
        if (constructions.length > 0)
            return false;
        return true;
    }
}

function exitTileToRoom(pos) {
    const [roomX, roomY] = Geo.roomNameToXY(pos.roomName);
    if (pos.x === 0) {
        return Geo.roomXYToName(roomX - 1, roomY);
    }
    if (pos.x === 49) {
        return Geo.roomXYToName(roomX + 1, roomY);
    }
    if (pos.y === 0) {
        return Geo.roomXYToName(roomX, roomY - 1);
    }
    if (pos.y === 49) {
        return Geo.roomXYToName(roomX, roomY + 1);
    }
    throw Error("exit tile provided is not exit" + JSON.stringify(pos));
}

const STRUCTURES_TO_RAMPART_UP = [
    STRUCTURE_STORAGE,
    STRUCTURE_TERMINAL,
    STRUCTURE_SPAWN,
    STRUCTURE_POWER_SPAWN,
    STRUCTURE_FACTORY,
    STRUCTURE_NUKER,
    STRUCTURE_LAB
    // STRUCTURE_TOWER
];
const CONFIG$t = Config.BaseRampartConstruction;
class BaseRampartConstruction {
    static handle() {
        General.interval(CONFIG$t.interval, () => {
            TickAction.add(() => Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            }));
        });
    }
    static handleRoom(room) {
        if (room.isGclFarm) {
            return;
        }
        if (!Constructor.canBuildMore()) {
            return;
        }
        if (!room.my) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (room.isAbandoning) {
            return;
        }
        if (room.controller.level < 5) {
            return;
        }
        if (room.energyCapacityAvailable < 1500) {
            return;
        }
        if (!room.storage) {
            return;
        }
        if (room.storage.store.energy < 40000) {
            return;
        }
        this.protectBuildings(room);
        this.protectEdges(room);
        this.protectEdgesWithWalls(room);
        this.protecteCenterBuildings(room);
        this.buildRoadsOnSwamps(room);
        this.protectEdgeBuildings(room);
        this.protectEdgeMiningPositions(room);
    }
    static buildRoadsOnSwamps(room) {
        const positions = this.getCachedRampartPositions(room);
        if (!positions) {
            return;
        }
        const terrain = room.getTerrain();
        positions.forEach(pos => {
            if (terrain.get(pos.x, pos.y) !== TERRAIN_MASK_SWAMP) {
                return;
            }
            if (pos.lookFor(LOOK_CONSTRUCTION_SITES).length > 0) {
                return;
            }
            if (pos.road) {
                return;
            }
            Constructor.createConstructionSite(room, pos.x, pos.y, STRUCTURE_ROAD);
        });
    }
    static protectEdgeBuildings(room) {
        room
            .find(FIND_MY_STRUCTURES)
            .filter(s => s.structureType === STRUCTURE_LINK)
            .forEach(structure => {
            if (structure.pos.x < 45 && structure.pos.x > 4 && structure.pos.y < 45 && structure.pos.y > 4) {
                return;
            }
            if (structure.pos.rampart) {
                return;
            }
            if (structure.pos.findInRange(FIND_EXIT, 4).length === 0) {
                return;
            }
            if (structure.pos.lookFor(LOOK_CONSTRUCTION_SITES).length > 0) {
                return;
            }
            Constructor.createConstructionSite(room, structure.pos.x, structure.pos.y, STRUCTURE_RAMPART);
        });
    }
    static protectEdgeMiningPositions(room) {
        room
            .find(FIND_SOURCES)
            .map(source => room.sourceOptions(source))
            .forEach(sourceOptions => {
            if (!sourceOptions.miningPos) {
                return;
            }
            const miningPos = new RoomPosition(sourceOptions.miningPos.x, sourceOptions.miningPos.y, room.name);
            if (miningPos.x < 45 && miningPos.x > 4 && miningPos.y < 45 && miningPos.y > 4) {
                return;
            }
            if (miningPos.rampart) {
                return;
            }
            if (miningPos.findInRange(FIND_EXIT, 4).length === 0) {
                return;
            }
            if (miningPos.lookFor(LOOK_CONSTRUCTION_SITES).length > 0) {
                return;
            }
            Constructor.createConstructionSite(room, miningPos.x, miningPos.y, STRUCTURE_RAMPART);
        });
    }
    static protectBuildings(room) {
        room
            .find(FIND_STRUCTURES, {
            filter: s => STRUCTURES_TO_RAMPART_UP.includes(s.structureType)
        })
            .forEach(structure => {
            if (!Constructor.canBuildMore()) {
                return;
            }
            const ramparts = structure.pos.lookFor(LOOK_STRUCTURES).filter(s => s.structureType === STRUCTURE_RAMPART);
            if (ramparts.length > 0) {
                return;
            }
            const rampartConstructions = structure.pos
                .lookFor(LOOK_CONSTRUCTION_SITES)
                .filter(s => s.structureType === STRUCTURE_RAMPART);
            if (rampartConstructions.length > 0) {
                return;
            }
            Constructor.createConstructionSite(structure.room, structure.pos.x, structure.pos.y, STRUCTURE_RAMPART);
        });
    }
    static exitRadiusPositions(exit) {
        const coords = [];
        coords.push(...General.squarePositions(exit.roomName, exit.x, exit.y, 2));
        const keyedCoords = coords.reduce((keyed, pos) => {
            keyed[`${pos.x}.${pos.y}`] = pos;
            return keyed;
        }, {});
        return Object.values(keyedCoords);
    }
    static protectEdges(room) {
        let currentConstructions = room.find(FIND_MY_CONSTRUCTION_SITES, {
            filter: c => c.structureType === STRUCTURE_RAMPART
        }).length;
        if (CONFIG$t.maxConstructionsPerRoom < currentConstructions) {
            return;
        }
        const positions = this.getCachedRampartPositions(room) || this.createRampartPositions(room);
        positions.forEach(pos => {
            if (CONFIG$t.maxConstructionsPerRoom < currentConstructions) {
                return;
            }
            if (pos.hasRampart) {
                return;
            }
            if (pos.lookFor(LOOK_CONSTRUCTION_SITES).length > 0) {
                return;
            }
            if (!room.wasRecentlyUnderAttack && room.level >= 8) {
                const wall = pos.lookFor(LOOK_STRUCTURES).filter(s => s.structureType === STRUCTURE_WALL)[0];
                if (wall) {
                    wall.destroy();
                }
            }
            Constructor.createConstructionSite(room, pos.x, pos.y, STRUCTURE_RAMPART);
            currentConstructions++;
            room.visual.circle(pos.x, pos.y, { radius: 0.5, fill: "#fff" });
        });
    }
    static protectEdgesWithWalls(room) {
        var _a, _b;
        let currentConstructions = room.find(FIND_MY_CONSTRUCTION_SITES, {
            filter: c => c.structureType === STRUCTURE_RAMPART
        }).length;
        if (CONFIG$t.maxConstructionsPerRoom < currentConstructions) {
            return;
        }
        const positions = ((_b = (_a = room.mem.layout) === null || _a === void 0 ? void 0 : _a[STRUCTURE_WALL]) === null || _b === void 0 ? void 0 : _b.map(p => new RoomPosition(p[0], p[1], room.name))) || [];
        positions.forEach(pos => {
            if (CONFIG$t.maxConstructionsPerRoom < currentConstructions) {
                return;
            }
            if (pos.hasRampart) {
                return;
            }
            if (pos.lookFor(LOOK_CONSTRUCTION_SITES).length > 0) {
                return;
            }
            Constructor.createConstructionSite(room, pos.x, pos.y, STRUCTURE_WALL);
            currentConstructions++;
            room.visual.circle(pos.x, pos.y, { radius: 0.5, fill: "#fff" });
        });
    }
    static getCachedRampartPositions(room) {
        var _a, _b;
        return (_b = (_a = room.mem.layout) === null || _a === void 0 ? void 0 : _a[STRUCTURE_RAMPART]) === null || _b === void 0 ? void 0 : _b.map(p => new RoomPosition(p[0], p[1], room.name));
    }
    static createRampartPositions(room) {
        const terrain = room.getTerrain();
        const validExitRooms = this.validExitRooms(room.name);
        const exits = room.find(FIND_EXIT);
        const uniquePositions = Object.values(exits.reduce((keyed, exit) => {
            const exitRoomName = exitTileToRoom(exit);
            if (!validExitRooms.includes(exitRoomName)) {
                return keyed;
            }
            room.visual.circle(exit.x, exit.y, { radius: 0.3 });
            this.exitRadiusPositions(exit).forEach(pos => {
                keyed[`${pos.x}.${pos.y}`] = new RoomPosition(pos.x, pos.y, room.name);
            });
            return keyed;
        }, {}));
        const wallPositions = [];
        const positions = uniquePositions
            .filter(pos => exits.filter(e => e.getRangeTo(pos.x, pos.y) <= 1).length === 0)
            .filter(pos => {
            if (!this.isCoordGood(room, terrain, pos.x, pos.y)) {
                return false;
            }
            return true;
        })
            .filter(pos => {
            const ret = PathFinder.search(pos, exits, {
                maxRooms: 1,
                maxCost: 3,
                plainCost: 1,
                swampCost: 1
            });
            return !ret.incomplete;
        })
            .filter(pos => {
            var _a;
            const center = ((_a = room.storage) === null || _a === void 0 ? void 0 : _a.pos) || room.center;
            if (!center) {
                return false;
            }
            const ret = PathFinder.search(center, pos, {
                maxRooms: 1,
                maxCost: 1000,
                plainCost: 1,
                swampCost: 1,
                roomCallback(roomName) {
                    const matrix = room.matrix();
                    room.edgeDangerPositions.forEach(p => {
                        matrix.set(p.pos.x, p.pos.y, 256);
                    });
                    return matrix;
                }
            });
            if (ret.incomplete) {
                wallPositions.push(pos);
            }
            return !ret.incomplete;
        });
        room.mem.layout = Object.assign(Object.assign({}, room.mem.layout), { [STRUCTURE_RAMPART]: positions.map(p => [p.x, p.y]), [STRUCTURE_WALL]: wallPositions.map(p => [p.x, p.y]) });
        return positions;
    }
    static validExitRooms(roomName) {
        return Object.values(Game.map.describeExits(roomName)).filter(exitRoomName => exitRoomName && Object.values(Game.map.describeExits(exitRoomName)).length > 1);
    }
    static protecteCenterBuildings(room) {
        if (!room.center)
            return;
        const structures = room.center
            .findInRange(FIND_STRUCTURES, 1)
            .filter(s => s.structureType !== STRUCTURE_RAMPART && !s.pos.hasRampart);
        structures.forEach(s => {
            Constructor.createConstructionSite(room, s.pos.x, s.pos.y, STRUCTURE_RAMPART);
            room.visual.circle(s.pos.x, s.pos.y, { radius: 0.5, fill: "#fff" });
        });
    }
    static isCoordGood(room, terrain, x, y) {
        if (x <= 0) {
            return false;
        }
        if (x >= 49) {
            return false;
        }
        if (y <= 0) {
            return false;
        }
        if (y >= 49) {
            return false;
        }
        return terrain.get(x, y) !== TERRAIN_MASK_WALL;
    }
}

const CONFIG$s = Config.BaseTowerConstruction;
class BaseTowerConstruction {
    static handle() {
        General.interval(CONFIG$s.interval, () => {
            TickAction.add(() => Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            }));
        });
    }
    static handleRoom(room) {
        if (room.isGclFarm) {
            return;
        }
        if (!Constructor.canBuildMore(1)) {
            return;
        }
        if (Game.cpu.bucket < 500) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_TOWER, 1)) {
            return;
        }
        if (room.find(FIND_MY_CONSTRUCTION_SITES, { filter: s => s.structureType === STRUCTURE_TOWER }).length > 0) {
            return;
        }
        const roomCenter = room.center;
        if (!roomCenter) {
            return;
        }
        const terrain = room.getTerrain();
        const exits = this.getvalidExits(room, terrain);
        if (exits.length === 0) {
            console.log(room.name, "BaseTowerConstruction", "Cannot find a single exit");
            return;
        }
        const possibleLocations = this.getPossibleCoordinates(room, terrain);
        if (possibleLocations.length === 0) {
            console.log(room.name, "BaseTowerConstruction", "something wrong cause no possible locations for tower");
            return;
        }
        possibleLocations.forEach(pos => {
            new RoomVisual(room.name).circle(pos.x, pos.y, { radius: 0.2, fill: "#fff" });
        });
        const lowestExits = exits.sort((a, b) => a.damage - b.damage).slice(0, Math.ceil(exits.length / 3));
        const bestPosition = this.bestTowerPosition(possibleLocations, lowestExits);
        exits.forEach(exit => {
            exit.damage += General.towerDamage(exit.pos, new RoomPosition(bestPosition.x, bestPosition.y, bestPosition.roomName));
        });
        new RoomVisual(room.name).circle(bestPosition.x, bestPosition.y, { radius: 0.3, fill: "#f00" });
        Constructor.createConstructionSite(room, bestPosition.x, bestPosition.y, STRUCTURE_TOWER);
        console.log(room.name, "BaseTowerConstruction", "creating tower construction");
        exits.forEach(exit => {
            let y = exit.pos.y;
            if (y === 0) {
                y = exit.pos.x % 3;
            }
            if (y === 49) {
                y = 49 - (exit.pos.x % 3);
            }
            let align = "center";
            if (exit.pos.x === 0) {
                align = "left";
            }
            if (exit.pos.x === 49) {
                align = "right";
            }
            new RoomVisual(exit.pos.roomName).text(`${exit.damage}`, exit.pos.x, y, { align });
        });
    }
    static validExitRooms(roomName) {
        return Object.values(Game.map.describeExits(roomName)).filter(exitRoomName => exitRoomName && Object.values(Game.map.describeExits(exitRoomName)).length > 1);
    }
    static getvalidExits(room, terrain) {
        const roomCenter = room.center;
        if (!roomCenter) {
            console.log(room.name, "BaseTowerConstruction", "missing RoomCenter");
            return [];
        }
        const validExitRooms = this.validExitRooms(room.name);
        const exitPathMatrix = this.validExitGeneralCostMatrix();
        const exits = room.find(FIND_EXIT).filter(pos => {
            const exitRoomName = exitTileToRoom(pos);
            if (!validExitRooms.includes(exitRoomName)) {
                return false;
            }
            const ret = PathFinder.search(roomCenter, pos, {
                maxRooms: 1,
                plainCost: 1,
                swampCost: 1,
                maxOps: 500,
                roomCallback: () => this.validExitCostMatrix(terrain, exitPathMatrix, pos)
            });
            return !ret.incomplete;
        });
        return exits.map(pos => ({
            pos,
            damage: room.towers.reduce((damage, tower) => {
                return damage + General.towerDamage(pos, tower.pos);
            }, 0)
        }));
    }
    static validExitCostMatrix(terrain, matrix, pos) {
        const newMatrix = matrix.clone();
        newMatrix.set(pos.x, pos.y, 1);
        if (pos.x === 0 && terrain.get(1, pos.y) !== TERRAIN_MASK_WALL) {
            newMatrix.set(1, pos.y, 1);
        }
        if (pos.x === 49 && terrain.get(48, pos.y) !== TERRAIN_MASK_WALL) {
            newMatrix.set(48, pos.y, 1);
        }
        if (pos.y === 0 && terrain.get(pos.x, 1) !== TERRAIN_MASK_WALL) {
            newMatrix.set(pos.x, 1, 1);
        }
        if (pos.y === 49 && terrain.get(pos.x, 48) !== TERRAIN_MASK_WALL) {
            newMatrix.set(pos.x, 48, 1);
        }
        return newMatrix;
    }
    static validExitGeneralCostMatrix() {
        const matrix = new PathFinder.CostMatrix();
        for (let i = 0; i < 49; i++) {
            matrix.set(0, i, 255);
            matrix.set(1, i, 255);
            matrix.set(48, i, 255);
            matrix.set(49, i, 255);
            matrix.set(i, 0, 255);
            matrix.set(i, 1, 255);
            matrix.set(i, 49, 255);
            matrix.set(i, 48, 255);
        }
        return matrix;
    }
    static bestTowerPosition(positions, exits) {
        return positions.sort((a, b) => exits.reduce((total, exit) => total + General.towerDamage(exit.pos, b), 0) -
            exits.reduce((total, exit) => total + General.towerDamage(exit.pos, a), 0))[0];
    }
    static getPossibleCoordinates(room, terrain) {
        const roomCenter = room.center;
        if (!roomCenter) {
            return [];
        }
        const positions = [];
        for (let x = 0; x < 49; x++) {
            for (let y = 0; y < 49; y++) {
                positions.push(new RoomPosition(x, y, room.name));
            }
        }
        const nonWalkableMatrix = new PathFinder.CostMatrix();
        const isCenterOutOfBounds = roomCenter.x < 5 || roomCenter.x > 44 || roomCenter.y < 5 || roomCenter.y > 44;
        for (let i = 5; i < 44; i++) {
            if (!isCenterOutOfBounds || roomCenter.getRangeTo(new RoomPosition(5, i + 1, roomCenter.roomName)) > 2) {
                nonWalkableMatrix.set(5, i + 1, 255);
            }
            if (!isCenterOutOfBounds || roomCenter.getRangeTo(new RoomPosition(44, i, roomCenter.roomName)) > 2) {
                nonWalkableMatrix.set(44, i, 255);
            }
            if (!isCenterOutOfBounds || roomCenter.getRangeTo(new RoomPosition(i, 5, roomCenter.roomName)) > 2) {
                nonWalkableMatrix.set(i, 5, 255);
            }
            if (!isCenterOutOfBounds || roomCenter.getRangeTo(new RoomPosition(i + 1, 44, roomCenter.roomName)) > 2) {
                nonWalkableMatrix.set(i + 1, 44, 255);
            }
        }
        return positions
            .filter(pos => {
            return terrain.get(pos.x, pos.y) !== TERRAIN_MASK_WALL;
        })
            .filter(pos => room.lookForAt(LOOK_STRUCTURES, pos.x, pos.y).filter(s => s.structureType !== STRUCTURE_RAMPART).length === 0)
            .filter(pos => pos.findInRange(FIND_SOURCES, 2).length === 0)
            .filter(pos => pos.findInRange(FIND_MINERALS, 2).length === 0)
            .filter(pos => {
            const ret = PathFinder.search(roomCenter, pos, {
                plainCost: 1,
                swampCost: 1,
                maxRooms: 1,
                maxOps: 500,
                roomCallback() {
                    const matrix = nonWalkableMatrix.clone();
                    matrix.set(pos.x, pos.y, 1);
                    return matrix;
                }
            });
            return !ret.incomplete;
        });
    }
}

const CONFIG$r = Config.DismantlerDuo;
const TARGET_PRIORITY = {
    [STRUCTURE_TOWER]: 1,
    [STRUCTURE_LAB]: 2,
    [STRUCTURE_FACTORY]: 2,
    [STRUCTURE_SPAWN]: 2,
    [STRUCTURE_NUKER]: 3,
    [STRUCTURE_EXTENSION]: 4,
    [STRUCTURE_EXTRACTOR]: 20,
    [STRUCTURE_LINK]: 20,
    [STRUCTURE_OBSERVER]: 20,
    [STRUCTURE_POWER_SPAWN]: 20,
    [STRUCTURE_TERMINAL]: 30,
    [STRUCTURE_STORAGE]: 50,
    [STRUCTURE_ROAD]: 60,
    [STRUCTURE_RAMPART]: 70,
    [STRUCTURE_WALL]: 100,
    [STRUCTURE_CONTAINER]: 100,
    [STRUCTURE_CONTROLLER]: Infinity,
    [STRUCTURE_INVADER_CORE]: Infinity,
    [STRUCTURE_KEEPER_LAIR]: Infinity,
    [STRUCTURE_PORTAL]: Infinity,
    [STRUCTURE_POWER_BANK]: Infinity
};
class DismantlerDuo {
    static handle() {
        Duos.duosByName(CONFIG$r.duoName).forEach(duo => {
            this.worker(duo);
        });
        General.interval(CONFIG$r.spawnFlagInterval, () => TickAction.add(() => this.flagSpawner()));
    }
    static worker(duo) {
        var _a;
        switch (duo.memory.stage) {
            case DuoGroupStage.SPAWNING: {
                duo.handleSpawning();
                break;
            }
            case DuoGroupStage.BOOSTING: {
                duo.handleBoosting();
                break;
            }
            case DuoGroupStage.WORKING: {
                if (!duo.attacker || !duo.healer) {
                    console.log("missing one of the fucks");
                    duo.memory.stage = DuoGroupStage.RETREATING;
                    return;
                }
                if (duo.targetFlag && duo.targetFlag.room && ((_a = duo.targetFlag.room.controller) === null || _a === void 0 ? void 0 : _a.safeMode)) {
                    duo.memory.stage = DuoGroupStage.RETREATING;
                    return;
                }
                this.handleAttacker(duo, duo.attacker);
                this.handleHealer(duo.healer);
                this.dieNoTicks(duo, duo.attacker, duo.healer) ||
                    this.retreat(duo, duo.attacker, duo.healer) ||
                    this.groupUp(duo, duo.attacker, duo.healer) ||
                    this.waitFatigue(duo.attacker, duo.healer) ||
                    this.moveToFlagRoom(duo, duo.attacker, duo.healer) ||
                    this.stepOffEdge(duo, duo.attacker, duo.healer) ||
                    this.moveToFlagStructure(duo, duo.attacker, duo.healer) ||
                    this.moveToGrayFlagStructure(duo, duo.attacker, duo.healer) ||
                    this.moveToHostileStructure(duo, duo.attacker, duo.healer) ||
                    this.moveToSafeSpot(duo, duo.attacker, duo.healer) ||
                    this.moveToLowestDefence(duo, duo.attacker, duo.healer) ||
                    this.moveToFlag(duo, duo.attacker, duo.healer);
                break;
            }
            case DuoGroupStage.RETREATING: {
                if (duo.attacker) {
                    this.handleAttacker(duo, duo.attacker);
                }
                if (duo.healer) {
                    this.handleHealer(duo.healer);
                }
                duo.handleRetreating();
                break;
            }
        }
    }
    static moveToFlag(duo, attacker, healer) {
        if (!duo.targetFlag) {
            return false;
        }
        attacker.travel(duo.targetFlag, { ignoreCreeps: false, freshPath: true });
        healer.moveTo(attacker);
        return true;
    }
    static dieNoTicks(duo, attacker, healer) {
        if (attacker.ticksToLive !== 1 && healer.ticksToLive !== 1) {
            return false;
        }
        attacker.die();
        healer.die();
        if (Memory.duos) {
            delete Memory.duos[duo.memory.id];
        }
        return true;
    }
    static stepOffEdge(duo, attacker, healer) {
        if (!duo.targetFlag) {
            return false;
        }
        if (duo.targetFlag.pos.roomName !== healer.room.name) {
            return false;
        }
        if (!healer.pos.isRoomEdge) {
            return false;
        }
        const position = attacker.pos.openSpots.filter(p => !p.creep && !p.isRoomEdge && p.getRangeTo(healer) === 1)[0];
        if (!position) {
            return false;
        }
        healer.moveTo(position, { ignoreCreeps: false, reusePath: 0 });
        return true;
    }
    static retreat(duo, attacker, healer) {
        if (!duo.targetFlag) {
            return false;
        }
        const targetRoom = Rooms.model(duo.targetFlag.pos.roomName);
        if (!targetRoom.isInSafeMode) {
            return false;
        }
        attacker.recycleFinal(1500);
        healer.recycleFinal(1500);
        return true;
    }
    static waitFatigue(attacker, healer) {
        return attacker.fatigue !== 0 || healer.fatigue !== 0;
    }
    static moveToGrayFlagStructure(duo, attacker, healer) {
        const flags = attacker.room.find(FIND_FLAGS, {
            filter: f => Flags.getType(f) === FlagType.dismantleTarget &&
                f.pos.lookFor(LOOK_STRUCTURES).filter(s => s.structureType !== STRUCTURE_STORAGE).length > 0 // &&
            // f.pos.findInRange(FIND_HOSTILE_CREEPS, 5, { filter: c => c.attackPower > 1200 }).length === 0
        });
        if (flags.length === 0) {
            return false;
        }
        if (flags.filter(f => f.pos.getRangeTo(attacker) <= 1).length !== 0) {
            return true;
        }
        const flag = attacker.pos.findClosestByPath(FIND_FLAGS, {
            filter: f => Flags.getType(f) === FlagType.dismantleTarget &&
                f.pos.lookFor(LOOK_STRUCTURES).length > 0 &&
                f.pos.findInRange(FIND_HOSTILE_CREEPS, 5, { filter: c => c.attackPower > 1200 }).length === 0
        });
        if (!flag) {
            return false;
        }
        const distance = attacker.pos.getRangeTo(flag);
        if (distance > 1) {
            attacker.travel(flag, { ignoreCreeps: false, freshPath: true });
            healer.moveTo(attacker);
        }
        return true;
    }
    static moveToFlagStructure(duo, attacker, healer) {
        if (!duo.targetFlag) {
            return false;
        }
        if (!duo.targetFlag.room) {
            return false;
        }
        const structure = duo.targetFlag.pos.lookFor(LOOK_STRUCTURES)[0];
        if (!structure) {
            return false;
        }
        const distance = attacker.pos.getRangeTo(structure);
        if (distance > 1) {
            if (attacker.pos.isPosReachable(duo.targetFlag.pos)) {
                attacker.travel(structure, { ignoreCreeps: false, freshPath: true });
                healer.moveTo(attacker);
            }
            else {
                return false;
            }
        }
        return true;
    }
    static moveToSafeSpot(duo, attacker, healer) {
        const flag = attacker.room.find(FIND_FLAGS, {
            filter: f => f.color === COLOR_YELLOW && f.secondaryColor === COLOR_WHITE
        })[0];
        if (!flag) {
            return false;
        }
        const distance = attacker.pos.getRangeTo(flag);
        if (distance > 2) {
            attacker.travel(flag, { ignoreCreeps: false, freshPath: true });
            healer.moveTo(attacker);
        }
        return true;
    }
    static moveToHostileStructure(duo, attacker, healer) {
        if (attacker.room.my) {
            return false;
        }
        const structure = (attacker.room.find(FIND_HOSTILE_STRUCTURES, {
            filter: s => s.hits > 0 &&
                (s.structureType !== STRUCTURE_STORAGE || s.isWorthless) &&
                s.structureType !== STRUCTURE_RAMPART &&
                !s.pos.rampart
        }) ||
            attacker.room.find(FIND_HOSTILE_STRUCTURES, {
                filter: s => s.hits > 0 &&
                    (s.structureType !== STRUCTURE_STORAGE || s.isWorthless) &&
                    s.structureType !== STRUCTURE_RAMPART
            }) ||
            attacker.room.find(FIND_HOSTILE_STRUCTURES, {
                filter: s => s.hits > 0 && (s.structureType !== STRUCTURE_STORAGE || s.isWorthless)
            }))
            .sort((a, b) => {
            const aPrio = TARGET_PRIORITY[a.structureType];
            const bPrio = TARGET_PRIORITY[b.structureType];
            if (aPrio === bPrio) {
                return a.pos.getRangeTo(attacker) - b.pos.getRangeTo(attacker);
            }
            return aPrio - bPrio;
        })
            .find(s => attacker.pos.isPosReachable(s.pos));
        if (!structure) {
            return false;
        }
        const distance = attacker.pos.getRangeTo(structure);
        if (distance > 1) {
            attacker.travel(structure, { ignoreCreeps: false, freshPath: true });
            healer.moveTo(attacker);
        }
        return true;
    }
    static moveToLowestDefence(duo, attacker, healer) {
        var _a, _b;
        if (attacker.room.my) {
            return false;
        }
        if (((_b = (_a = attacker.room.controller) === null || _a === void 0 ? void 0 : _a.reservation) === null || _b === void 0 ? void 0 : _b.username) === USERNAME.ME) {
            return false;
        }
        const defence = attacker.room
            .find(FIND_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_WALL || s.structureType === STRUCTURE_RAMPART
        })
            .sort((a, b) => a.hits - b.hits)
            .find(s => attacker.pos.isPosReachable(s.pos));
        if (!defence) {
            return false;
        }
        const distance = attacker.pos.getRangeTo(defence);
        if (distance > 1) {
            attacker.travel(defence, { ignoreCreeps: false, freshPath: true });
            healer.moveTo(attacker);
        }
        return true;
    }
    static groupUp(duo, attacker, healer) {
        const distance = attacker.wpos.getRangeTo(healer.wpos);
        if (distance <= 1) {
            return false;
        }
        if (attacker.pos.isRoomEdge && distance <= 2) {
            return false;
        }
        if (healer.pos.isRoomEdge && distance <= 2) {
            return false;
        }
        healer.travel(attacker);
        return true;
    }
    static moveToFlagRoom(duo, attacker, healer) {
        if (!duo.targetFlag) {
            return false;
        }
        if (attacker.room.name === duo.targetFlag.pos.roomName) {
            return false;
        }
        attacker.travel(duo.targetFlag) || attacker.travelToRoom(duo.targetFlag.pos.roomName);
        // attacker.moveToSiegeFlagRoom(duo.targetFlag);
        healer.moveTo(attacker);
        return true;
    }
    static handleHealer(creep) {
        creep.rangedBestAttack();
        if (!creep.healPower) {
            return;
        }
        creep.healMele() || creep.prehealMele();
    }
    static rangedAttack(duo, creep) {
        if (creep.room.name !== duo.memory.targetRoom) {
            return;
        }
        if (!creep.rangedAttackPower) {
            return;
        }
        const enemy = creep.pos
            .findInRange(FIND_HOSTILE_CREEPS, 3, { filter: c => !c.pos.rampart && !c.isFriendly })
            .sort((a, b) => b.hitsMax - b.hits - a.hitsMax - a.hits)[0] ||
            creep.pos
                .findInRange(FIND_STRUCTURES, 3, { filter: s => s.structureType === STRUCTURE_ROAD && !s.pos.rampart })
                .sort((a, b) => a.hits - b.hits)[0];
        if (!enemy) {
            return;
        }
        creep.rangedAttack(enemy);
    }
    static dismantle(duo, creep) {
        var _a;
        if (creep.room.name !== ((_a = duo.targetFlag) === null || _a === void 0 ? void 0 : _a.pos.roomName)) {
            return false;
        }
        if (creep.room.my) {
            return false;
        }
        if (!creep.dismantlePower) {
            return false;
        }
        const structures = creep.pos.findInRange(FIND_STRUCTURES, 1, { filter: s => s.hits > 0 });
        const hostileStructure = structures
            .filter(s => s.structureType !== STRUCTURE_RAMPART && s.structureType !== STRUCTURE_WALL && !s.pos.rampart)
            .sort((a, b) => a.hits - b.hits)[0] ||
            structures
                .filter(s => (s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_WALL) &&
                s.pos.lookFor(LOOK_FLAGS).filter(f => f.color === COLOR_YELLOW && f.secondaryColor === COLOR_GREY).length >
                    0)
                .sort((a, b) => a.hits - b.hits)[0] ||
            structures.filter(s => s.structureType === STRUCTURE_RAMPART).sort((a, b) => a.hits - b.hits)[0] ||
            structures.sort((a, b) => a.hits - b.hits)[0];
        if (!hostileStructure) {
            return false;
        }
        creep.dismantle(hostileStructure);
        return true;
    }
    static targetStructure(creep) {
        return creep.pos
            .findInRange(FIND_STRUCTURES, 1, {
            filter: c => c.hits && (c.structureType !== STRUCTURE_STORAGE || c.isWorthless)
        })
            .filter(s => s.room.model.canAttackStructures &&
            (!s.effects || s.effects.filter(e => e.effect === PWR_FORTIFY).length === 0) &&
            s.hits > 0)
            .sort((a, b) => a.hits - b.hits)[0];
    }
    static targetHostileRampart(creep) {
        return creep.pos
            .findInRange(FIND_HOSTILE_STRUCTURES, 1, {
            filter: c => c.hits && c.structureType === STRUCTURE_RAMPART
        })
            .filter(s => !s.effects || s.effects.filter(e => e.effect === PWR_FORTIFY).length === 0)
            .sort((a, b) => a.hits - b.hits)[0];
    }
    static targetHostileStructure(creep) {
        return creep.pos
            .findInRange(FIND_HOSTILE_STRUCTURES, 1, {
            filter: c => c.hits &&
                !c.pos.rampart &&
                (c.structureType !== STRUCTURE_STORAGE || c.isWorthless) &&
                c.structureType !== STRUCTURE_RAMPART
        })
            .filter(s => !s.effects || s.effects.filter(e => e.effect === PWR_FORTIFY).length === 0)
            .sort((a, b) => a.hits - b.hits)[0];
    }
    static targetSecondaryFlagStructure(creep) {
        return creep.pos
            .findInRange(FIND_FLAGS, 1, { filter: f => f.color === COLOR_GREY && f.secondaryColor === COLOR_GREY })
            .map(f => f.pos.lookFor(LOOK_STRUCTURES).filter(s => s.structureType !== STRUCTURE_STORAGE)[0])
            .filter(Boolean)
            .filter(s => s.structureType !== STRUCTURE_STORAGE)[0];
    }
    static targetFlagStructure(duo, creep) {
        const structure = duo.targetFlag && duo.targetFlag.room
            ? duo.targetFlag.pos.lookFor(LOOK_STRUCTURES).filter(s => !(s instanceof StructureStorage) || s.isWorthless)[0]
            : undefined;
        if (!structure) {
            return;
        }
        if (!structure.pos.isNearTo(creep)) {
            return;
        }
        return structure;
    }
    static handleAttacker(duo, creep) {
        this.rangedAttack(duo, creep);
        this.dismantle(duo, creep);
    }
    static flagSpawner() {
        Flags.flags(FlagType.dismantlerDuoTier3).forEach(flag => {
            const targetRoomName = flag.pos.roomName;
            const roomModel = Rooms.model(targetRoomName);
            if (roomModel.isInSafeMode) {
                return;
            }
            const activeDuos = Duos.duos.filter(duo => duo.memory.name === CONFIG$r.duoName &&
                duo.memory.targetFlag === flag.name &&
                duo.memory.ticksTo > 600 &&
                duo.memory.stage !== DuoGroupStage.RETREATING);
            if (activeDuos.length > 0) {
                return;
            }
            const spawnRoom = Geo.closestHomeRoomByRange(targetRoomName, {
                minLevel: 8,
                maxDistance: MAX_EXPANSION_RANGE * 2,
                room: room => {
                    return !room.isSpawningDuo && !room.isSpawningQuad;
                }
            });
            if (!spawnRoom) {
                return;
            }
            spawnRoom._isSpawningDuo = undefined;
            const duoId = Duos.create({
                homeRoom: spawnRoom.name,
                name: CONFIG$r.duoName,
                targetFlag: flag.name,
                targetRoom: flag.pos.roomName
            });
            Spawns.addToQue([spawnRoom.name], Object.assign(Object.assign({}, this.attackerTier1()), { 
                // ...attackerTest(),
                // ...attackerTier1Defensive(),
                // ...attackerTier2(),
                // ...attackerTier3(),
                // ...attackerTier4(),
                priority: 0 /* Highest */, role: CONFIG$r.roleNameAttacker, memory: {
                    duoId,
                    duoRole: "attacker"
                } }));
            Spawns.addToQue([spawnRoom.name], Object.assign(Object.assign({}, this.healerTier1()), { 
                // ...healerTier3(),
                // ...healerTier4(),
                priority: 0 /* Highest */, role: CONFIG$r.roleNameHealer, memory: {
                    duoId,
                    duoRole: "healer"
                } }));
            spawnRoom.mem.increasedSpawnUntil = Game.time + 2000;
        });
    }
    static attackerTest() {
        return {
            body: BodyParts.new().move().work()
        };
    }
    static healerTest() {
        return {
            body: BodyParts.new().move().heal()
        };
    }
    static attackerTier1() {
        return {
            body: BodyParts.new().tough(9).rangedAttack().move(10).work(30),
            boosts: [
                RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
                RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
                RESOURCE_CATALYZED_ZYNTHIUM_ACID,
                RESOURCE_CATALYZED_KEANIUM_ALKALIDE
            ]
        };
    }
    static healerTier1() {
        return {
            body: BodyParts.new().tough(10).move(8).heal(30).move(2),
            // body: BodyParts.new().move(8).heal(40).move(2),
            boosts: [
                RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
                RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
                RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE
            ]
        };
    }
    static healerTier2() {
        return {
            body: new BodyParts().add(TOUGH, 5).add(HEAL, 32).add(MOVE, 13).get(),
            boosts: [BOOST_ALIAS.TOUGH_3, BOOST_ALIAS.HEAL_2, BOOST_ALIAS.MOVE_2]
        };
    }
    static healerTier3() {
        return {
            body: new BodyParts().add(TOUGH, 5).add(HEAL, 27).add(MOVE, 17).get(),
            boosts: [BOOST_ALIAS.TOUGH_3, BOOST_ALIAS.HEAL_2, BOOST_ALIAS.MOVE_2]
        };
    }
}
__decorate([
    Profiler.subprofile("duo")
], DismantlerDuo, "worker", null);
__decorate([
    Profiler.subprofile("spawn")
], DismantlerDuo, "flagSpawner", null);

const CONFIG$q = Config.ExpansionClaimer;
class ExpansionClaimer {
    static handle() {
        Creeps.getByRole(CONFIG$q.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$q.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        this.drawTicksRemaining(creep);
        this.goToTargetRoom(creep) ||
            this.signController(creep) ||
            this.attackController(creep) ||
            this.claimController(creep) ||
            this.removeFlag(creep) ||
            this.removeConstructionSites(creep) ||
            this.suicide(creep);
    }
    static drawTicksRemaining(creep) {
        Game.map.visual.text(String(creep.ticksToLive), creep.pos);
    }
    static removeConstructionSites(creep) {
        creep.room.find(FIND_HOSTILE_CONSTRUCTION_SITES).forEach(s => s.remove());
    }
    static removeFlag(creep) {
        Flags.roomFlags(creep.room, FlagType.claimer).forEach(flag => flag.remove());
    }
    static signController(creep) {
        if (!creep.room.controller) {
            return false;
        }
        if (creep.room.name !== creep.memory.targetRoom) {
            return false;
        }
        if (creep.room.controller.signUsername === USERNAME.SCREEPS) {
            return false;
        }
        if (creep.room.controller.signText === SIGNATURE) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.controller);
        if (distance > 1) {
            creep.travel(creep.room.controller);
        }
        else {
            creep.signController(creep.room.controller, SIGNATURE);
        }
        return true;
    }
    static attackController(creep) {
        if (!creep.room.controller) {
            return false;
        }
        if (creep.room.controller.my) {
            return false;
        }
        if (!creep.room.controller.reservation) {
            return false;
        }
        if (creep.room.controller.reservation.username === USERNAME.ME) {
            return false;
        }
        if (creep.attackController(creep.room.controller) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.room.controller);
        }
        return true;
    }
    static claimController(creep) {
        if (!creep.room.controller) {
            return false;
        }
        if (creep.room.controller.my) {
            return false;
        }
        if (creep.claimController(creep.room.controller) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.room.controller);
        }
        return true;
    }
    static goToTargetRoom(creep) {
        const targetFlag = creep.targetFlag;
        if (!targetFlag) {
            return false;
        }
        if (creep.pos.getRangeTo(targetFlag) <= 1) {
            return false;
        }
        return creep.travel(targetFlag, { costRoomSk: 5, ignoreHostiles: false });
    }
    static suicide(creep) {
        if (creep.room.name !== creep.memory.targetRoom) {
            return false;
        }
        if (!creep.room.my) {
            return false;
        }
        creep.die();
        return true;
    }
    static handleSpawn() {
        const creeps = Creeps.getByRole(CONFIG$q.roleName);
        const que = Creeps.queByRole(CONFIG$q.roleName);
        Flags.flags(FlagType.claimer).forEach(flag => {
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetFlag) === flag.name; }).length > 0) {
                return;
            }
            if (creeps.filter(c => c.memory.targetFlag === flag.name).length > 0) {
                return;
            }
            const spawnRoom = Geo.closestHomeRoomByRange(flag.pos.roomName, {
                minLevel: 3,
                maxDistance: MAX_EXPANSION_RANGE,
                room: room => room.myActiveSpawns.length > 0
            });
            if (!spawnRoom) {
                return;
            }
            const targetRoom = Rooms.model(flag.pos.roomName);
            Spawns.addToQue(spawnRoom, {
                body: BodyParts.new().move().claim(),
                optionalBody: targetRoom.reservedUsername && targetRoom.reservedUsername !== USERNAME.ME
                    ? BodyParts.new().addMultiple([MOVE, CLAIM], 25)
                    : BodyParts.new().move(8),
                priority: CONFIG$q.spawnPriority,
                role: CONFIG$q.roleName,
                memory: { targetFlag: flag.name, targetRoom: flag.pos.roomName }
            });
        });
    }
}
__decorate([
    Profiler.subprofile("creep")
], ExpansionClaimer, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], ExpansionClaimer, "handleSpawn", null);

class ControllerStructureWorker {
    static handle() {
        General.myRooms.forEach(room => {
            this.handleRoom(room);
        });
    }
    static handleRoom(room) {
        if (!room.controller) {
            return;
        }
        if (!room.controller.safeModeAvailable) {
            return;
        }
        if (room.controller.safeModeCooldown) {
            return;
        }
        if (room.hostileAttackPower + room.hostileHealPower + room.hostileRangedAttackPower < 500) {
            return;
        }
        room.getEventLog().forEach(log => {
            var _a;
            if (log.event !== EVENT_OBJECT_DESTROYED) {
                return;
            }
            if (log.data.type !== STRUCTURE_RAMPART) {
                return;
            }
            Log.room(room, "activating safe mode");
            (_a = room.controller) === null || _a === void 0 ? void 0 : _a.activateSafeMode();
        });
    }
}

class LabStructureWorker {
    static handle() {
        Rooms.myRooms.forEach(room => {
            this.handleRoom(room);
        });
    }
    static handleRoom(room) {
        if (!room.mem.labOutputResource) {
            return;
        }
        General.interval(REACTION_TIME[room.mem.labOutputResource], () => {
            const reactorLabs = room.labOutputs;
            const inputLabs = room.labInputs;
            if (reactorLabs.length < 1 || inputLabs.length !== 2) {
                return;
            }
            // todo ignore taken labs for boosting
            reactorLabs.forEach(lab => {
                if (lab.cooldown > 0) {
                    return;
                }
                if (lab.pos.findInRange(FIND_MY_CREEPS, 6, {
                    filter: c => c.memory.recycling && c.body.filter(b => b.boost).length > 0
                }).length > 0) {
                    return;
                }
                lab.runReaction(inputLabs[0], inputLabs[1]);
            });
        });
    }
}

class LinkStructureWorker {
    static handle() {
        Rooms.myRooms.forEach(room => {
            this.handleRoom(room);
        });
    }
    static handleRoom(room) {
        for (const source of room.find(FIND_SOURCES)) {
            for (const link of source.links) {
                if (this.sendToControllerLink(link) ||
                    // this.sendtoControllerUpgraderCreep(link) ||
                    this.sendToCenterLink(link)) {
                    return;
                }
            }
        }
    }
    static sendToControllerLink(link) {
        if (link.cooldown > 0) {
            return false;
        }
        if (!link.room.controller) {
            return false;
        }
        if (link.store.energy < 300) {
            return false;
        }
        if (!link.room.controllerLink) {
            return false;
        }
        if (link.room.controllerLink.store.getFreeCapacity(RESOURCE_ENERGY) < 300) {
            return false;
        }
        if (link.room.controllerLink.pos.findInRange(FIND_SOURCES, 2).length > 0) {
            return false;
        }
        const minAmount = Math.min(link.store.energy, link.room.controllerLink.store.getFreeCapacity(RESOURCE_ENERGY));
        const roundedAmount = Math.floor(minAmount / 100) * 100;
        link.transferEnergy(link.room.controllerLink, roundedAmount);
        return true;
    }
    static sendtoControllerUpgraderCreep(link) {
        if (link.cooldown > 0) {
            return false;
        }
        if (!link.room.controller) {
            return false;
        }
        if (link.store.energy < 300) {
            return false;
        }
        const upgraderCreep = link.room.controller.pos.findInRange(FIND_MY_CREEPS, 3, {
            filter: c => c.memory.role === Config.BaseUpgrader.roleName && c.store.getFreeCapacity(RESOURCE_ENERGY) > 300
        })[0];
        if (!upgraderCreep) {
            return false;
        }
        const minAmount = Math.min(link.store.energy, upgraderCreep.store.getFreeCapacity(RESOURCE_ENERGY));
        const roundedAmount = Math.floor(minAmount / 100) * 100;
        const res = link.transferEnergy(upgraderCreep, roundedAmount);
        Log.object(link, res);
        return true;
    }
    static sendToCenterLink(link) {
        if (link.room.controller && link.pos.isNearTo(link.room.controller)) {
            return false;
        }
        if (!link.cachedIsActive()) {
            return false;
        }
        if (link.cooldown > 0) {
            return false;
        }
        if (link.room.centerLinks.length === 0) {
            return false;
        }
        const activeCenterLinks = link.room.centerLinks.filter(l => l.cachedIsActive());
        if (activeCenterLinks.length === 0) {
            return false;
        }
        if (LINK_CAPACITY - link.store.getUsedCapacity(RESOURCE_ENERGY) > 200) {
            return false;
        }
        const centerLinkReadyToReceive = activeCenterLinks.find(l => l.store.energy <= 300);
        if (!centerLinkReadyToReceive) {
            return false;
        }
        const minAmount = Math.min(link.store.energy, centerLinkReadyToReceive.store.getFreeCapacity(RESOURCE_ENERGY));
        const roundedAmount = Math.floor(minAmount / 100) * 100;
        link.transferEnergy(centerLinkReadyToReceive, roundedAmount);
        return true;
    }
}

const CONFIG$p = Config.ObserverStructureWorker;
const roomsScanned = {};
const observerTargets = {};
class ObserverStructureWorker {
    static handle() {
        if (Game.cpu.bucket < CONFIG$p.minBucket) {
            return;
        }
        Rooms.myRooms.forEach(room => {
            this.handleRoom(room);
        });
        General.interval(1000, () => this.cleanupDeadObservers());
        General.interval(1001, () => this.cleanupDeadTargets());
    }
    static cleanupDeadTargets() {
        for (const roomName in roomsScanned) {
            if (roomsScanned[roomName] < Game.time - 5000) {
                delete roomsScanned[roomName];
            }
        }
    }
    static cleanupDeadObservers() {
        for (const observerId in observerTargets) {
            const observer = Game.getObjectById(observerId);
            if (!observer) {
                delete observerTargets[observerId];
            }
        }
    }
    static handleRoom(room) {
        const observer = room.observer();
        if (!observer) {
            return;
        }
        const observerRooms = this.getCachedObserverTargetRooms(observer) || this.getObserverTargetRooms(observer);
        const oldestRoom = observerRooms
            .filter(r => !roomsScanned[r] || roomsScanned[r] < Game.time - 500)
            .sort((a, b) => (roomsScanned[a] || 0) - (roomsScanned[b] || 0))[0];
        if (!oldestRoom) {
            return;
        }
        roomsScanned[oldestRoom] = Game.time;
        observer.observeRoom(oldestRoom);
        // drawScannedRoom(observer.room.name, oldestRoom);
    }
    static getCachedObserverTargetRooms(observer) {
        return observerTargets[observer.id];
    }
    static getObserverTargetRooms(observer) {
        const rooms = [];
        const maxRoom = Math.floor(Game.map.getWorldSize() / 2);
        const [centerX, centerY] = Geo.roomNameToXY(observer.room.name);
        const range = Math.min(CONFIG$p.range, OBSERVER_RANGE);
        for (let x = -range; x < range; x++) {
            for (let y = -range; y < range; y++) {
                if (centerX + x >= maxRoom * 50) {
                    continue;
                }
                if (centerY + y >= maxRoom * 50) {
                    continue;
                }
                const roomName = Geo.roomXYToName(centerX + x, centerY + y);
                rooms.push(roomName);
            }
        }
        observerTargets[observer.id] = rooms;
        return rooms;
    }
    static drawScannedRoom(homeRoomName, roomName) {
        Game.map.visual.line(new RoomPosition(25, 25, homeRoomName), new RoomPosition(25, 25, roomName), {
            color: "#fff",
            width: 3
        });
        Game.map.visual.circle(new RoomPosition(25, 25, roomName), {
            radius: 20,
            fill: "#fff"
        });
    }
}

const CONFIG$o = Config.PowerSpawnStructureWorker;
class PowerSpawnStructureWorker {
    static handle() {
        Rooms.myRooms.forEach(room => {
            this.handleRoom(room);
        });
    }
    static handleRoom(room) {
        if (!room.controller) {
            return;
        }
        if (room.controller.level < 8) {
            return;
        }
        if (!room.storage) {
            return;
        }
        if (room.storage.store.energy < CONFIG$o.minStorageEnergy) {
            return;
        }
        if (!room.myCenterPowerSpawn) {
            return;
        }
        if (room.myCenterPowerSpawn.store.power === 0) {
            return;
        }
        if (room.myCenterPowerSpawn.store.energy < 50) {
            return;
        }
        room.myCenterPowerSpawn.processPower();
    }
}

function uniqueNumber() {
    if (!Memory.stats) {
        Memory.stats = { creepSpawnCount: 0 };
        console.log('initiating "Misc.stats"');
    }
    if (!Memory.stats.creepSpawnCount) {
        Memory.stats.creepSpawnCount = 0;
        console.log('reseting "Misc.stats.creepSpawnCount"');
    }
    Memory.stats.creepSpawnCount++;
    return Memory.stats.creepSpawnCount;
}

class SpawnStructureWorker {
    static handle() {
        General.interval(5, () => this.clearOldQue());
        this.spawnCreeps();
        // this.moveCreepsOutOfTheWay();
    }
    // private static moveCreepsOutOfTheWay(): void {
    //   Object.values(Game.spawns).forEach(spawn => {
    //     if (!spawn.spawning) {
    //       return;
    //     }
    //
    //     if (spawn.spawning.remainingTime !== 0) {
    //       return;
    //     }
    //
    //     const creeps = spawn.pos.findInRange(FIND_MY_CREEPS, 2);
    //
    //     creeps.forEach(creep => {
    //       creep.idleAwayFrom([STRUCTURE_SPAWN], 3);
    //     });
    //   });
    // }
    static spawnCreeps() {
        Rooms.myRooms.forEach(room => {
            if (!Memory.spawnQue) {
                return;
            }
            if (room.spawnActionPending) {
                return;
            }
            const spawns = room
                .find(FIND_MY_SPAWNS)
                .filter(spawn => !spawn.spawning &&
                !spawn.actionPending &&
                spawn.cachedIsActive() &&
                spawn.pos.findInRange(FIND_MY_CREEPS, 5, { filter: c => c.memory.recycling }).length === 0);
            if (spawns.length <= 0) {
                return;
            }
            const queues = Memory.spawnQue.filter(q => q.rooms.includes(room.name));
            for (const queue of queues) {
                if (queue.priority !== 0 /* Highest */ && (room.isSpawningQuad || room.isSpawningDuo)) {
                    continue;
                }
                if (this.spawnCreep(spawns[0], queue.body, queue.optionalBody || [], queue.role, Object.assign({ homeRoom: room.name, createdAt: Game.time }, (queue.memory || {})), queue.directionToCenter || false, queue.name)) {
                    Memory.spawnQue.splice(Memory.spawnQue.indexOf(queue), 1);
                    return;
                }
            }
        });
    }
    static clearOldQue() {
        if (!Memory.spawnQue) {
            return;
        }
        Memory.spawnQue = Memory.spawnQue.filter(que => que.expiresAt > Game.time);
    }
    static getCreepName() {
        return `c-${uniqueNumber()}`;
    }
    static spawnCreep(spawn, mandatoryBodyParts, optionalBodyParts, roleName, memory, directionFlag, name) {
        const body = mandatoryBodyParts;
        const newName = name ? name : this.getCreepName();
        const dryRun = spawn.spawnCreep(body, newName, { dryRun: true });
        if (dryRun === ERR_NAME_EXISTS) {
            console.log("Cant spawn creep, name already exists");
            return false;
        }
        if (dryRun !== OK) {
            return false;
        }
        if (optionalBodyParts && optionalBodyParts.length) {
            optionalBodyParts.forEach(part => {
                if (spawn.spawnCreep([...body, part], newName, { dryRun: true }) === OK) {
                    body.push(part);
                }
            });
        }
        let directions = [TOP, TOP_RIGHT, RIGHT, BOTTOM_RIGHT, BOTTOM, BOTTOM_LEFT, LEFT, TOP_LEFT];
        if (spawn.room.center) {
            if (directionFlag) {
                const position = spawn.pos.getDirectionTo(spawn.room.center);
                switch (position) {
                    case TOP:
                        directions = [TOP, TOP_LEFT, TOP_RIGHT];
                        break;
                    case TOP_RIGHT:
                        directions = [TOP_RIGHT, TOP, RIGHT];
                        break;
                    case RIGHT:
                        directions = [RIGHT, TOP_RIGHT, BOTTOM_RIGHT];
                        break;
                    case BOTTOM_RIGHT:
                        directions = [BOTTOM_RIGHT, RIGHT, BOTTOM];
                        break;
                    case BOTTOM:
                        directions = [BOTTOM, BOTTOM_RIGHT, BOTTOM_LEFT];
                        break;
                    case BOTTOM_LEFT:
                        directions = [BOTTOM_LEFT, BOTTOM, LEFT];
                        break;
                    case LEFT:
                        directions = [LEFT, BOTTOM_LEFT, TOP_LEFT];
                        break;
                    case TOP_LEFT:
                        directions = [TOP_LEFT, LEFT, TOP];
                        break;
                }
            }
            else {
                const position = spawn.room.center.getDirectionTo(spawn);
                switch (position) {
                    case TOP:
                        directions = [TOP, TOP_LEFT, TOP_RIGHT];
                        break;
                    case TOP_RIGHT:
                        directions = [TOP_RIGHT, TOP, RIGHT];
                        break;
                    case RIGHT:
                        directions = [RIGHT, TOP_RIGHT, BOTTOM_RIGHT];
                        break;
                    case BOTTOM_RIGHT:
                        directions = [BOTTOM_RIGHT, RIGHT, BOTTOM];
                        break;
                    case BOTTOM:
                        directions = [BOTTOM, BOTTOM_RIGHT, BOTTOM_LEFT];
                        break;
                    case BOTTOM_LEFT:
                        directions = [BOTTOM_LEFT, BOTTOM, LEFT];
                        break;
                    case LEFT:
                        directions = [LEFT, BOTTOM_LEFT, TOP_LEFT];
                        break;
                    case TOP_LEFT:
                        directions = [TOP_LEFT, LEFT, TOP];
                        break;
                }
            }
        }
        const response = spawn.spawnCreep(body, newName, {
            memory: Object.assign({ role: roleName, homeRoom: spawn.room.name }, memory),
            directions
        });
        if (response === OK) {
            spawn.room.spawnActionPending = true;
        }
        else {
            console.log("failed to spawn");
        }
        if (response === ERR_NAME_EXISTS) {
            console.log("Cant spawn creep, name already exists");
        }
        return response === OK;
    }
}

const CONFIG$n = Config.TerminalStructureWorker;
class TerminalStructureWorker {
    static handle() {
        const orderIntents = {};
        const terminals = this.getMyTerminals().map(terminal => ({
            intents: [],
            busy: false,
            terminal,
            incomingAmount: 0
        }));
        General.interval(TERMINAL_COOLDOWN, () => this.balance(terminals));
        General.interval(TERMINAL_COOLDOWN, () => this.balanceGclFarms(terminals));
        General.interval(TERMINAL_COOLDOWN, () => this.unloadAbandoningRooms(terminals));
        General.interval(TERMINAL_COOLDOWN, () => this.sell(terminals));
        General.interval(210, () => this.buyV2(terminals, orderIntents));
        General.interval(999, () => this.cancelOrders());
        General.interval(2000, () => this.unloadResourcesFromGclFarmRooms(terminals));
    }
    static cancelOrders() {
        Object.values(Game.market.orders).forEach(order => {
            if (order.remainingAmount > 0) {
                return;
            }
            Game.market.cancelOrder(order.id);
        });
    }
    static unloadResourcesFromGclFarmRooms(terminals) {
        Object.keys(GCL_POWERLEVEL_ROOMS).forEach(roomName => {
            const room = Game.rooms[roomName];
            if (!room) {
                return;
            }
            if (!room.controller) {
                return;
            }
            if (!room.controller.my) {
                return;
            }
            if (!room.terminal) {
                return;
            }
            if (room.terminal.cooldown) {
                return;
            }
            if (!room.terminal.isActive()) {
                return;
            }
            const resource = Resources.firstStoreResource(room.terminal.store, { except: [RESOURCE_ENERGY] });
            if (!resource) {
                return;
            }
            const amount = Math.min(10000, room.terminal.store[resource]);
            if (amount <= 0) {
                return;
            }
            const terminal = terminals
                .filter(t => !ABANDONING_ROOMS.includes(t.terminal.room.name))
                .filter(t => !Object.keys(GCL_POWERLEVEL_ROOMS).includes(t.terminal.room.name))
                .filter(t => t.terminal.cachedIsActive())
                .sort((a, b) => a.terminal.room.store[resource] - b.terminal.room.store[resource])[0];
            if (!terminal) {
                return;
            }
            const response = room.terminal.send(resource, amount, terminal.terminal.room.name);
            if (response !== OK) {
                console.log(response, amount, resource);
            }
            return;
        });
    }
    static unloadAbandoningRooms(terminals) {
        ABANDONING_ROOMS.forEach(roomName => {
            const room = Game.rooms[roomName];
            if (!room) {
                return;
            }
            if (!room.controller) {
                return;
            }
            if (!room.controller.my) {
                return;
            }
            if (!room.terminal) {
                return;
            }
            if (room.terminal.cooldown) {
                return;
            }
            let resource = [
                RESOURCE_POWER,
                RESOURCE_OPS,
                ...RESOURCE_MINERALS,
                ...RESOURCE_COMPOUNDS,
                ...RESOURCE_BOOSTS,
                ...RESOURCE_COMODITIES
            ].sort((a, b) => { var _a, _b; return (((_a = room.terminal) === null || _a === void 0 ? void 0 : _a.store[b]) || 0) - (((_b = room.terminal) === null || _b === void 0 ? void 0 : _b.store[a]) || 0); })[0];
            let amount = Math.min(10000, room.terminal.store[resource]);
            if (amount <= 0) {
                amount = Math.min(10000, room.terminal.store[RESOURCE_ENERGY]);
                if (amount <= 0) {
                    return;
                }
                resource = RESOURCE_ENERGY;
            }
            const terminal = terminals
                .filter(t => !ABANDONING_ROOMS.includes(t.terminal.room.name))
                .filter(t => t.terminal.cachedIsActive())
                .sort((a, b) => a.terminal.room.store[resource] - b.terminal.room.store[resource])[0];
            if (!terminal) {
                return;
            }
            const response = room.terminal.send(resource, amount, terminal.terminal.room.name);
            if (response !== OK) {
                console.log(response, amount, resource);
            }
            return;
        });
    }
    static createEnergyBuyOrders(terminals) {
        if (Game.market.credits < CONFIG$n.buyOrderEnergyMinCredits) {
            return;
        }
        terminals.forEach(terminalIntent => {
            if (terminalIntent.terminal.room.isGclFarm) {
                return;
            }
            if (terminalIntent.terminal.room.isAbandoning) {
                return;
            }
            if (!terminalIntent.terminal.room.storage) {
                return;
            }
            if (terminalIntent.terminal.room.store.energy > CONFIG$n.buyEnergyWhenUnder) {
                return;
            }
            const currentBuyOrders = Game.market.getAllOrders({
                type: ORDER_BUY,
                resourceType: RESOURCE_ENERGY
            });
            if (currentBuyOrders.filter(o => o.roomName === terminalIntent.terminal.room.name && o.remainingAmount > 0).length >
                0) {
                return;
            }
            const orderHistory = Game.market.getHistory(RESOURCE_ENERGY);
            let averagePrice = orderHistory.reduce((avgPrice, history, currentIndex) => {
                if (avgPrice === 0) {
                    return history.avgPrice;
                }
                const previousHistory = orderHistory[currentIndex - 1];
                if (!previousHistory) {
                    return avgPrice;
                }
                return ((history.avgPrice * history.volume + previousHistory.avgPrice * previousHistory.volume) /
                    (history.volume + previousHistory.volume));
            }, 0);
            if (!averagePrice) {
                return;
            }
            averagePrice = Math.min(averagePrice, currentBuyOrders.sort((a, b) => b.price - a.price)[0].price);
            const price = averagePrice * CONFIG$n.buyOrderPriceMultiplier;
            Game.market.createOrder({
                type: ORDER_BUY,
                resourceType: RESOURCE_ENERGY,
                price,
                totalAmount: CONFIG$n.buyEnergyOrderAmount,
                roomName: terminalIntent.terminal.room.name
            });
            this.printCreateBuyOrderMessage(terminalIntent.terminal.room.name, CONFIG$n.buyEnergyOrderAmount, price, RESOURCE_ENERGY);
        });
    }
    static createNewbieUpgradeBuyOrders(terminals) {
        if (Game.market.credits < 5000000) {
            return;
        }
        terminals.forEach(terminalIntent => {
            [BOOST_ALIAS.UPGRADE_3, BOOST_ALIAS.UPGRADE_2, BOOST_ALIAS.UPGRADE_1].forEach(boost => {
                if (terminalIntent.terminal.room.level >= 8) {
                    return;
                }
                if (terminalIntent.terminal.room.isGclFarm) {
                    return;
                }
                if (terminalIntent.terminal.room.isAbandoning) {
                    return;
                }
                if (!terminalIntent.terminal.room.storage) {
                    return;
                }
                if (terminalIntent.terminal.room.store[boost] > 3000) {
                    return;
                }
                const currentBuyOrders = Game.market.getAllOrders({
                    type: ORDER_BUY,
                    resourceType: boost
                });
                if (currentBuyOrders.filter(o => o.roomName === terminalIntent.terminal.room.name && o.remainingAmount > 0)
                    .length > 0) {
                    return;
                }
                const orderHistory = Game.market.getHistory(boost);
                const averagePrice = orderHistory.reduce((avgPrice, history, currentIndex) => {
                    if (avgPrice === 0) {
                        return history.avgPrice;
                    }
                    const previousHistory = orderHistory[currentIndex - 1];
                    if (!previousHistory) {
                        return avgPrice;
                    }
                    return ((history.avgPrice * history.volume + previousHistory.avgPrice * previousHistory.volume) /
                        (history.volume + previousHistory.volume));
                }, 0);
                if (!averagePrice) {
                    return;
                }
                // averagePrice = Math.min(averagePrice, currentBuyOrders.sort((a, b) => b.price - a.price)[0].price);
                const price = averagePrice;
                Game.market.createOrder({
                    type: ORDER_BUY,
                    resourceType: boost,
                    price,
                    totalAmount: 5000,
                    roomName: terminalIntent.terminal.room.name
                });
                this.printCreateBuyOrderMessage(terminalIntent.terminal.room.name, 5000, price, boost);
            });
        });
    }
    static createBuyOrders(terminals) {
        if (Game.market.credits < CONFIG$n.buyOrderBoostsMinCredits) {
            return;
        }
        terminals.forEach(terminalIntent => {
            if (terminalIntent.terminal.room.isGclFarm) {
                return;
            }
            if (terminalIntent.terminal.room.level < 8) {
                return;
            }
            if (terminalIntent.terminal.room.isAbandoning) {
                return;
            }
            if (!terminalIntent.terminal.room.storage) {
                return;
            }
            if (!terminalIntent.terminal.room.controller) {
                return;
            }
            if (terminalIntent.terminal.room.controller.level < 6) {
                return;
            }
            if (terminalIntent.terminal.room.level < 8 &&
                terminalIntent.terminal.room.labs.length !== CONTROLLER_STRUCTURES[STRUCTURE_LAB][8]) {
                return;
            }
            const types = terminalIntent.terminal.room.level === 8 ? CONFIG$n.buyBoosts.completeRoom : CONFIG$n.buyBoosts.developingRoom;
            for (const boost of types) {
                if (terminalIntent.terminal.room.store[boost] > CONFIG$n.buyBoosts.desiredMinStorageAmount) {
                    continue;
                }
                const currentBuyOrders = Game.market.getAllOrders({
                    type: ORDER_BUY,
                    resourceType: boost
                });
                if (currentBuyOrders.filter(o => o.roomName === terminalIntent.terminal.room.name && o.remainingAmount > 0)
                    .length > 0) {
                    continue;
                }
                const orderHistory = Game.market.getHistory(boost);
                const totalVolume = orderHistory.reduce((volume, history) => volume + history.volume, 0);
                if (totalVolume < 1000) {
                    continue;
                }
                const averagePrice = orderHistory.reduce((avgPrice, history, currentIndex) => {
                    if (avgPrice === 0) {
                        return history.avgPrice;
                    }
                    const previousHistory = orderHistory[currentIndex - 1];
                    if (!previousHistory) {
                        return avgPrice;
                    }
                    return ((history.avgPrice * history.volume + previousHistory.avgPrice * previousHistory.volume) /
                        (history.volume + previousHistory.volume));
                }, 0);
                if (!averagePrice) {
                    continue;
                }
                const price = averagePrice * CONFIG$n.buyOrderPriceMultiplier;
                const response = Game.market.createOrder({
                    type: ORDER_BUY,
                    resourceType: boost,
                    price,
                    totalAmount: CONFIG$n.buyBoosts.batchAmount,
                    roomName: terminalIntent.terminal.room.name
                });
                if (response !== OK) {
                    Log.object(terminalIntent.terminal, `Failed to create order for ${boost}`);
                }
            }
        });
    }
    static buy(terminals) {
        if (Game.market.credits < 600000000) {
            return;
        }
        terminals.forEach(terminalIntent => {
            if (terminalIntent.terminal.room.isAbandoning) {
                return;
            }
            if (!terminalIntent.terminal.room.storage) {
                return;
            }
            if (terminalIntent.terminal.room.storage.store.energy < CONFIG$n.buyBoosts.minStorageEnergy) {
                return;
            }
            if (terminalIntent.terminal.cooldown) {
                return;
            }
            if (!terminalIntent.terminal.room.controller) {
                return;
            }
            if (terminalIntent.terminal.room.controller.level < 6) {
                return;
            }
            if (terminalIntent.terminal.room.level < 8 && terminalIntent.terminal.room.labs.length === 0) {
                return;
            }
            const types = terminalIntent.terminal.room.level === 8 ? CONFIG$n.buyBoosts.completeRoom : CONFIG$n.buyBoosts.developingRoom;
            for (const boost of types) {
                if (terminalIntent.terminal.room.store[boost] > CONFIG$n.buyBoosts.instantBuyWhenStorageAmountLessThen) {
                    continue;
                }
                const sellOrders = Game.market.getAllOrders({
                    type: ORDER_SELL,
                    resourceType: boost
                });
                const order = sellOrders.sort((a, b) => a.price - b.price)[0];
                if (!order) {
                    continue;
                }
                if (order.price / Resources.resourceValues[boost] > 1.5) {
                    continue;
                }
                Game.market.deal(order.id, Math.min(CONFIG$n.buyBoosts.batchAmount, order.remainingAmount), terminalIntent.terminal.room.name);
                console.log("bought", boost, Math.min(CONFIG$n.buyBoosts.batchAmount, order.remainingAmount));
                return;
            }
        });
    }
    static buyV2(terminals, orderIntents) {
        terminals.forEach(terminalIntent => {
            var _a;
            if (terminalIntent.busy) {
                return;
            }
            if (terminalIntent.terminal.room.isAbandoning) {
                return;
            }
            if (!terminalIntent.terminal.room.storage) {
                return;
            }
            if (terminalIntent.terminal.room.storage.store.energy < 10000) {
                return;
            }
            if (terminalIntent.terminal.cooldown) {
                return;
            }
            if (!terminalIntent.terminal.room.controller) {
                return;
            }
            if (terminalIntent.terminal.room.controller.level < 8) {
                return;
            }
            for (const [r, config] of Object.entries(CONFIG_BALANCE)) {
                const resource = r;
                if (!config.terminalBuyMinCredits) {
                    continue;
                }
                if (Game.market.credits < config.terminalBuyMinCredits) {
                    continue;
                }
                if (!config.terminalBuyUnder) {
                    continue;
                }
                if (terminalIntent.terminal.room.store[resource] > config.terminalBuyUnder) {
                    continue;
                }
                const sellOrders = Game.market.getAllOrders({
                    type: ORDER_SELL,
                    resourceType: resource
                });
                const order = (_a = sellOrders
                    .filter(o => o.remainingAmount - (orderIntents[o.id] || 0) >= config.batchSizeMin)
                    .map(o => ({ order: o, actualPrice: this.orderEnergyTransactionCost(terminalIntent.terminal.room.name, o) }))
                    .sort((a, b) => a.actualPrice - b.actualPrice)[0]) === null || _a === void 0 ? void 0 : _a.order;
                if (!order) {
                    continue;
                }
                if (order.price / Resources.resourceValues[resource] > 1.5) {
                    continue;
                }
                const maxAmount = Math.min(order.remainingAmount - (orderIntents[order.id] || 0), config.terminalBuyUnder - terminalIntent.terminal.room.store[resource]);
                const amount = Math.min(10000, maxAmount);
                if (amount < config.batchSizeMin) {
                    continue;
                }
                Game.market.deal(order.id, amount, terminalIntent.terminal.room.name);
                orderIntents[order.id] = (orderIntents[order.id] || 0) + amount;
                terminalIntent.busy = true;
                return;
            }
        });
    }
    static orderEnergyTransactionCost(roomName, order) {
        const energyPrice = Resources.resourceValues[RESOURCE_ENERGY];
        if (!order.roomName) {
            return order.price;
        }
        return Game.market.calcTransactionCost(1, roomName, order.roomName) * energyPrice + order.price;
    }
    // private static sellPower(terminals: TerminalWithIntent[]): void {
    //   terminals.forEach(t => {
    //     if (t.terminal.store.power < Config.terminal.power.sellWhenMoreThan) {
    //       return;
    //     }
    //
    //     const buyOrders = Game.market.getAllOrders({ type: ORDER_BUY, resourceType: RESOURCE_POWER });
    //
    //     const order = buyOrders.sort((a, b) => b.price - a.price)[0];
    //
    //     if (!order) {
    //       return;
    //     }
    //
    //     const historyAvgPrice = getAverageMarketPrice(RESOURCE_POWER);
    //
    //     if (historyAvgPrice === 0) {
    //       return;
    //     }
    //
    //     if (historyAvgPrice * 0.9 > order.price) {
    //       return;
    //     }
    //
    //     const amount = Math.min(order.amount, t.terminal.store.power, Config.terminal.power.sellMax);
    //
    //     if (amount === 0) {
    //       return;
    //     }
    //
    //     Game.market.deal(order.id, amount, t.terminal.room.name);
    //   });
    // }
    static getAverageMarketPrice(resource) {
        const history = Game.market.getHistory(resource);
        return history.reduce((total, h) => total + h.avgPrice, 0) / history.length;
    }
    static sell(terminals) {
        const averageResources = Resources.myAverageResources();
        let dealCount = 0;
        for (const r in averageResources) {
            if (dealCount >= 10) {
                return;
            }
            const resource = r;
            // const average = averageResources[resource];
            const config = CONFIG_BALANCE[resource];
            // const maxInRoom = config.terminalSellInstantFrom + config.storageMaxAmount;
            // const overlowingAmount = average - maxInRoom;
            //
            // if (overlowingAmount < config.terminalSellInstantMinAmount) {
            //   continue;
            // }
            const overflowingTerminals = terminals
                .filter(t => t.terminal.store[RESOURCE_ENERGY] >= 10000 &&
                !t.terminal.room.isGclFarm &&
                t.terminal.store[resource] - config.terminalSellInstantFrom >= config.terminalSellInstantMinAmount &&
                (!t.terminal.room.storage || t.terminal.room.storage.store[resource] >= config.storageMaxAmount) &&
                t.terminal.cooldown === 0 &&
                !t.busy &&
                !t.intents.includes(resource))
                .sort((a, b) => a.terminal.store.getFreeCapacity() - b.terminal.store.getFreeCapacity());
            // .sort((a, b) => b.terminal.room.store[resource] - a.terminal.room.store[resource]);
            const buyOrders = Game.market
                .getAllOrders({
                type: ORDER_BUY,
                resourceType: resource
            })
                .sort((a, b) => b.price - a.price);
            const buyOrderIntents = {};
            overflowingTerminals.forEach(terminal => {
                var _a;
                if (dealCount >= 10) {
                    return;
                }
                if (terminal.terminal.room.storage &&
                    ((_a = terminal.terminal.room.storage) === null || _a === void 0 ? void 0 : _a.store[resource]) < config.storageMaxAmount) {
                    return;
                }
                const buyOrder = buyOrders.find(o => o.remainingAmount - (buyOrderIntents[o.id] || 0) >= config.terminalSellInstantMinAmount);
                if (!buyOrder) {
                    return;
                }
                if (buyOrder.price < Resources.resourceValues[resource] * 0.8) {
                    // console.log("price too low for", resource);
                    // console.log(
                    //   "scam buy prices for",
                    //   resource,
                    //   "expected min price",
                    //   Resources.resourceValues[resource] * 0.7,
                    //   "actual price",
                    //   buyOrder.price
                    // );
                    return;
                }
                const overflowingAmount = terminal.terminal.store[resource] - config.terminalSellInstantFrom;
                const finalAmount = Math.min(5000, overflowingAmount, terminal.terminal.store[resource], buyOrder.remainingAmount - (buyOrderIntents[buyOrder.id] || 0));
                if (finalAmount < config.terminalSellInstantMinAmount) {
                    return;
                }
                const response = Game.market.deal(buyOrder.id, finalAmount, terminal.terminal.room.name);
                if (response === OK) {
                    terminal.busy = true;
                    terminal.intents.push(resource);
                    buyOrderIntents[buyOrder.id] = (buyOrderIntents[buyOrder.id] || 0) + finalAmount;
                    dealCount++;
                }
                else {
                    console.log("sell failed", terminal.terminal.room.name, resource, finalAmount, response, buyOrder.id);
                }
            });
        }
    }
    static sellEnergy(terminals) {
        if (!General.farmingGcl()) {
            return;
        }
        // todo only when farming gcl
        const MIN_ENERGY = 220000;
        const MAX_CREDITS = 350000000;
        const MAX_DISTANCE = 20000;
        if (Game.market.credits > MAX_CREDITS) {
            return;
        }
        const buyOrders = Game.market
            .getAllOrders({
            type: ORDER_BUY,
            resourceType: RESOURCE_ENERGY
        })
            .filter(o => o.remainingAmount >= 10000)
            .sort((a, b) => b.price - a.price);
        if (buyOrders.length === 0) {
            return;
        }
        const topPrice = buyOrders[0].price;
        terminals
            .filter(t => !t.terminal.room.isGclFarm &&
            t.terminal.store[RESOURCE_ENERGY] >= 15000 &&
            t.terminal.room.storage &&
            t.terminal.room.storage.store[RESOURCE_ENERGY] >= MIN_ENERGY &&
            t.terminal.cooldown === 0 &&
            !t.busy &&
            !t.intents.includes(RESOURCE_ENERGY))
            .sort((a, b) => b.terminal.room.store[RESOURCE_ENERGY] - a.terminal.room.store[RESOURCE_ENERGY])
            .forEach(terminal => {
            const bestDealInRange = buyOrders.find(o => o.roomName && Game.map.getRoomLinearDistance(terminal.terminal.room.name, o.roomName) < MAX_DISTANCE);
            if (!bestDealInRange) {
                return;
            }
            if (bestDealInRange.price < topPrice * 0.9) {
                return;
            }
            Game.market.deal(bestDealInRange.id, 10000, terminal.terminal.room.name);
            terminal.busy = true;
            terminal.intents.push(RESOURCE_ENERGY);
        });
    }
    static getMyTerminals() {
        const terminals = [];
        Object.values(Game.rooms).forEach(room => {
            if (!room.terminal) {
                return;
            }
            if (!room.terminal.my) {
                return;
            }
            if (!room.terminal.cachedIsActive()) {
                return;
            }
            terminals.push(room.terminal);
        });
        return terminals;
    }
    static balance(terminals) {
        if (terminals.length <= 1) {
            return;
        }
        const averageResources = Resources.myAverageResources();
        for (const r in averageResources) {
            const resource = r;
            // const average = averageResources[resource];
            const config = CONFIG_BALANCE[resource];
            const terminalIntents = terminals
                .filter(t => !t.busy)
                .filter(t => !t.intents.includes(resource))
                .filter(t => !ABANDONING_ROOMS.includes(t.terminal.room.name))
                .filter(t => !t.terminal.room.isGclFarm)
                .sort((a, b) => a.terminal.room.store[resource] - b.terminal.room.store[resource]);
            for (let i = 0; i < Math.floor((terminalIntents.length - 1) / 2); i++) {
                const lowest = terminalIntents[i];
                const highest = terminalIntents[terminalIntents.length - 1 - i];
                if (!highest) {
                    continue;
                }
                if (highest.terminal.store.energy < 10000) {
                    continue;
                }
                if (!lowest) {
                    continue;
                }
                if (highest.terminal.id === lowest.terminal.id) {
                    continue;
                }
                if (lowest.terminal.store.getFreeCapacity() - lowest.incomingAmount < 10000) {
                    continue;
                }
                if (config.terminalMaxAmount && lowest.terminal.store[resource] > config.terminalMaxAmount) {
                    continue;
                }
                if (lowest.terminal.room.level < 8) {
                    if (!config.terminalBalanceMinRoomLevel || lowest.terminal.room.level < config.terminalBalanceMinRoomLevel) {
                        continue;
                    }
                }
                const amountToSend = Math.min(5000, (highest.terminal.room.store[resource] - lowest.terminal.room.store[resource]) / 2, highest.terminal.store[resource]);
                if (amountToSend < config.terminalBalanceMin) {
                    continue;
                }
                const response = highest.terminal.send(resource, amountToSend, lowest.terminal.room.name);
                if (response === 0) {
                    highest.busy = true;
                    lowest.intents.push(resource);
                    highest.intents.push(resource);
                    highest.incomingAmount -= amountToSend;
                    lowest.incomingAmount += amountToSend;
                }
                else {
                    console.log("balance failed", lowest.terminal.room.name, highest.terminal.room.name, resource, amountToSend, response);
                }
            }
        }
    }
    static balanceGclFarms(terminals) {
        if (terminals.length <= 1) {
            return;
        }
        const glcFarmTerminals = terminals
            .filter(t => !t.busy)
            .filter(t => !t.intents.includes(RESOURCE_ENERGY))
            .filter(t => !ABANDONING_ROOMS.includes(t.terminal.room.name))
            .filter(t => t.terminal.room.isGclFarm)
            .filter(t => t.terminal.store.getFreeCapacity(RESOURCE_ENERGY) > 5000)
            .sort((a, b) => a.terminal.room.store.energy - b.terminal.room.store.energy);
        if (glcFarmTerminals.length === 0) {
            return;
        }
        const supplyTerminals = terminals
            .filter(t => !t.busy)
            .filter(t => !t.intents.includes(RESOURCE_ENERGY))
            .filter(t => !ABANDONING_ROOMS.includes(t.terminal.room.name))
            .filter(t => !t.terminal.room.isGclFarm)
            .filter(t => t.terminal.room.store.energy > 130000)
            .sort((a, b) => b.terminal.room.store.energy - a.terminal.room.store.energy);
        if (supplyTerminals.length === 0) {
            return;
        }
        for (let i = 0; i < Math.min(glcFarmTerminals.length, supplyTerminals.length); i++) {
            const gclFarmTerminal = glcFarmTerminals[i];
            if (!gclFarmTerminal) {
                continue;
            }
            const supplyTerminal = supplyTerminals[i];
            if (!supplyTerminal) {
                continue;
            }
            if (supplyTerminal.terminal.id === gclFarmTerminal.terminal.id) {
                continue;
            }
            const response = supplyTerminal.terminal.send(RESOURCE_ENERGY, 5000, gclFarmTerminal.terminal.room.name);
            if (response === 0) {
                supplyTerminal.busy = true;
                gclFarmTerminal.busy = true;
                gclFarmTerminal.intents.push(RESOURCE_ENERGY);
                supplyTerminal.intents.push(RESOURCE_ENERGY);
            }
            else {
                console.log("balance gcl farm failed", gclFarmTerminal.terminal.room.name, supplyTerminal.terminal.room.name, RESOURCE_ENERGY, 5000, response);
            }
        }
    }
    static printCreateBuyOrderMessage(fromRoomName, amount, orderPrice, resource) {
        console.log(`<span style="color: #07ce00;">Terminal:</span> Buy order created <strong>${amount}</strong> <strong>${resource}</strong> for ${orderPrice} in ${Helpers.roomLink(fromRoomName)}`);
    }
}

class TowerStructureWorker {
    static handle() {
        Rooms.myRooms.forEach(room => {
            this.handleRoom(room);
        });
    }
    static handleRoom(room) {
        const towers = room
            .find(FIND_MY_STRUCTURES)
            .filter(structure => structure.structureType === STRUCTURE_TOWER);
        if (towers.length === 0) {
            return;
        }
        this.attackInvaders(room, towers) ||
            this.repairTowers(room, towers) ||
            this.healUnits(room, towers) ||
            this.attackHostiles(room, towers);
    }
    static repairTowers(room, towers) {
        const t = towers.filter(s => s.hitsMax - s.hits > 500).sort((a, b) => a.hits - b.hits)[0];
        if (!t) {
            return false;
        }
        towers.forEach(tower => tower.repair(t));
        return true;
    }
    static healUnits(room, towers) {
        if (!room.center) {
            return false;
        }
        const wounedCreep = room.center.findClosestByRange(FIND_MY_POWER_CREEPS, {
            filter: creep => creep.hitsMax - creep.hits >= 100
        }) ||
            room.center.findClosestByRange(FIND_MY_CREEPS, {
                filter: creep => creep.hitsMax - creep.hits >= 100
            });
        if (!wounedCreep) {
            return false;
        }
        towers.forEach(tower => tower.heal(wounedCreep));
        return true;
    }
    static attackInvaders(room, towers) {
        if (!room.center) {
            return false;
        }
        const hostile = room.center.findClosestByRange(FIND_HOSTILE_CREEPS, { filter: c => c.isInvader() });
        if (!hostile) {
            return false;
        }
        towers.forEach(tower => tower.attack(hostile));
        return true;
    }
    static attackHostiles(room, towers) {
        var _a;
        room.find(FIND_HOSTILE_CREEPS).forEach(c => {
            room.visual.text(`${c.realDamageTaken(c.expectedDamageTakenFromMe) - c.healPower}`, c.pos);
        });
        const hostile = room
            .find(FIND_HOSTILE_CREEPS)
            .filter(c => c.hits !== c.hitsMax || !c.pos.isRoomEdge || c.realDamageTaken(c.expectedDamageTakenFromMe) > c.hits)
            .sort((a, b) => {
            const scoreA = a.realDamageTaken(a.expectedDamageTakenFromMe) - a.healPower;
            const scoreB = a.realDamageTaken(b.expectedDamageTakenFromMe) - a.healPower;
            return scoreB - scoreA;
        })[0];
        if (!((_a = room.controller) === null || _a === void 0 ? void 0 : _a.safeMode)) {
            if (!hostile) {
                return false;
            }
            if (hostile.realDamageTaken(hostile.expectedDamageTakenFromMe) - hostile.healPower <= 0) {
                return false;
            }
        }
        towers.forEach(tower => tower.attack(hostile));
        return true;
    }
}

const CONFIG$m = Config.AttackerDuo;
class AttackerDuo {
    static handle() {
        Duos.duosByName(CONFIG$m.duoName).forEach(duo => {
            this.handleDuo(duo);
        });
        General.interval(5, () => TickAction.add(() => this.flagSpawner()));
    }
    static handleDuo(duo) {
        var _a;
        switch (duo.memory.stage) {
            case DuoGroupStage.SPAWNING: {
                duo.handleSpawning();
                break;
            }
            case DuoGroupStage.BOOSTING: {
                duo.handleBoosting();
                break;
            }
            case DuoGroupStage.WORKING: {
                if (!duo.attacker || !duo.healer) {
                    console.log("missing one of the fucks, so retreating");
                    duo.memory.stage = DuoGroupStage.RETREATING;
                    return;
                }
                if (duo.targetFlag && duo.targetFlag.room && ((_a = duo.targetFlag.room.controller) === null || _a === void 0 ? void 0 : _a.safeMode)) {
                    duo.memory.stage = DuoGroupStage.RETREATING;
                    return;
                }
                this.handleAttacker(duo, duo.attacker);
                this.handleHealer(duo.healer);
                this.groupUp(duo, duo.attacker, duo.healer) ||
                    this.waitFatigue(duo.attacker, duo.healer) ||
                    this.moveToHostilePowerCreeps(duo.attacker, duo.healer) ||
                    this.moveToEnemies(duo, duo.attacker, duo.healer) ||
                    this.moveToFlagRoom(duo, duo.attacker, duo.healer) ||
                    this.moveToEnemies(duo, duo.attacker, duo.healer) ||
                    this.moveToHostiles(duo, duo.attacker, duo.healer) ||
                    this.moveToFlagStructure(duo, duo.attacker, duo.healer) ||
                    // this.moveToNpc(duo, duo.attacker, duo.healer) ||
                    this.moveToLowestStructure(duo, duo.attacker, duo.healer) ||
                    this.moveToLowestDefence(duo, duo.attacker, duo.healer) ||
                    this.moveToFlag(duo, duo.attacker, duo.healer);
                break;
            }
            case DuoGroupStage.RETREATING: {
                if (duo.attacker) {
                    this.handleAttacker(duo, duo.attacker);
                }
                if (duo.healer) {
                    this.handleHealer(duo.healer);
                }
                duo.handleRetreating();
                break;
            }
        }
    }
    static closestHostile(creep, targetRoomName) {
        if (creep.room.name !== targetRoomName) {
            return (creep.pos
                .findInRange(FIND_HOSTILE_CREEPS, 2, {
                filter: c => !c.isFriendly && !c.isUnderRampart && c.healPower
            })
                .sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0] ||
                creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
                    filter: c => !c.isFriendly && !c.isUnderRampart
                }));
        }
        return (creep.pos
            .findInRange(FIND_HOSTILE_CREEPS, 2, {
            filter: c => !c.isUnderRampart && c.healPower
        })
            .sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0] ||
            creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
                filter: c => !c.isUnderRampart // && !c.isNPC // && (c.attackPower || c.rangedAttackPower || c.healPower)
            }));
    }
    static moveToHostilePowerCreeps(attacker, healer) {
        if (attacker.fatigue) {
            return false;
        }
        if (healer.fatigue) {
            return false;
        }
        const enemy = attacker.pos.findClosestByPath(FIND_HOSTILE_POWER_CREEPS, {
            filter: c => !c.isUnderRampart && !c.pos.isRoomEdge
        });
        if (!enemy) {
            return false;
        }
        if (enemy.pos.isRoomEdge) {
            return false;
        }
        const distance = attacker.pos.getRangeTo(enemy);
        if (distance === 1) {
            attacker.moveTo(enemy);
            healer === null || healer === void 0 ? void 0 : healer.moveTo(attacker);
        }
        else {
            attacker.travel(enemy, { freshPath: true, ignoreCreeps: false });
            healer === null || healer === void 0 ? void 0 : healer.moveTo(attacker);
        }
        return true;
    }
    static moveToEnemies(duo, attacker, healer) {
        if (attacker.fatigue) {
            return false;
        }
        if (healer.fatigue) {
            return false;
        }
        const enemy = attacker.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
            filter: c => !c.isUnderRampart &&
                !c.isNPC &&
                // (c.healPower || c.attackPower || c.rangedAttackPower) &&
                c.isEnemy &&
                !c.pos.isRoomEdge
        });
        if (!enemy) {
            return false;
        }
        if (enemy.isOnRoomEdge) {
            return false;
        }
        const distance = attacker.pos.getRangeTo(enemy);
        if (distance === 1) {
            attacker.moveTo(enemy);
            healer === null || healer === void 0 ? void 0 : healer.moveTo(attacker);
        }
        else {
            attacker.travel(enemy, { freshPath: true, ignoreCreeps: false });
            healer === null || healer === void 0 ? void 0 : healer.moveTo(attacker);
        }
        return true;
    }
    static moveToHostiles(duo, attacker, healer) {
        if (attacker.fatigue) {
            return false;
        }
        if (healer.fatigue) {
            return false;
        }
        const hostile = this.closestHostile(attacker, duo.memory.targetRoom);
        if (!hostile) {
            return false;
        }
        if (hostile.isOnRoomEdge) {
            return false;
        }
        const distance = attacker.pos.getRangeTo(hostile);
        if (distance === 1) {
            attacker.moveTo(hostile);
            healer === null || healer === void 0 ? void 0 : healer.moveTo(attacker);
        }
        else {
            attacker.travel(hostile, { ignoreCreeps: false, freshPath: true });
            healer === null || healer === void 0 ? void 0 : healer.moveTo(attacker);
        }
        return true;
    }
    static moveToNpc(duo, attacker, healer) {
        if (attacker.fatigue) {
            return false;
        }
        if (healer === null || healer === void 0 ? void 0 : healer.fatigue) {
            return false;
        }
        const hostile = attacker.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
            filter: c => !c.isUnderRampart && c.isNPC
        });
        if (!hostile) {
            return false;
        }
        attacker.travel(hostile, { freshPath: true, ignoreCreeps: false });
        healer === null || healer === void 0 ? void 0 : healer.moveTo(attacker);
        return true;
    }
    static waitFatigue(attacker, healer) {
        return attacker.fatigue !== 0 || healer.fatigue !== 0;
    }
    static moveToFlag(duo, attacker, healer) {
        if (!duo.targetFlag) {
            return false;
        }
        const distance = attacker.pos.getRangeTo(duo.targetFlag);
        if (distance > 1) {
            if (attacker.pos.isPosReachable(duo.targetFlag.pos)) {
                attacker.travel(duo.targetFlag, { ignoreCreeps: false, freshPath: true });
                healer.moveTo(attacker);
            }
            else {
                return false;
            }
        }
        return true;
    }
    static moveToFlagStructure(duo, attacker, healer) {
        if (!duo.targetFlag) {
            return false;
        }
        if (!duo.targetFlag.room) {
            return false;
        }
        const structure = duo.targetFlag.pos.lookFor(LOOK_STRUCTURES)[0];
        if (!structure) {
            return false;
        }
        const distance = attacker.pos.getRangeTo(structure);
        if (distance > 1) {
            if (attacker.pos.isPosReachable(duo.targetFlag.pos)) {
                attacker.travel(structure, { ignoreCreeps: false, freshPath: true });
                healer.moveTo(attacker);
            }
            else {
                return false;
            }
        }
        return true;
    }
    static moveToLowestStructure(duo, attacker, healer) {
        var _a, _b;
        if (attacker.room.my) {
            return false;
        }
        if (((_b = (_a = attacker.room.controller) === null || _a === void 0 ? void 0 : _a.reservation) === null || _b === void 0 ? void 0 : _b.username) === USERNAME.ME) {
            return false;
        }
        const defence = attacker.room
            .find(FIND_HOSTILE_STRUCTURES, { filter: s => s.structureType !== STRUCTURE_RAMPART && s.hits > 0 })
            .sort((a, b) => attacker.pos.getRangeTo(a) - attacker.pos.getRangeTo(b))
            .find(s => attacker.pos.isPosReachable(s.pos));
        if (!defence) {
            return false;
        }
        const distance = attacker.pos.getRangeTo(defence);
        if (distance > 1) {
            attacker.travel(defence, { ignoreCreeps: false, freshPath: true });
            healer.moveTo(attacker);
        }
        return true;
    }
    static moveToLowestDefence(duo, attacker, healer) {
        var _a, _b;
        if (attacker.room.my) {
            return false;
        }
        if (((_b = (_a = attacker.room.controller) === null || _a === void 0 ? void 0 : _a.reservation) === null || _b === void 0 ? void 0 : _b.username) === USERNAME.ME) {
            return false;
        }
        const defence = attacker.room
            .find(FIND_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_WALL || s.structureType === STRUCTURE_RAMPART
        })
            .sort((a, b) => a.hits - b.hits)
            .find(s => attacker.pos.isPosReachable(s.pos));
        if (!defence) {
            return false;
        }
        const distance = attacker.pos.getRangeTo(defence);
        if (distance > 1) {
            attacker.travel(defence, { ignoreCreeps: false, freshPath: true });
            healer.moveTo(attacker);
        }
        return true;
    }
    static groupUp(duo, attacker, healer) {
        const distance = attacker.wpos.getRangeTo(healer.wpos);
        if (distance <= 1) {
            return false;
        }
        if (attacker.pos.isRoomEdge && distance <= 2) {
            return false;
        }
        if (healer.pos.isRoomEdge && distance <= 2) {
            return false;
        }
        Log.object(attacker, distance);
        healer.travel(attacker, { ignoreCreeps: false, freshPath: true });
        return true;
    }
    static moveToFlagRoom(duo, attacker, healer) {
        if (!duo.targetFlag) {
            return false;
        }
        if (attacker.room.name === duo.targetFlag.pos.roomName) {
            return false;
        }
        attacker.moveToSiegeFlagRoom(duo.targetFlag);
        // attacker.travelToRoom(duo.targetFlag.pos.roomName);
        healer.moveTo(attacker);
        return true;
    }
    static handleHealer(creep) {
        creep.rangedBestAttack();
        if (!creep.healPower) {
            return;
        }
        creep.healMele() || creep.prehealMele();
    }
    static handleAttacker(duo, creep) {
        var _a;
        creep.rangedBestAttack();
        creep.bestAttack((_a = duo.targetFlag) === null || _a === void 0 ? void 0 : _a.pos);
        return;
    }
    static flagSpawner() {
        Flags.flags(FlagType.attackerDuoTier0).forEach(flag => {
            const targetRoomName = flag.pos.roomName;
            const roomModel = Rooms.model(targetRoomName);
            if (roomModel.isInSafeMode) {
                Log.room(flag.pos.roomName, "attacker spawner", "safe mode");
                return;
            }
            const spawnRoom = Geo.closestHomeRoomByRange(targetRoomName, {
                minLevel: 8,
                maxDistance: MAX_EXPANSION_RANGE,
                room: r => !r.isSpawningQuad && !r.isSpawningDuo
            });
            if (!spawnRoom) {
                Log.room(flag.pos.roomName, "attacker spawner", "no spawn room");
                return;
            }
            const distance = Geo.findRouteCached(spawnRoom.name, targetRoomName).length;
            const activeDuos = Duos.duos.filter(duo => duo.memory.name === CONFIG$m.duoName &&
                duo.memory.targetFlag === flag.name &&
                duo.memory.ticksTo > 200 + 50 * distance);
            if (activeDuos.length > 0) {
                return;
            }
            spawnRoom._isSpawningDuo = undefined;
            const duoId = Duos.create({
                homeRoom: spawnRoom.name,
                name: CONFIG$m.duoName,
                targetFlag: flag.name,
                targetRoom: flag.pos.roomName
            });
            Spawns.addToQue(spawnRoom, Object.assign(Object.assign({}, this.attackerTier1()), { priority: 0 /* Highest */, role: CONFIG$m.roleNameAttacker, memory: {
                    duoId,
                    duoRole: "attacker",
                    duoAttacker: true
                } }));
            Spawns.addToQue(spawnRoom, Object.assign(Object.assign({}, this.healerTier1()), { priority: 0 /* Highest */, role: CONFIG$m.roleNameHealer, memory: {
                    duoId,
                    duoRole: "healer",
                    duoHealer: true
                } }));
            spawnRoom.mem.increasedSpawnUntil = Game.time + 1500;
        });
    }
    static attackerTier4() {
        return {
            body: new BodyParts().add(TOUGH, 1).add(ATTACK, 24).add(MOVE, 25).get(),
            boosts: [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]
        };
    }
    static attackerTier3() {
        return {
            body: new BodyParts().add(TOUGH, 3).add(MOVE, 17).add(ATTACK, 30).get(),
            boosts: [RESOURCE_CATALYZED_GHODIUM_ALKALIDE, RESOURCE_ZYNTHIUM_OXIDE, RESOURCE_UTRIUM_HYDRIDE]
        };
    }
    static attackerTierAttack1() {
        return {
            body: new BodyParts().add(TOUGH, 3).add(MOVE, 17).add(ATTACK, 30).get(),
            boosts: [RESOURCE_CATALYZED_GHODIUM_ALKALIDE, RESOURCE_ZYNTHIUM_OXIDE, RESOURCE_UTRIUM_ACID]
        };
    }
    static attackerTier2() {
        return {
            body: new BodyParts().add(TOUGH, 7).add(MOVE, 13).add(ATTACK, 30).get(),
            boosts: [RESOURCE_CATALYZED_GHODIUM_ALKALIDE, RESOURCE_ZYNTHIUM_ALKALIDE, RESOURCE_UTRIUM_ACID]
        };
    }
    static attackerTier1Defensive() {
        return {
            body: new BodyParts().add(TOUGH, 20).add(MOVE, 10).add(ATTACK, 20).get(),
            boosts: [
                RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
                RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
                RESOURCE_CATALYZED_UTRIUM_ACID
            ]
        };
    }
    static attackerTier1Offensive() {
        return {
            body: new BodyParts().add(TOUGH, 5).add(MOVE, 10).add(ATTACK, 35).get(),
            boosts: [
                RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
                RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
                RESOURCE_CATALYZED_UTRIUM_ACID
            ]
        };
    }
    static attackerTier1() {
        return {
            body: new BodyParts().tough(9).rangedAttack().move(10).attack(30).get(),
            boosts: [
                RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
                RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
                RESOURCE_CATALYZED_UTRIUM_ACID,
                BOOST_ALIAS.RANGED_ATTACK_3
            ]
        };
    }
    static healerTier4() {
        return {
            body: new BodyParts().add(TOUGH, 1).add(HEAL, 24).add(MOVE, 25).get(),
            boosts: [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]
        };
    }
    static healerTier3() {
        return {
            body: new BodyParts().add(TOUGH, 3).add(HEAL, 30).add(MOVE, 17).get(),
            boosts: [RESOURCE_CATALYZED_GHODIUM_ALKALIDE, RESOURCE_LEMERGIUM_OXIDE, RESOURCE_ZYNTHIUM_OXIDE]
        };
    }
    static healerTier2() {
        return {
            body: new BodyParts().add(TOUGH, 5).add(HEAL, 32).add(MOVE, 13).get(),
            boosts: [RESOURCE_CATALYZED_GHODIUM_ALKALIDE, RESOURCE_LEMERGIUM_ALKALIDE, RESOURCE_ZYNTHIUM_ALKALIDE]
        };
    }
    static healerTier1() {
        return {
            body: new BodyParts().add(TOUGH, 10).add(MOVE, 8).add(HEAL, 30).add(MOVE, 2).get(),
            boosts: [
                RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
                RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
                RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE
            ]
        };
    }
    static attackerTier0() {
        return {
            body: BodyParts.new().attack(3).move(25).attack(22)
        };
    }
    static healerTier0() {
        return {
            body: BodyParts.new().heal(3).move(25).heal(22)
        };
    }
}
__decorate([
    Profiler.subprofile("duo")
], AttackerDuo, "handleDuo", null);
__decorate([
    Profiler.subprofile("spawn")
], AttackerDuo, "flagSpawner", null);

class CleanupMemory {
    static handle() {
        General.random(1 / 100, () => this.cleanupCreeps());
        General.random(1 / 100, () => this.cleanupFlags());
        General.random(1 / 100, () => this.cleanUpExpiredValues());
    }
    static cleanUpExpiredValues() {
        Rooms.memoryObjectRoomValues.forEach(room => {
            if (room.increasedSpawnUntil && room.increasedSpawnUntil < Game.time) {
                room.increasedSpawnUntil = undefined;
            }
        });
    }
    static cleanupFlags() {
        if (!Memory.flags) {
            Memory.flags = {};
        }
        Object.keys(Memory.flags).forEach(flagName => {
            if (!(flagName in Game.flags)) {
                delete Memory.flags[flagName];
            }
        });
    }
    static cleanupCreeps() {
        if (!Memory.creeps) {
            Memory.creeps = {};
        }
        Object.keys(Memory.creeps).forEach(creepName => {
            if (!(creepName in Game.creeps)) {
                delete Memory.creeps[creepName];
                delete Traveler.creepTravels[creepName];
            }
        });
    }
}

function roomNameToType(roomName) {
    const parsed = roomName.match(/\d+/g);
    if (!parsed) {
        console.log("failed to parse", roomName, "is not a room name");
        return RoomTypeEnum.STANDART;
    }
    const [EW, NS] = parsed;
    if (Number(EW) % 10 === 0 && Number(NS) % 10 === 0) {
        return RoomTypeEnum.CROSSROAD;
    }
    else if (Number(EW) % 10 === 0 || Number(NS) % 10 === 0) {
        return RoomTypeEnum.HIGHWAY;
    }
    else if (Number(EW) % 5 === 0 && Number(NS) % 5 === 0) {
        return RoomTypeEnum.CENTER;
    }
    else if (Math.abs(5 - (Number(EW) % 10)) <= 1 && Math.abs(5 - (Number(NS) % 10)) <= 1) {
        return RoomTypeEnum.SK;
    }
    else {
        return RoomTypeEnum.STANDART;
    }
}

class MemoryStrongholdHandler {
    static updateRoom(room) {
        const stronghold = Memory.strongholds[room.name];
        if (!stronghold && !room.invaderCore) {
            return;
        }
        this.deleteComplete(stronghold) || this.create(room, stronghold) || this.updateExisting(room);
    }
    static updateExisting(room) {
        if (!Memory.strongholds[room.name]) {
            return;
        }
        if (room.invaderCore) {
            Memory.strongholds[room.name].level = room.invaderCore.level;
        }
        Memory.strongholds[room.name].updatedAt = Game.time;
        Memory.strongholds[room.name].isSpawning = room.invaderCore ? this.isSpawning(room.invaderCore) : false;
        Memory.strongholds[room.name].endsAt = room.invaderCore ? this.endsAt(room.invaderCore) : undefined;
        Memory.strongholds[room.name].startsAt = room.invaderCore ? this.startsAt(room.invaderCore) : undefined;
        Memory.strongholds[room.name].isAlive = !!room.invaderCore;
        Memory.strongholds[room.name].lootableAmount = this.lootableAmount(room);
        Memory.strongholds[room.name].structureHits = this.structureHits(room);
    }
    static create(room, stronghold) {
        if (stronghold) {
            return false;
        }
        if (!room.invaderCore) {
            return false;
        }
        Memory.strongholds[room.name] = {
            attackerCount: 0,
            attackerCountMax: this.attackerCountMax(room.invaderCore.level),
            createdAt: Game.time,
            endsAt: this.endsAt(room.invaderCore),
            homeRooms: this.findHomeRooms(room, room.invaderCore.level).map(r => r.name),
            isSpawning: this.isSpawning(room.invaderCore),
            isAlive: true,
            level: room.invaderCore.level,
            lootableAmount: this.lootableAmount(room),
            pos: { x: room.invaderCore.pos.x, y: room.invaderCore.pos.y },
            startsAt: this.startsAt(room.invaderCore),
            structureHits: this.structureHits(room),
            targetRoom: room.name,
            updatedAt: Game.time
        };
        return true;
    }
    static lootableAmount(room) {
        const ruins = room.find(FIND_RUINS).filter(r => r.store.getUsedCapacity() > r.store.energy &&
            (r.structure.structureType === STRUCTURE_INVADER_CORE || r.structure.structureType === STRUCTURE_CONTAINER) &&
            r.pos.findInRange(FIND_HOSTILE_STRUCTURES, 1, {
                filter: s => s.structureType === STRUCTURE_RAMPART
            }).length < 8);
        return (ruins.reduce((total, ruin) => total + ruin.store.getUsedCapacity(), 0) +
            room
                .find(FIND_STRUCTURES)
                .filter(s => s.structureType === STRUCTURE_CONTAINER && s.ticksToDecay > 5000 && !s.pos.rampart)
                .reduce((total, s) => total + (s instanceof StructureContainer ? s.store.getUsedCapacity() : 0), 0));
    }
    static startsAt(invaderCore) {
        const effect = invaderCore.effects.find(e => e.effect === EFFECT_INVULNERABILITY);
        if (!effect) {
            return;
        }
        return effect.ticksRemaining + Game.time;
    }
    static isSpawning(invaderCore) {
        const invEffect = invaderCore.effects.find(e => e.effect === EFFECT_INVULNERABILITY);
        return !!invEffect;
    }
    static endsAt(invaderCore) {
        const collapseEffect = invaderCore.effects.find(e => e.effect === EFFECT_COLLAPSE_TIMER);
        if (!collapseEffect) {
            return;
        }
        return collapseEffect.ticksRemaining + Game.time;
    }
    static findHomeRooms(targetRoom, level) {
        if (level === 1) {
            return Geo.closestHomeRoomsByRange(targetRoom.name, 2, {
                maxDistance: 5,
                minLevel: 8,
                room: room => {
                    return (!room.wasRecentlyUnderAttack &&
                        room.store[BOOST_ALIAS.RANGED_ATTACK_3] >= 500 &&
                        room.store[BOOST_ALIAS.HEAL_3] >= 500);
                }
            });
        }
        if (level === 2) {
            return Geo.closestHomeRoomsByRange(targetRoom.name, 2, {
                maxDistance: 5,
                minLevel: 8,
                room: room => {
                    return (!room.wasRecentlyUnderAttack &&
                        room.store[BOOST_ALIAS.TOUGH_3] >= 500 &&
                        room.store[BOOST_ALIAS.HEAL_3] >= 500 &&
                        room.store[BOOST_ALIAS.RANGED_ATTACK_3] >= 700);
                }
            });
        }
        if (level === 3) {
            return Geo.closestHomeRoomsByRange(targetRoom.name, 2, {
                maxDistance: 5,
                minLevel: 8,
                room: room => {
                    return (!room.wasRecentlyUnderAttack &&
                        room.store[BOOST_ALIAS.RANGED_ATTACK_3] >= 700 &&
                        room.store[BOOST_ALIAS.HEAL_3] >= 500 &&
                        room.store[BOOST_ALIAS.TOUGH_3] >= 500 &&
                        room.store[BOOST_ALIAS.MOVE_3] >= 500);
                }
            });
        }
        if (level === 4) {
            const rooms = Geo.closestHomeRoomsByRange(targetRoom.name, 8, {
                maxDistance: 5,
                minLevel: 8,
                room: room => !room.wasRecentlyUnderAttack &&
                    room.store[BOOST_ALIAS.RANGED_ATTACK_3] >= 800 * 3 &&
                    room.store[BOOST_ALIAS.HEAL_3] >= 1300 * 3 &&
                    room.store[BOOST_ALIAS.TOUGH_3] >= 500 * 3 &&
                    room.store[BOOST_ALIAS.MOVE_3] >= 600 * 3
            });
            if (rooms.length < 2) {
                return [];
            }
            return rooms;
        }
        // if (level === 5) {
        //   const rooms = Geo.closestHomeRoomsByRange(targetRoom.name, 8, {
        //     maxDistance: 5,
        //     minLevel: 8,
        //     room: room =>
        //       !room.wasRecentlyUnderAttack &&
        //       room.store[BOOST_ALIAS.RANGED_ATTACK_3] >= 800 * 3 &&
        //       room.store[BOOST_ALIAS.HEAL_3] >= 1300 * 3 &&
        //       room.store[BOOST_ALIAS.TOUGH_3] >= 500 * 3 &&
        //       room.store[BOOST_ALIAS.MOVE_3] >= 600 * 3
        //   });
        //
        //   if (rooms.length < 3) {
        //     return [];
        //   }
        //
        //   return rooms;
        // }
        return [];
    }
    static structureHits(room) {
        return (room
            .find(FIND_HOSTILE_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_RAMPART ||
                s.structureType === STRUCTURE_TOWER ||
                s.structureType === STRUCTURE_INVADER_CORE
        })
            .reduce((total, s) => total + s.hits, 0) +
            room
                .find(FIND_STRUCTURES, {
                filter: s => s.structureType === STRUCTURE_CONTAINER && s.ticksToDecay && s.ticksToDecay > 5000
            })
                .reduce((total, s) => total + s.hits, 0));
    }
    static attackerCountMax(level) {
        if (level === 1) {
            return 2;
        }
        if (level === 2) {
            return 2;
        }
        if (level === 3) {
            return 3;
        }
        if (level === 4) {
            return 10;
        }
        // if (level === 5) {
        //   return 60;
        // }
        return 1;
    }
    static deleteComplete(stronghold) {
        if (!stronghold) {
            return false;
        }
        if (stronghold.isAlive) {
            return false;
        }
        if (stronghold.isSpawning) {
            return false;
        }
        if (stronghold.lootableAmount > 0) {
            return false;
        }
        if (stronghold.structureHits > 0) {
            return false;
        }
        console.log("deleting complete stronghold", stronghold.targetRoom);
        delete Memory.strongholds[stronghold.targetRoom];
        return true;
    }
    static deleteEnded() {
        Object.keys(Memory.strongholds).forEach(roomName => {
            if ((Memory.strongholds[roomName].endsAt || Number.POSITIVE_INFINITY) > Game.time + 50) {
                return;
            }
            console.log("deleting ended stronghold", roomName);
            delete Memory.strongholds[roomName];
        });
    }
    static deleteStuck() {
        Object.keys(Memory.strongholds).forEach(roomName => {
            if (Memory.strongholds[roomName].createdAt > Game.time - 300000) {
                return;
            }
            console.log("deleting stuck stronghold", roomName);
            delete Memory.strongholds[roomName];
        });
    }
}

const PowerBankConfig = {
    maxRange: 10,
    beginingMinDecay: 4000,
    minPowerInPowerBank: 3000,
    flagTtl: 5000,
    boosted: false,
    role: {
        powerBankHauler: {
            name: "powerBankHauler",
            priority: 3 /* Medium */
        },
        powerBankHealer: {
            name: "powerBankHealer",
            priority: 1 /* Higher */
        },
        powerBankMiner: {
            name: "powerBankMiner",
            priority: 2 /* High */
        }
    },
    duoRole: "powerBank"
};

class MemoryPowerBankHandler {
    static updateRoom(room) {
        const powerBankMemory = Memory.powerBanks[room.name];
        if (!powerBankMemory && !room.powerBank) {
            return;
        }
        this.create(room) || this.updateExisting(room) || this.deleteComplete(room);
    }
    static updateExisting(room) {
        var _a;
        if (!Memory.powerBanks[room.name]) {
            return;
        }
        Memory.powerBanks[room.name].hits = ((_a = room.powerBank) === null || _a === void 0 ? void 0 : _a.hits) || 0;
        Memory.powerBanks[room.name].isAlive = !!room.powerBank;
        Memory.powerBanks[room.name].droppedPower = this.droppedPower(room);
        return;
    }
    static create(room) {
        if (Memory.powerBanks[room.name]) {
            return false;
        }
        if (!room.powerBank) {
            return false;
        }
        const hasCompetitors = this.hasCompetitors(room);
        const hasUntouchables = this.hasUntouchables(room);
        Memory.powerBanks[room.name] = {
            attackersCount: 0,
            createdAt: Game.time,
            endsAt: room.powerBank.ticksToDecay + Game.time,
            hits: room.powerBank.hits,
            homeRooms: this.findHomeRooms(room, room.powerBank, hasCompetitors, hasUntouchables).map(r => r.name),
            openSlotCount: room.powerBank.pos.openSpots.length,
            power: room.powerBank.power,
            targetRoom: room.name,
            hasCompetitors,
            hasAvoidingUsersNearby: hasUntouchables,
            isAlive: true,
            droppedPower: this.droppedPower(room)
        };
        return true;
    }
    static droppedPower(room) {
        return (room.find(FIND_RUINS).reduce((total, ruin) => total + ruin.store.power, 0) +
            room
                .find(FIND_DROPPED_RESOURCES, { filter: r => r.resourceType === RESOURCE_POWER })
                .reduce((total, r) => total + r.amount, 0));
    }
    static hasCompetitors(room) {
        return (Geo.findRoomsInRange(room.name, 5).filter(r => r.ownerUsername && POWER_BANK_COMPETITOR_USERNAMES.includes(r.ownerUsername)).length > 0);
    }
    static hasUntouchables(room) {
        return (Geo.findRoomsInRange(room.name, 5).filter(r => r.ownerUsername && POWER_BANK_AVOID_USERNAMES.includes(r.ownerUsername)).length > 0);
    }
    static findHomeRooms(room, powerBank, hasCompetitors, hasUntouchables) {
        if (hasUntouchables) {
            return [];
        }
        if (powerBank.power < PowerBankConfig.minPowerInPowerBank) {
            return [];
        }
        if (powerBank.ticksToDecay < PowerBankConfig.beginingMinDecay) {
            return [];
        }
        return Geo.closestHomeRoomsByRange(room.name, 3, {
            maxDistance: PowerBankConfig.maxRange,
            minLevel: 8,
            room: r => {
                return (!r.isGclFarm && !r.wasRecentlyUnderAttack // &&
                // r.mem.sectorName !== undefined &&
                // ALLOWED_SECTORS.includes(r.mem.sectorName) &&
                // (!hasCompetitors ||
                //   (r.store[BOOST_TOUGH_TIER_2] > 3000 &&
                //     r.store[BOOST_TOUGH_TIER_1] > 3000 &&
                //     r.store[BOOST_ATTACK_TIER_2] > 3000 &&
                //     r.store[BOOST_ATTACK_TIER_1] > 3000 &&
                //     r.store[BOOST_HEAL_TIER_1] > 3000))
                );
            }
        });
    }
    static deleteComplete(room) {
        const mem = Memory.powerBanks[room.name];
        if (!mem) {
            return false;
        }
        if (mem.isAlive) {
            return false;
        }
        if (mem.droppedPower) {
            return false;
        }
        delete Memory.powerBanks[room.name];
        return true;
    }
    static deleteEnded() {
        Object.keys(Memory.powerBanks).forEach(roomName => {
            if (Memory.powerBanks[roomName].endsAt > Game.time) {
                return;
            }
            delete Memory.powerBanks[roomName];
        });
    }
}

function roomNameToSector(roomName) {
    return roomName.replace(/([WE].?)([0-9])([SN].?)([0-9])/g, `$15$35`);
}

class RoomEvents$1 {
    static ownerChanged(room, oldUsername, newUsername) {
        this.notifyAboutNewUserInRoom(room, newUsername);
        this.clearLayout(room);
        this.clearCenterDistances(room);
        this.clearSources(room);
        this.resetIsMine(room, oldUsername, newUsername);
    }
    static towersChanged(room, oldTowerCount, newTowerCount) {
        if (!newTowerCount) {
            this.resetRoutes(room);
        }
    }
    static resetRoutes(room) {
        Geo.resetRoutesContaining(room.name);
    }
    static resetIsMine(room, oldUsername, newUsername) {
        var _a;
        if (oldUsername !== USERNAME.ME && newUsername !== USERNAME.ME) {
            return;
        }
        room.mem.isMine = ((_a = room.controller) === null || _a === void 0 ? void 0 : _a.my) ? 1 : undefined;
    }
    static notifyAboutNewUserInRoom(room, newUsername) {
        if (newUsername && (ENEMIES.includes(newUsername) || FRIENDLIES.includes(newUsername))) {
            Game.notify(`New room owner detected '${newUsername}' in '${room.name}' level ${String(room.mem.controllerLevel)}`);
        }
    }
    static clearLayout(room) {
        room.mem.layout = undefined;
    }
    static clearCenterDistances(room) {
        room.mem.centerDistances = undefined;
    }
    static clearSources(room) {
        room.mem.sources = undefined;
    }
}

class MemoryRoom {
    static handle() {
        Object.values(Game.rooms).forEach(room => {
            Rooms.runVisibleCallbacks(room);
            if (room.mem.updatedAt > Game.time - 50) {
                return;
            }
            this.handleRoomV2(room);
        });
        General.interval(50, () => MemoryPowerBankHandler.deleteEnded());
        General.interval(50, () => {
            MemoryStrongholdHandler.deleteEnded();
            MemoryStrongholdHandler.deleteStuck();
        });
    }
    static handleRoomV2(room) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        room.mem.updatedAt = Game.time;
        room.mem.sectorName = this.getSectorNameV2(room); // remove
        room.mem.name = room.name;
        room.mem.type = this.getRoomTypeV2(room);
        room.mem.ownerUsername = this.ownerUsernameV2(room);
        room.mem.controllerLevel = ((_a = room.controller) === null || _a === void 0 ? void 0 : _a.level) || undefined;
        room.mem.reservationUsername = (_c = (_b = room.controller) === null || _b === void 0 ? void 0 : _b.reservation) === null || _c === void 0 ? void 0 : _c.username;
        room.mem.reservationEndsAt = ((_e = (_d = room.controller) === null || _d === void 0 ? void 0 : _d.reservation) === null || _e === void 0 ? void 0 : _e.ticksToEnd) ? Game.time + ((_g = (_f = room.controller) === null || _f === void 0 ? void 0 : _f.reservation) === null || _g === void 0 ? void 0 : _g.ticksToEnd)
            : undefined;
        room.mem.isMine = this.isMine(room);
        room.mem.signatureOwner = (_h = room.controller) === null || _h === void 0 ? void 0 : _h.signUsername;
        room.mem.towerCount = this.activeTowerCountV2(room);
        room.mem.hostileCreepCount = this.hostileCreepCount(room);
        room.mem.safeModeEndsAt = this.safeModeEndsAt(room);
        room.mem.safeModeCooldownEndsAt = this.safeModeCooldownEndsAt(room);
        room.mem.sourceCount = this.getSourceCountV2(room);
        room.mem.mineralType = this.getMineralTypeV2(room);
        room.mem.terrainWallsCount = this.terrainWallsCountV2(room);
        room.mem.terrainSwampsCount = this.terrainSwampsCountV2(room);
        room.mem.hostileRangedAttackPower = room.hostileRangedAttackPower || undefined;
        room.mem.hostileAttackPower = room.hostileAttackPower || undefined;
        room.mem.hostileHealPower = room.hostileHealPower || undefined;
        room.mem.npcRangedAttackPower = room.npcRangedAttackPower || undefined;
        room.mem.npcAttackPower = room.npcAttackPower || undefined;
        room.mem.npcHealPower = room.npcHealPower || undefined;
        room.mem.myRangedAttackPower = room.myRangedAttackPower || undefined;
        room.mem.myAttackPower = room.myAttackPower || undefined;
        room.mem.myHealPower = room.myHealPower || undefined;
        if (!room.mem.statusUpdatedAt || room.mem.statusUpdatedAt < Game.time - 10000) {
            room.mem.status = Game.map.getRoomStatus(room.name).status;
            room.mem.statusUpdatedAt = Game.time;
        }
        if (!room.mem.hitsUpdatedAt || room.mem.hitsUpdatedAt < Game.time - 1000) {
            const hits = this.getHits(room);
            room.mem.hitsDefenceBuildingCount = hits.defencesCount;
            room.mem.hitsDefenceBuildingAverageHits = hits.defencesAvgHits;
            room.mem.hitsUpdatedAt = Game.time;
        }
        if (!room.mem.resourcesUpdatedAt || room.mem.resourcesUpdatedAt > Game.time - 10000) {
            room.mem.resourcesCreditValue = this.getRoomCreditValue(room);
            room.mem.resourcesValuableHaulCount = this.getRoomValuableHaulCount(room);
            room.mem.resourcesUpdatedAt = Game.time;
        }
        this.updateInvaderCore(room);
        this.updatePowerBank(room);
    }
    static ownerUsernameV2(room) {
        var _a, _b;
        const newUsername = (_b = (_a = room.controller) === null || _a === void 0 ? void 0 : _a.owner) === null || _b === void 0 ? void 0 : _b.username;
        if (newUsername !== room.mem.ownerUsername) {
            RoomEvents$1.ownerChanged(room, room.mem.ownerUsername, newUsername);
        }
        return newUsername;
    }
    static getSectorNameV2(room) {
        if (room.mem.sectorName) {
            return room.mem.sectorName;
        }
        return roomNameToSector(room.name);
    }
    static getRoomCreditValue(room) {
        return (room
            .find(FIND_STRUCTURES)
            .filter(s => s.structureType === STRUCTURE_STORAGE ||
            s.structureType === STRUCTURE_TERMINAL ||
            s.structureType === STRUCTURE_FACTORY)
            .reduce((total, structure) => total + ("store" in structure ? Resources.storeValue(structure.store) : 0), 0) ||
            undefined);
    }
    static getRoomValuableHaulCount(room) {
        return (room
            .find(FIND_STRUCTURES)
            .filter(s => s.structureType === STRUCTURE_STORAGE ||
            s.structureType === STRUCTURE_TERMINAL ||
            s.structureType === STRUCTURE_FACTORY)
            .reduce((total, structure) => total + ("store" in structure ? Resources.storeValuableCount(structure.store) : 0), 0) || undefined);
    }
    static isMine(room) {
        var _a;
        return ((_a = room.controller) === null || _a === void 0 ? void 0 : _a.my) ? 1 : undefined;
    }
    static updatePowerBank(room) {
        if (room.mem.type !== RoomTypeEnum.HIGHWAY && room.mem.type !== RoomTypeEnum.CROSSROAD) {
            return;
        }
        MemoryPowerBankHandler.updateRoom(room);
    }
    static updateInvaderCore(room) {
        if (room.mem.type !== RoomTypeEnum.SK && room.mem.type !== RoomTypeEnum.CENTER) {
            return;
        }
        MemoryStrongholdHandler.updateRoom(room);
    }
    static getHits(room) {
        let defenceHits = 0;
        let defenceCount = 0;
        room.find(FIND_STRUCTURES).forEach(s => {
            if ((s.structureType === STRUCTURE_RAMPART && !s.my) || s.structureType === STRUCTURE_WALL) {
                defenceCount++;
                defenceHits += s.hits;
            }
        });
        return {
            defencesCount: defenceCount || undefined,
            defenceTotalHits: defenceHits || undefined,
            defencesAvgHits: defenceHits / defenceCount || undefined
        };
    }
    static getRoomTypeV2(room) {
        if (room.mem.type) {
            return room.mem.type;
        }
        return roomNameToType(room.name);
    }
    static terrainSwampsCountV2(room) {
        if (room.mem.terrainWallsCount !== undefined) {
            return room.mem.terrainWallsCount;
        }
        const roomTerrain = room.getTerrain();
        let count = 0;
        for (let x = 0; x <= 49; x++) {
            for (let y = 0; y <= 49; y++) {
                const terrain = roomTerrain.get(x, y);
                if (terrain === TERRAIN_MASK_SWAMP) {
                    count++;
                }
            }
        }
        return count;
    }
    static terrainWallsCountV2(room) {
        if (room.mem.terrainWallsCount !== undefined) {
            return room.mem.terrainWallsCount;
        }
        const roomTerrain = room.getTerrain();
        let count = 0;
        for (let x = 0; x <= 49; x++) {
            for (let y = 0; y <= 49; y++) {
                const terrain = roomTerrain.get(x, y);
                if (terrain === TERRAIN_MASK_WALL) {
                    count++;
                }
            }
        }
        return count;
    }
    static activeTowerCountV2(room) {
        var _a;
        if (room.mem.type !== RoomTypeEnum.STANDART && room.mem.type !== RoomTypeEnum.SK) {
            return undefined;
        }
        const towerCount = room.find(FIND_STRUCTURES).filter(s => s.structureType === STRUCTURE_TOWER).length;
        if (room.mem.type === RoomTypeEnum.STANDART) {
            const newCount = Math.min(towerCount, CONTROLLER_STRUCTURES[STRUCTURE_TOWER][room.level] || 0) || undefined;
            if (newCount !== room.mem.towerCount) {
                RoomEvents$1.towersChanged(room, room.mem.towerCount, newCount);
            }
            return newCount;
        }
        if (room.mem.type === RoomTypeEnum.SK) {
            const newCount = ((_a = room.invaderCore) === null || _a === void 0 ? void 0 : _a.level) ? towerCount : undefined;
            if (newCount !== room.mem.towerCount) {
                RoomEvents$1.towersChanged(room, room.mem.towerCount, newCount);
            }
            return newCount;
        }
        return undefined;
    }
    static hostileCreepCount(room) {
        return room.find(FIND_HOSTILE_CREEPS).length || undefined;
    }
    static getMineralTypeV2(room) {
        var _a;
        if (room.mem.type !== RoomTypeEnum.SK && room.mem.type !== RoomTypeEnum.STANDART) {
            return;
        }
        return room.mem.mineralType || ((_a = room.find(FIND_MINERALS)[0]) === null || _a === void 0 ? void 0 : _a.mineralType);
    }
    static getSourceCountV2(room) {
        if (room.mem.type !== RoomTypeEnum.STANDART) {
            return undefined;
        }
        return room.mem.sourceCount || room.find(FIND_SOURCES).length || undefined;
    }
    static safeModeEndsAt(room) {
        if (!room.controller) {
            return;
        }
        if (!room.controller.safeMode) {
            return;
        }
        return Game.time + room.controller.safeMode;
    }
    static safeModeCooldownEndsAt(room) {
        if (!room.controller) {
            return;
        }
        if (!room.controller.safeModeCooldown) {
            return;
        }
        return Game.time + room.controller.safeModeCooldown;
    }
}

class RoomHostilityMemory {
    static handle() {
        Object.values(Game.rooms).forEach(room => {
            this.updateRoom(room);
        });
        General.interval(500, () => {
            Rooms.memoryObjectRoomValues.forEach(room => {
                this.decay(room);
            });
        });
    }
    static decay(room) {
        this.decayDeaths(room);
        this.decayKills(room);
    }
    static decayDeaths(room) {
        if (!room.recentDeaths) {
            return;
        }
        if (room.recentDeaths <= 0.1) {
            room.recentDeaths = undefined;
        }
        else {
            room.recentDeaths *= 0.9;
        }
    }
    static decayKills(room) {
        if (!room.recentKills) {
            return;
        }
        if (room.recentKills <= 0.1) {
            room.recentKills = undefined;
        }
        else {
            room.recentKills *= 0.9;
        }
    }
    static updateRoom(room) {
        if (room.my)
            return;
        for (const event of room.getEventLog()) {
            if (event.event !== EVENT_OBJECT_DESTROYED) {
                continue;
            }
            if (event.data.type !== "creep") {
                continue;
            }
            room
                .find(FIND_TOMBSTONES, {
                filter: t => t.deathTime === Game.time - 1 &&
                    t.creep &&
                    t.creep.hitsMax > 100 &&
                    // t.creep.owner.username === NAME_ME &&
                    t.creep.ticksToLive &&
                    t.creep.ticksToLive > 1 // &&
                // t.creep.memory.role !== "remoteMineMiner"
            })
                .forEach(tombstone => {
                if (tombstone.creep.owner.username === USERNAME.ME) {
                    if (tombstone.creep.saying !== "🗑️") {
                        const points = tombstone.creep.hitsMax / 5000;
                        room.mem.recentDeaths = (room.mem.recentDeaths || 0) + points;
                        Log.room(room.name, "death points", points);
                    }
                }
                else if (![USERNAME.SOURCE_KEEPER, USERNAME.INVADER, USERNAME.SCREEPS].includes(tombstone.creep.owner.username)) {
                    room.mem.recentKills = (room.mem.recentKills || 0) + tombstone.creep.hitsMax / 5000;
                }
            });
        }
    }
}

const MIN_INPUT_RESOURCES_TO_START_NEW_REACTION = 2000;
const STOP_T3 = 35000;
const START_T3 = 30000;
const STOP_T2 = 12000;
const START_T2 = 11000;
const STOP_T1 = 12000;
const START_T1 = 11000;
const CONFIG$l = {
    [RESOURCE_CATALYZED_GHODIUM_ACID]: {
        output: RESOURCE_CATALYZED_GHODIUM_ACID,
        inputs: BOOST_REACTIONS[RESOURCE_CATALYZED_GHODIUM_ACID],
        stopWhenRoomAbove: STOP_T3,
        startWhenRoomUnder: START_T3
    },
    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: {
        output: RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
        inputs: BOOST_REACTIONS[RESOURCE_CATALYZED_KEANIUM_ALKALIDE],
        stopWhenRoomAbove: STOP_T3,
        startWhenRoomUnder: START_T3
    },
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: {
        output: RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
        inputs: BOOST_REACTIONS[RESOURCE_CATALYZED_UTRIUM_ALKALIDE],
        stopWhenRoomAbove: STOP_T3,
        startWhenRoomUnder: START_T3
    },
    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: {
        output: RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
        inputs: BOOST_REACTIONS[RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE],
        stopWhenRoomAbove: STOP_T3,
        startWhenRoomUnder: START_T3
    },
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: {
        output: RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
        inputs: BOOST_REACTIONS[RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE],
        stopWhenRoomAbove: STOP_T3,
        startWhenRoomUnder: START_T3
    },
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: {
        output: RESOURCE_CATALYZED_ZYNTHIUM_ACID,
        inputs: BOOST_REACTIONS[RESOURCE_CATALYZED_ZYNTHIUM_ACID],
        stopWhenRoomAbove: STOP_T3,
        startWhenRoomUnder: START_T3
    },
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: {
        output: RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
        inputs: BOOST_REACTIONS[RESOURCE_CATALYZED_GHODIUM_ALKALIDE],
        stopWhenRoomAbove: STOP_T3,
        startWhenRoomUnder: START_T3
    },
    [RESOURCE_CATALYZED_UTRIUM_ACID]: {
        output: RESOURCE_CATALYZED_UTRIUM_ACID,
        inputs: BOOST_REACTIONS[RESOURCE_CATALYZED_UTRIUM_ACID],
        stopWhenRoomAbove: STOP_T3,
        startWhenRoomUnder: START_T3
    },
    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: {
        output: RESOURCE_CATALYZED_LEMERGIUM_ACID,
        inputs: BOOST_REACTIONS[RESOURCE_CATALYZED_LEMERGIUM_ACID],
        stopWhenRoomAbove: STOP_T3,
        startWhenRoomUnder: START_T3
    },
    [RESOURCE_CATALYZED_KEANIUM_ACID]: {
        output: RESOURCE_CATALYZED_KEANIUM_ACID,
        inputs: BOOST_REACTIONS[RESOURCE_CATALYZED_KEANIUM_ACID],
        stopWhenRoomAbove: STOP_T3,
        startWhenRoomUnder: START_T3
    },
    [RESOURCE_CATALYZED_KEANIUM_ACID]: {
        output: RESOURCE_CATALYZED_KEANIUM_ACID,
        inputs: BOOST_REACTIONS[RESOURCE_CATALYZED_KEANIUM_ACID],
        stopWhenRoomAbove: STOP_T3,
        startWhenRoomUnder: START_T3
    },
    [RESOURCE_KEANIUM_ALKALIDE]: {
        output: RESOURCE_KEANIUM_ALKALIDE,
        inputs: BOOST_REACTIONS[RESOURCE_KEANIUM_ALKALIDE],
        stopWhenRoomAbove: STOP_T2,
        startWhenRoomUnder: START_T2
    },
    [RESOURCE_LEMERGIUM_ALKALIDE]: {
        output: RESOURCE_LEMERGIUM_ALKALIDE,
        inputs: BOOST_REACTIONS[RESOURCE_LEMERGIUM_ALKALIDE],
        stopWhenRoomAbove: STOP_T2,
        startWhenRoomUnder: START_T2
    },
    [RESOURCE_ZYNTHIUM_ALKALIDE]: {
        output: RESOURCE_ZYNTHIUM_ALKALIDE,
        inputs: BOOST_REACTIONS[RESOURCE_ZYNTHIUM_ALKALIDE],
        stopWhenRoomAbove: STOP_T2,
        startWhenRoomUnder: START_T2
    },
    [RESOURCE_GHODIUM_ALKALIDE]: {
        output: RESOURCE_GHODIUM_ALKALIDE,
        inputs: BOOST_REACTIONS[RESOURCE_GHODIUM_ALKALIDE],
        stopWhenRoomAbove: STOP_T2,
        startWhenRoomUnder: START_T2
    },
    [RESOURCE_GHODIUM_ACID]: {
        output: RESOURCE_GHODIUM_ACID,
        inputs: BOOST_REACTIONS[RESOURCE_GHODIUM_ACID],
        stopWhenRoomAbove: STOP_T2,
        startWhenRoomUnder: START_T2
    },
    [RESOURCE_ZYNTHIUM_ACID]: {
        output: RESOURCE_ZYNTHIUM_ACID,
        inputs: BOOST_REACTIONS[RESOURCE_ZYNTHIUM_ACID],
        stopWhenRoomAbove: STOP_T2,
        startWhenRoomUnder: START_T2
    },
    [RESOURCE_UTRIUM_ALKALIDE]: {
        output: RESOURCE_UTRIUM_ALKALIDE,
        inputs: BOOST_REACTIONS[RESOURCE_UTRIUM_ALKALIDE],
        stopWhenRoomAbove: STOP_T2,
        startWhenRoomUnder: START_T2
    },
    [RESOURCE_LEMERGIUM_ACID]: {
        output: RESOURCE_LEMERGIUM_ACID,
        inputs: BOOST_REACTIONS[RESOURCE_LEMERGIUM_ACID],
        stopWhenRoomAbove: STOP_T2,
        startWhenRoomUnder: START_T2
    },
    [RESOURCE_KEANIUM_ACID]: {
        output: RESOURCE_KEANIUM_ACID,
        inputs: BOOST_REACTIONS[RESOURCE_KEANIUM_ACID],
        stopWhenRoomAbove: STOP_T2,
        startWhenRoomUnder: START_T2
    },
    [RESOURCE_HYDROXIDE]: {
        output: RESOURCE_HYDROXIDE,
        inputs: BOOST_REACTIONS[RESOURCE_HYDROXIDE],
        stopWhenRoomAbove: STOP_T2,
        startWhenRoomUnder: START_T2
    },
    [RESOURCE_UTRIUM_ACID]: {
        output: RESOURCE_UTRIUM_ACID,
        inputs: BOOST_REACTIONS[RESOURCE_UTRIUM_ACID],
        stopWhenRoomAbove: STOP_T2,
        startWhenRoomUnder: START_T2
    },
    [RESOURCE_GHODIUM]: {
        output: RESOURCE_GHODIUM,
        inputs: BOOST_REACTIONS[RESOURCE_GHODIUM],
        stopWhenRoomAbove: STOP_T1,
        startWhenRoomUnder: START_T1
    },
    [RESOURCE_ZYNTHIUM_KEANITE]: {
        output: RESOURCE_ZYNTHIUM_KEANITE,
        inputs: BOOST_REACTIONS[RESOURCE_ZYNTHIUM_KEANITE],
        stopWhenRoomAbove: STOP_T1,
        startWhenRoomUnder: START_T1
    },
    [RESOURCE_UTRIUM_LEMERGITE]: {
        output: RESOURCE_UTRIUM_LEMERGITE,
        inputs: BOOST_REACTIONS[RESOURCE_UTRIUM_LEMERGITE],
        stopWhenRoomAbove: STOP_T1,
        startWhenRoomUnder: START_T1
    },
    [RESOURCE_KEANIUM_OXIDE]: {
        output: RESOURCE_KEANIUM_OXIDE,
        inputs: BOOST_REACTIONS[RESOURCE_KEANIUM_OXIDE],
        stopWhenRoomAbove: STOP_T1,
        startWhenRoomUnder: START_T1
    },
    [RESOURCE_GHODIUM_OXIDE]: {
        output: RESOURCE_GHODIUM_OXIDE,
        inputs: BOOST_REACTIONS[RESOURCE_GHODIUM_OXIDE],
        stopWhenRoomAbove: STOP_T1,
        startWhenRoomUnder: START_T1
    },
    [RESOURCE_GHODIUM_HYDRIDE]: {
        output: RESOURCE_GHODIUM_HYDRIDE,
        inputs: BOOST_REACTIONS[RESOURCE_GHODIUM_HYDRIDE],
        stopWhenRoomAbove: STOP_T1,
        startWhenRoomUnder: START_T1
    },
    [RESOURCE_UTRIUM_HYDRIDE]: {
        output: RESOURCE_UTRIUM_HYDRIDE,
        inputs: BOOST_REACTIONS[RESOURCE_UTRIUM_HYDRIDE],
        stopWhenRoomAbove: STOP_T1,
        startWhenRoomUnder: START_T1
    },
    [RESOURCE_LEMERGIUM_OXIDE]: {
        output: RESOURCE_LEMERGIUM_OXIDE,
        inputs: BOOST_REACTIONS[RESOURCE_LEMERGIUM_OXIDE],
        stopWhenRoomAbove: STOP_T1,
        startWhenRoomUnder: START_T1
    },
    [RESOURCE_ZYNTHIUM_OXIDE]: {
        output: RESOURCE_ZYNTHIUM_OXIDE,
        inputs: BOOST_REACTIONS[RESOURCE_ZYNTHIUM_OXIDE],
        stopWhenRoomAbove: STOP_T1,
        startWhenRoomUnder: START_T1
    },
    [RESOURCE_LEMERGIUM_HYDRIDE]: {
        output: RESOURCE_LEMERGIUM_HYDRIDE,
        inputs: BOOST_REACTIONS[RESOURCE_LEMERGIUM_HYDRIDE],
        stopWhenRoomAbove: STOP_T1,
        startWhenRoomUnder: START_T1
    },
    [RESOURCE_KEANIUM_HYDRIDE]: {
        output: RESOURCE_KEANIUM_HYDRIDE,
        inputs: BOOST_REACTIONS[RESOURCE_KEANIUM_HYDRIDE],
        stopWhenRoomAbove: STOP_T1,
        startWhenRoomUnder: START_T1
    },
    [RESOURCE_ZYNTHIUM_HYDRIDE]: {
        output: RESOURCE_ZYNTHIUM_HYDRIDE,
        inputs: BOOST_REACTIONS[RESOURCE_ZYNTHIUM_HYDRIDE],
        stopWhenRoomAbove: STOP_T1,
        startWhenRoomUnder: START_T1
    },
    [RESOURCE_UTRIUM_OXIDE]: {
        output: RESOURCE_UTRIUM_OXIDE,
        inputs: BOOST_REACTIONS[RESOURCE_UTRIUM_OXIDE],
        stopWhenRoomAbove: STOP_T1,
        startWhenRoomUnder: START_T1
    }
};
const REACTION_GROUPS = [
    [
        CONFIG$l[RESOURCE_CATALYZED_UTRIUM_ACID],
        // CONFIG[RESOURCE_CATALYZED_UTRIUM_ALKALIDE],
        CONFIG$l[RESOURCE_CATALYZED_KEANIUM_ACID],
        CONFIG$l[RESOURCE_CATALYZED_KEANIUM_ALKALIDE],
        CONFIG$l[RESOURCE_CATALYZED_LEMERGIUM_ACID],
        CONFIG$l[RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE],
        CONFIG$l[RESOURCE_CATALYZED_ZYNTHIUM_ACID],
        CONFIG$l[RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE],
        CONFIG$l[RESOURCE_CATALYZED_GHODIUM_ACID],
        CONFIG$l[RESOURCE_CATALYZED_GHODIUM_ALKALIDE]
    ],
    [
        CONFIG$l[RESOURCE_UTRIUM_ACID],
        // CONFIG[RESOURCE_UTRIUM_ALKALIDE],
        CONFIG$l[RESOURCE_KEANIUM_ACID],
        CONFIG$l[RESOURCE_KEANIUM_ALKALIDE],
        CONFIG$l[RESOURCE_LEMERGIUM_ACID],
        CONFIG$l[RESOURCE_LEMERGIUM_ALKALIDE],
        CONFIG$l[RESOURCE_ZYNTHIUM_ACID],
        CONFIG$l[RESOURCE_ZYNTHIUM_ALKALIDE],
        CONFIG$l[RESOURCE_GHODIUM_ACID],
        CONFIG$l[RESOURCE_GHODIUM_ALKALIDE]
    ],
    [
        CONFIG$l[RESOURCE_HYDROXIDE],
        CONFIG$l[RESOURCE_ZYNTHIUM_KEANITE],
        CONFIG$l[RESOURCE_UTRIUM_LEMERGITE],
        CONFIG$l[RESOURCE_GHODIUM],
        CONFIG$l[RESOURCE_UTRIUM_HYDRIDE],
        // CONFIG[RESOURCE_UTRIUM_OXIDE],
        CONFIG$l[RESOURCE_KEANIUM_HYDRIDE],
        CONFIG$l[RESOURCE_KEANIUM_OXIDE],
        CONFIG$l[RESOURCE_LEMERGIUM_HYDRIDE],
        CONFIG$l[RESOURCE_LEMERGIUM_OXIDE],
        CONFIG$l[RESOURCE_ZYNTHIUM_HYDRIDE],
        CONFIG$l[RESOURCE_ZYNTHIUM_OXIDE],
        CONFIG$l[RESOURCE_GHODIUM_HYDRIDE],
        CONFIG$l[RESOURCE_GHODIUM_OXIDE]
    ]
];
class RoomLabOutputMemory {
    static handle() {
        General.interval(50, () => {
            Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            });
        });
    }
    static handleRoom(room) {
        if (room.isAbandoning) {
            room.mem.labOutputResource = undefined;
            return;
        }
        if (!room.storage) {
            return;
        }
        if (!room.terminal) {
            return;
        }
        if (room.labInputs.length !== 2) {
            return;
        }
        if (room.labOutputs.length === 0) {
            return;
        }
        if (this.isCurrentReactionIsOk(room)) {
            return;
        }
        this.updateReaction(room);
    }
    static updateReaction(room) {
        const newReaction = this.findBestReaction(room);
        if (room.mem.labOutputResource !== newReaction) {
            console.log(`<span style="color: #00ce9e;">Reactions:</span> changing reaction in ${Helpers.roomLink(room.name)} from <strong>${String(room.mem.labOutputResource)}</strong> to <strong>${String(newReaction)}</strong>`);
        }
        room.mem.labOutputResource = newReaction;
    }
    static findBestReaction(room) {
        for (const group of REACTION_GROUPS) {
            const outcome = group
                .sort((a, b) => room.store[a.output] - room.store[b.output])
                .find(o => {
                if (!o.inputs) {
                    return false;
                }
                if (room.store[o.output] > o.startWhenRoomUnder) {
                    return false;
                }
                if (room.store[o.inputs[0]] < MIN_INPUT_RESOURCES_TO_START_NEW_REACTION) {
                    return false;
                }
                if (room.store[o.inputs[1]] < MIN_INPUT_RESOURCES_TO_START_NEW_REACTION) {
                    return false;
                }
                return true;
            });
            if (!outcome) {
                continue;
            }
            return outcome.output;
        }
        return;
    }
    static isCurrentReactionIsOk(room) {
        if (!room.mem.labOutputResource) {
            return false;
        }
        const config = CONFIG$l[room.mem.labOutputResource];
        if (!config.inputs) {
            return false;
        }
        return (room.store[config.inputs[0]] >= LAB_REACTION_AMOUNT &&
            room.store[config.inputs[1]] >= LAB_REACTION_AMOUNT &&
            room.store[room.mem.labOutputResource] < config.stopWhenRoomAbove);
    }
}

const MAX_IDLE_TIME = 10500;
const CLEANUP_OLDER_THAN = 30000;
const CONSTRUCTIONS_CACHE = {};
class CleanupConstructions {
    static handle() {
        General.interval(100, () => {
            Object.values(Game.constructionSites).forEach(construction => {
                this.handleConstruction(construction);
            });
        });
        this.cleanupCache();
    }
    static cleanupCache() {
        for (const constructionId in CONSTRUCTIONS_CACHE) {
            if (CONSTRUCTIONS_CACHE[constructionId].progressedAt < Game.time - CLEANUP_OLDER_THAN) {
                delete CONSTRUCTIONS_CACHE[constructionId];
            }
        }
    }
    static handleConstruction(construction) {
        if (!CONSTRUCTIONS_CACHE[construction.id]) {
            CONSTRUCTIONS_CACHE[construction.id] = {
                id: construction.id,
                progress: construction.progress,
                progressedAt: Game.time
            };
            return;
        }
        if (CONSTRUCTIONS_CACHE[construction.id].progress !== construction.progress) {
            CONSTRUCTIONS_CACHE[construction.id].progress = construction.progress;
            CONSTRUCTIONS_CACHE[construction.id].progressedAt = Game.time;
            return;
        }
        if (CONSTRUCTIONS_CACHE[construction.id].progress === construction.progress &&
            CONSTRUCTIONS_CACHE[construction.id].progressedAt < Game.time - MAX_IDLE_TIME) {
            Log.object(construction, "remove old construction");
            construction.remove();
            delete CONSTRUCTIONS_CACHE[construction.id];
            return;
        }
    }
}

class ClearExpiredFlags {
    static handle() {
        General.interval(10, () => {
            const flags = this.getFlags();
            this.setToDeleteFlags(flags);
            this.deleteExpiredFlags(flags);
        });
    }
    static getFlags() {
        return Object.values(Game.flags).filter(f => f.color === COLOR_ORANGE && f.secondaryColor === COLOR_ORANGE);
    }
    static setToDeleteFlags(flags) {
        flags.forEach(f => {
            if (f.memory.deleteAt) {
                return;
            }
            f.memory.deleteAt = Game.time + 2000;
        });
    }
    static deleteExpiredFlags(flags) {
        flags.forEach(f => {
            if (!f.memory.deleteAt) {
                return;
            }
            if (f.memory.deleteAt > Game.time) {
                return;
            }
            f.remove();
            delete Memory.flags[f.name];
        });
    }
}

class DamageVisuals {
    static handle() {
        Object.values(Game.rooms).filter(room => {
            this.handleRoom(room);
        });
    }
    static handleRoom(room) {
        const damageLogs = {};
        const addDamage = function (x, y, type, damage) {
            if (!damageLogs[x]) {
                damageLogs[x] = {};
            }
            if (!damageLogs[x][y]) {
                damageLogs[x][y] = {};
            }
            if (!damageLogs[x][y][type]) {
                damageLogs[x][y][type] = damage;
            }
            else {
                damageLogs[x][y][type] += damage;
            }
        };
        room.getEventLog().forEach(log => {
            let target;
            switch (log.event) {
                case EVENT_ATTACK:
                    target = Game.getObjectById(log.data.targetId);
                    if (!target)
                        return;
                    if (!("pos" in target))
                        return;
                    addDamage(target.pos.x, target.pos.y, "damage", log.data.damage);
                    return;
                case EVENT_HEAL:
                case EVENT_REPAIR:
                case EVENT_BUILD:
                    target = Game.getObjectById(log.data.targetId);
                    if (!target)
                        return;
                    if (!("pos" in target))
                        return;
                    addDamage(target.pos.x, target.pos.y, "heal", log.data.amount);
                    return;
                case EVENT_UPGRADE_CONTROLLER:
                    target = room.controller;
                    if (!target)
                        return;
                    if (!("pos" in target))
                        return;
                    addDamage(target.pos.x, target.pos.y, "upgrade", log.data.amount);
                    return;
            }
        });
        for (const x in damageLogs) {
            for (const y in damageLogs[x]) {
                for (const attackType in damageLogs[x][y]) {
                    const posX = parseInt(x, 10);
                    const posY = parseInt(y, 10);
                    switch (attackType) {
                        case "damage":
                            room.visual.text(String(damageLogs[x][y].damage), posX, posY - 0.15, {
                                font: 0.2,
                                stroke: "#be0202",
                                align: "center"
                            });
                            break;
                        case "heal":
                            room.visual.text(String(damageLogs[x][y].heal), posX, posY + 0.15, {
                                font: 0.2,
                                stroke: "#0c9d03",
                                align: "center"
                            });
                            break;
                        case "upgrade":
                            room.visual.text(String(damageLogs[x][y].upgrade), posX, posY, {
                                font: 0.2,
                                stroke: "#0c9d03",
                                align: "center"
                            });
                            break;
                    }
                }
            }
        }
    }
}

class DeathVisuals {
    static handle() {
        Rooms.memoryObjectRoomValues.forEach(room => {
            this.handleRoom(room);
        });
    }
    static handleRoom(roomMemory) {
        if (!roomMemory.name) {
            return;
        }
        if (roomMemory.recentDeaths && roomMemory.recentDeaths > 0.1) {
            Game.map.visual.text("D: " + String(roomMemory.recentDeaths.toFixed(2)), new RoomPosition(25, 20, roomMemory.name));
        }
        if (roomMemory.recentKills && roomMemory.recentKills > 0.1) {
            Game.map.visual.text("K: " + String(roomMemory.recentKills.toFixed(2)), new RoomPosition(25, 30, roomMemory.name));
        }
        // Game.map.visual.text("💀 " + String(room.hostility?.deaths || 0), new RoomPosition(25, 30, room.name));
    }
}

class VisualizeRoomStats {
    static init() {
        this.spawnQue = {};
        this.reaction = {};
        this.roomLines = {};
        this.multiSpawnQue = {};
        this.upgradeEta = {};
    }
    static handleReactions() {
        Object.entries(this.reaction).forEach(([roomName, text]) => {
            if (!this.roomLines[roomName]) {
                this.roomLines[roomName] = 0;
            }
            new RoomVisual(roomName).text("Reaction", 2, this.roomLines[roomName]++, this.styleTitle());
            new RoomVisual(roomName).text(this.tab() + text, 2, this.roomLines[roomName]++, this.styleLine());
        });
    }
    static handleControllerUpgradeEta() {
        Object.entries(this.upgradeEta).forEach(([roomName, text]) => {
            if (!this.roomLines[roomName]) {
                this.roomLines[roomName] = 0;
            }
            new RoomVisual(roomName).text("Controller upgrade eta", 2, this.roomLines[roomName]++, this.styleTitle());
            new RoomVisual(roomName).text(this.tab() + String(text), 2, this.roomLines[roomName]++, this.styleLine());
        });
    }
    static handleSpawnQue() {
        Object.entries(this.spawnQue).forEach(([roomName, que]) => {
            que.forEach((text, index) => {
                if (!this.roomLines[roomName]) {
                    this.roomLines[roomName] = 0;
                }
                if (index === 0) {
                    new RoomVisual(roomName).text("Spawn que", 2, this.roomLines[roomName]++, this.styleTitle());
                }
                new RoomVisual(roomName).text(this.tab() + text, 2, this.roomLines[roomName]++, this.styleLine());
            });
        });
    }
    static handleMultiSpawnQue() {
        Object.entries(this.multiSpawnQue).forEach(([roomName, que]) => {
            que.forEach((text, index) => {
                if (!this.roomLines[roomName]) {
                    this.roomLines[roomName] = 0;
                }
                if (index === 0) {
                    new RoomVisual(roomName).text("Multi spawn que", 2, this.roomLines[roomName]++, this.styleTitle());
                }
                new RoomVisual(roomName).text(this.tab() + text, 2, this.roomLines[roomName]++, this.styleLine());
            });
        });
    }
    static handleActiveSpawn() {
        const roomTitles = {};
        Creeps.myCreeps.forEach(creep => {
            var _a;
            if (!creep.spawning) {
                return;
            }
            if (!creep.memory.homeRoom) {
                return;
            }
            if (!this.roomLines[creep.room.name]) {
                this.roomLines[creep.room.name] = 0;
            }
            if (!roomTitles[creep.room.name]) {
                roomTitles[creep.room.name] = true;
                new RoomVisual(creep.room.name).text("Spawning", 2, this.roomLines[creep.room.name]++, this.styleTitle());
            }
            const spawn = creep.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_SPAWN);
            if (!(spawn instanceof StructureSpawn)) {
                return;
            }
            if (!spawn.spawning) {
                return;
            }
            const line = [(_a = spawn.spawning) === null || _a === void 0 ? void 0 : _a.remainingTime.toString().padEnd(4, " "), String(creep.memory.role)];
            if (creep.pos.roomName !== creep.memory.homeRoom) {
                line.push(creep.memory.homeRoom);
            }
            new RoomVisual(creep.pos.roomName).text(this.tab() + "  " + line.join("|"), 2, this.roomLines[creep.pos.roomName]++, this.styleLine());
        });
    }
    static exit() {
        this.handleControllerUpgradeEta();
        this.handleReactions();
        this.handleMultiSpawnQue();
        this.handleSpawnQue();
        this.handleActiveSpawn();
    }
    static styleTitle() {
        return {
            align: "left",
            color: "#ffc038"
        };
    }
    static styleLine() {
        return { align: "left", font: "0.7 Courier New" };
    }
    static tab() {
        return "  ";
    }
    static addSpawnQue(roomName, text) {
        this.spawnQue[roomName] ? this.spawnQue[roomName].push(text) : (this.spawnQue[roomName] = [text]);
    }
    static addMultiSpawnQue(roomName, text) {
        this.multiSpawnQue[roomName] ? this.multiSpawnQue[roomName].push(text) : (this.multiSpawnQue[roomName] = [text]);
    }
    static addReaction(roomName, reaction) {
        this.reaction[roomName] = reaction;
    }
    static addUpgradeEta(roomName, eta) {
        this.upgradeEta[roomName] = eta;
    }
}
VisualizeRoomStats.spawnQue = {};
VisualizeRoomStats.multiSpawnQue = {};
VisualizeRoomStats.reaction = {};
VisualizeRoomStats.roomLines = {};
VisualizeRoomStats.upgradeEta = {};

class ReactionVisuals {
    static handle() {
        Rooms.myRooms.filter(room => {
            this.handleRoom(room);
        });
    }
    static handleRoom(room) {
        if (!room.mem.labOutputResource) {
            return;
        }
        const reaction = BOOST_REACTIONS[room.mem.labOutputResource];
        if (!reaction)
            return;
        VisualizeRoomStats.addReaction(room.name, `${reaction[0]} + ${reaction[1]} = ${room.mem.labOutputResource}`);
    }
}

class SpawnQueueVisuals {
    static handle() {
        Rooms.myRooms.forEach(room => {
            this.handleRoom(room);
        });
    }
    static handleRoom(room) {
        if (!Memory.spawnQue) {
            return;
        }
        const queues = Memory.spawnQue.filter(q => q.rooms.includes(room.name));
        queues.forEach(que => {
            const roleName = que.role;
            if (que.rooms.length > 1) {
                VisualizeRoomStats.addMultiSpawnQue(room.name, [String(que.priority), String(que.expiresAt - Game.time).padEnd(4, " "), roleName, que.rooms.join(", ")].join("|"));
            }
            else {
                VisualizeRoomStats.addSpawnQue(room.name, [String(que.priority), String(que.expiresAt - Game.time).padEnd(4, " "), roleName].join("|"));
            }
        });
    }
}

class SpawnSpawningVisuals {
    static handle() {
        const roomCreeps = {};
        Creeps.myCreeps.forEach(creep => {
            if (!creep.spawning)
                return;
            if (!roomCreeps[creep.room.name]) {
                roomCreeps[creep.room.name] = [];
            }
            roomCreeps[creep.room.name].push(creep.memory.role);
        });
        Object.entries(roomCreeps).forEach(([roomName, roles]) => {
            const roomVisual = new RoomVisual(roomName);
            const room = Game.rooms[roomName];
            if (!room) {
                return;
            }
            if (!room.center) {
                return;
            }
            let i = 0;
            roles.forEach(role => {
                if (!room.center) {
                    return;
                }
                roomVisual.text(role, room.center.x, room.center.y - 2.5 - i++ * 0.5, {
                    color: "#fff",
                    stroke: "#000",
                    align: "center",
                    font: 0.4
                });
            });
        });
    }
}

class TerminalTransactions {
    static handle() {
        this.printIncomingTransactions();
        this.printOutgoingTransactions();
    }
    static printOutgoingTransactions() {
        Game.market.outgoingTransactions
            .filter(t => t.time === Game.time - 1)
            .forEach(transaction => {
            var _a, _b;
            if (((_a = transaction.recipient) === null || _a === void 0 ? void 0 : _a.username) === USERNAME.ME && ((_b = transaction.sender) === null || _b === void 0 ? void 0 : _b.username) === USERNAME.ME) {
                return;
            }
            this.printTransaction(transaction);
        });
    }
    static printIncomingTransactions() {
        Game.market.incomingTransactions
            .filter(t => t.time === Game.time - 1)
            .forEach(transaction => {
            this.printTransaction(transaction);
        });
    }
    static printTransaction(transaction) {
        var _a, _b;
        const fromRoom = Helpers.roomLink(transaction.from);
        const toRoom = Helpers.roomLink(transaction.to);
        const data = [];
        const transactionType = () => {
            var _a, _b, _c, _d;
            let color = `<span style="color: #fff">${"bal".padEnd(3)}</span>`;
            if (((_a = transaction.recipient) === null || _a === void 0 ? void 0 : _a.username) === USERNAME.ME && ((_b = transaction.sender) === null || _b === void 0 ? void 0 : _b.username) !== USERNAME.ME) {
                color = `<span style="color: #ce0000">${"in".padEnd(3)}</span>`;
            }
            if (((_c = transaction.recipient) === null || _c === void 0 ? void 0 : _c.username) !== USERNAME.ME && ((_d = transaction.sender) === null || _d === void 0 ? void 0 : _d.username) === USERNAME.ME) {
                color = `<span style="color: #07ce00">${"out".padEnd(3)}</span>`;
            }
            return color;
        };
        data.push(`<span style="color: #fff;">Terminal:</span>`);
        data.push(transactionType());
        data.push(`<span>${fromRoom} ${(((_a = transaction.sender) === null || _a === void 0 ? void 0 : _a.username) || "").slice(0, 12).padEnd(12)}</span>`);
        data.push("->");
        data.push(`<span>${toRoom} ${(((_b = transaction.recipient) === null || _b === void 0 ? void 0 : _b.username) || "").slice(0, 12).padEnd(12)}</span>`);
        data.push(`<strong>${String(transaction.amount).padEnd(5)}</strong>`);
        data.push(`<span style="color: black; background: ${RESOURCE_COLORS[transaction.resourceType]};">&nbsp;${transaction.resourceType.padEnd(15)}&nbsp;</span>`);
        const cost = (Resources.resourceValues[RESOURCE_ENERGY] *
            Game.market.calcTransactionCost(transaction.amount, transaction.from, transaction.to)) /
            transaction.amount;
        data.push(`cost:${cost.toLocaleString().padEnd(12)}`);
        if (transaction.order) {
            data.push(`price:${transaction.order.price.toLocaleString().padEnd(12)}`);
            const profit = transaction.order.price - cost;
            data.push(`profit:${profit.toLocaleString().padEnd(12)}`);
        }
        const description = BOOST_DESCRIPTIONS[transaction.resourceType];
        if (description) {
            data.push(`<span style="color: ${RESOURCE_COLORS[transaction.resourceType]};">${description}</span>`);
        }
        console.log(data.join(" "));
    }
}

const CONFIG$k = Config.Attacker;
class Attacker {
    static handle() {
        Creeps.getByRole(CONFIG$k.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(50, () => TickAction.add(() => this.flagSpawner()));
    }
    static flagSpawner() {
        Object.values(Game.flags)
            .filter(f => f.color === COLOR_RED &&
            (f.secondaryColor === COLOR_RED ||
                // f.secondaryColor === COLOR_PURPLE ||
                f.secondaryColor === COLOR_BLUE ||
                f.secondaryColor === COLOR_CYAN))
            .forEach(flag => {
            const targetRoomName = flag.pos.roomName;
            const roomModel = new RoomModel(targetRoomName);
            if (roomModel.ownerUsername !== USERNAME.ME && roomModel.isInSafeMode) {
                return;
            }
            const spawnRoom = Geo.closestHomeRoomByRange(targetRoomName, {
                maxDistance: MAX_EXPANSION_RANGE,
                minLevel: 8
            });
            if (!spawnRoom) {
                Log.room(flag.pos.roomName, "Attacker", "No closest room for spawn");
                return;
            }
            const distance = Geo.findRouteCached(spawnRoom.name, flag.pos.roomName).length;
            const creepsCount = Creeps.creepsCountWithQue({ minTicksToLive: 200 + distance * 50, targetFlag: flag.name });
            if (creepsCount >= 1) {
                return;
            }
            Spawns.addToQue(spawnRoom, Object.assign(Object.assign({}, this.getCreepBuild(flag.secondaryColor)), { priority: 2 /* High */, role: CONFIG$k.roleName, memory: {
                    targetRoom: targetRoomName,
                    targetFlag: flag.name
                } }));
        });
    }
    static getCreepBuild(color) {
        switch (color) {
            case COLOR_CYAN:
                return {
                    body: BodyParts.new().tough(4).rangedAttack().move(10).attack(27).heal(8),
                    boosts: [
                        BOOST_ALIAS.TOUGH_3,
                        BOOST_ALIAS.RANGED_ATTACK_3,
                        BOOST_ALIAS.MOVE_3,
                        BOOST_ALIAS.ATTACK_3,
                        BOOST_ALIAS.HEAL_3
                    ]
                };
            default: {
                return {
                    body: BodyParts.new().tough(2).move(25).attack(18).heal(5),
                    boosts: [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]
                };
            }
        }
    }
    static handleCreep(creep) {
        var _a;
        creep.notifyWhenAttacked(false);
        if (creep.boost({ minTicksToLive: 1 })) {
            return;
        }
        // creep.bestAttack()
        creep.rangedBestAttack();
        creep.bestAttack((_a = creep.targetFlag) === null || _a === void 0 ? void 0 : _a.pos) || creep.healMele() || this.attackStructures(creep) || creep.prehealMele();
        this.move(creep);
    }
    static attackStructures(creep) {
        if (creep.attackPower === 0) {
            return false;
        }
        const hostile = creep.pos
            .findInRange(FIND_HOSTILE_STRUCTURES, 1, { filter: s => s.structureType !== STRUCTURE_KEEPER_LAIR })
            .sort((a, b) => a.hits - b.hits)[0] ||
            creep.pos
                .findInRange(FIND_STRUCTURES, 1, {
                filter: s => s.room.model.canAttackStructures && s.hits
            })
                .sort((a, b) => a.hits - b.hits)[0];
        if (!hostile) {
            return false;
        }
        creep.attack(hostile);
        return true;
    }
    static move(creep) {
        // moveToFlagRoom() ||
        // kiteBack() ||
        //   //   // moveToHostiles() ||
        //   moveOnToConstructionSites() ||
        this.moveToFlagRoom(creep) ||
            // this.moveToTargetRoom(creep) ||
            this.moveToHostiles(creep) ||
            this.moveToRampartNearHostile(creep) ||
            this.moveToHostileStructures(creep) ||
            this.moveToFlagOnStructure(creep) ||
            this.moveToHostileRamparts(creep) ||
            this.moveToNpcHostiles(creep) ||
            // this.moveToSoonestLair(creep) ||
            this.moveToStructures(creep) ||
            this.moveToFlag(creep);
        // this.moveToFlagRoom(creep) ||
        //   this.moveToHostiles(creep) ||
        //   this.moveToFlagOnStructure(creep) ||
        //   this.moveToFlag(creep);
        // this.moveToFlagRoom(creep) || this.moveToFlag(creep);
    }
    static moveToRampartNearHostile(creep) {
        if (creep.pos.rampart) {
            return false;
        }
        const ramparts = {};
        creep.pos.findInRange(FIND_HOSTILE_CREEPS, 1).forEach(hostile => {
            const ramprtsNextToHostile = hostile.pos.findInRange(FIND_MY_STRUCTURES, 1, {
                filter: s => s.structureType === STRUCTURE_RAMPART
            });
            ramprtsNextToHostile.forEach(r => {
                ramparts[r.id] = r;
            });
        });
        const rampart = Object.values(ramparts).sort((a, b) => creep.pos.getRangeTo(a) - creep.pos.getRangeTo(b))[0];
        if (!rampart) {
            return false;
        }
        creep.travel(rampart, { range: 0 });
        return true;
    }
    static moveToSoonestLair(creep) {
        const lairs = creep.room.find(FIND_HOSTILE_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_KEEPER_LAIR
        });
        const lair = lairs.sort((a, b) => (a.ticksToSpawn || 999) - (b.ticksToSpawn || 999))[0];
        if (!lair) {
            return false;
        }
        creep.travel(lair);
        return true;
    }
    static moveOnToConstructionSites(creep) {
        const constructionSite = creep.pos.findClosestByRange(FIND_HOSTILE_CONSTRUCTION_SITES, {
            filter: s => s.structureType !== STRUCTURE_EXTRACTOR &&
                s.progress &&
                s.progress > 1000 &&
                !s.pos.lookFor(LOOK_STRUCTURES).find(ls => ls.structureType === STRUCTURE_RAMPART)
        });
        if (!constructionSite)
            return false;
        creep.travel(constructionSite, { range: 0 });
        return true;
    }
    static moveToTargetRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        if (creep.memory.targetRoom === creep.room.name) {
            return false;
        }
        creep.travelToRoom(creep.memory.targetRoom, {
            ignoreCreeps: true,
            ignoreHostiles: true,
            costRoomHighway: 2,
            costRoomStandart: 3,
            costRoomSk: 3
        });
        return true;
    }
    static moveToFlagRoom(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        if (creep.targetFlag.pos.roomName === creep.room.name)
            return false;
        creep.travel(creep.targetFlag, {
            ignoreCreeps: true,
            ignoreHostiles: true,
            costRoomHighway: 2,
            costRoomStandart: 3,
            costRoomSk: 3
        });
        return true;
    }
    static moveToFlagOnStructure(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        if (!creep.targetFlag.room) {
            return false;
        }
        if (creep.targetFlag.room.my) {
            return false;
        }
        const structure = creep.targetFlag.pos.lookFor(LOOK_STRUCTURES)[0];
        if (!structure) {
            return false;
        }
        // creep.travelTo(creep.targetFlag, { allowSK: true });
        creep.travel(creep.targetFlag, {
            costRoomSk: 2,
            costRoomStandart: 2,
            costRoomHighway: 1,
            range: 1
        });
        return true;
    }
    static moveToFlag(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.targetFlag);
        if ((creep.targetFlag.pos.creep && distance <= 1) || distance <= 0) {
            return false;
        }
        creep.travel(creep.targetFlag, {
            ignoreCreeps: false,
            freshPath: distance <= 3,
            range: distance <= 1 ? 0 : 1
        });
        // creep.moveToSiegeFlagRoom(creep.targetFlag);
        return true;
    }
    static moveToHostileRamparts(creep) {
        const structure = creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
            range: 3,
            filter: s => s.structureType === STRUCTURE_RAMPART &&
                // s.structureType !== STRUCTURE_INVADER_CORE &&
                s.hits > 0
        });
        if (!structure)
            return false;
        if (creep.pos.getRangeTo(structure) > 3) {
            creep.travel(structure, { range: 1 }) || creep.travel(structure, { range: 3 });
        }
        return true;
    }
    static moveToStructures(creep) {
        if (!creep.room.model.canAttackStructures) {
            return false;
        }
        const structure = creep.pos.findClosestByPath(FIND_STRUCTURES, {
            range: 1,
            filter: s => s.hits > 0
        });
        if (!structure) {
            return false;
        }
        creep.travel(structure, { range: 1 });
        return true;
    }
    static moveToHostileStructures(creep) {
        const structure = creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
            range: 1,
            filter: s => s.structureType !== STRUCTURE_CONTROLLER &&
                // s.structureType !== STRUCTURE_STORAGE &&
                s.structureType !== STRUCTURE_POWER_BANK &&
                s.structureType !== STRUCTURE_RAMPART &&
                s.structureType !== STRUCTURE_INVADER_CORE &&
                s.pos.lookFor(LOOK_STRUCTURES).filter(ss => ss.structureType === STRUCTURE_RAMPART).length === 0 &&
                // s.structureType !== STRUCTURE_INVADER_CORE &&
                s.hits > 0
        }) ||
            creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
                range: 1,
                filter: s => s.structureType !== STRUCTURE_POWER_BANK && s.hits > 0
            });
        if (!structure) {
            return false;
        }
        creep.travel(structure, { range: 1 });
        return true;
    }
    static moveToHostiles(creep) {
        const hostile = creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
            range: 1,
            filter: c => c.hitsMax > 100 &&
                !c.isUnderRampart &&
                !c.pos.isRoomEdge &&
                !c.isNPC &&
                c.attackPower + c.rangedAttackPower + c.healPower > 0
        }) ||
            creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
                range: 1,
                filter: c => c.hitsMax > 100 && !c.isUnderRampart && !c.pos.isRoomEdge && c.owner.username !== USERNAME.SOURCE_KEEPER
            }) ||
            creep.pos.findClosestByPath(FIND_HOSTILE_POWER_CREEPS, {
                range: 1,
                filter: c => c.hitsMax > 100 && !c.isUnderRampart
            });
        if (!hostile) {
            return false;
        }
        const target = (creep.pos.rampart
            ? hostile
            : hostile.pos
                .findInRange(FIND_MY_STRUCTURES, 1)
                .find(s => s.structureType === STRUCTURE_RAMPART && !s.pos.creep)) || hostile;
        const distance = creep.pos.getRangeTo(target);
        if (distance === 1) {
            if (creep.pos.rampart) {
                return true;
            }
            creep.moveTo(target, {
                ignoreCreeps: false,
                costCallback: (roomName, costMatrix) => {
                    Geo.roomEdges(1).forEach(pos => {
                        costMatrix.set(pos.x, pos.y, 50);
                    });
                    return costMatrix;
                }
            });
        }
        else {
            creep.travel(target, {
                range: 0,
                ignoreCreeps: true
            });
        }
        return true;
    }
    static moveToNpcHostiles(creep) {
        const hostile = creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
            range: 1,
            filter: c => c.hitsMax > 100 && !c.isUnderRampart && c.owner.username === USERNAME.SOURCE_KEEPER
        });
        if (!hostile)
            return false;
        if (creep.pos.getRangeTo(hostile) === 1 &&
            (hostile.pos.x === 49 || hostile.pos.x === 0 || hostile.pos.y === 49 || hostile.pos.y === 0)) {
            return false;
        }
        creep.travel(hostile, {
            range: 0
        });
        return true;
    }
    static getKiteRange(creep) {
        if (creep.rangedAttackPower > 20) {
            return 5;
        }
        if (creep.attackPower > 20) {
            return 3;
        }
        return 3;
    }
    static creepHasDeadBoostedToughParts(creep) {
        return creep.body.filter(b => b.type === TOUGH && b.boost && b.hits === 0).length > 0;
    }
    static hasHostileMeleClose(creep) {
        return (creep.pos.findInRange(FIND_HOSTILE_CREEPS, 2, {
            filter: c => c.attackPower > creep.rangedAttackPower && c.owner.username !== USERNAME.SOURCE_KEEPER
        }).length > 0);
    }
    static hostileRangedPowerInRange(creep) {
        return creep.pos.findInRange(FIND_HOSTILE_CREEPS, 5).reduce((total, c) => {
            if (c.owner.username === USERNAME.SOURCE_KEEPER) {
                return total;
            }
            return total + c.rangedAttackPower;
        }, 0);
    }
    static shouldKite(creep) {
        if (this.hasHostileMeleClose(creep)) {
            return true;
        }
        if (creep.rangedAttackPower < this.hostileRangedPowerInRange(creep) && this.creepHasDeadBoostedToughParts(creep)) {
            return true;
        }
        return false;
    }
    static kiteBack(creep) {
        if (!this.shouldKite(creep)) {
            return false;
        }
        const path = PathFinder.search(creep.pos, creep.room
            .find(FIND_HOSTILE_CREEPS)
            .filter(c => c.attackPower || c.rangedAttackPower)
            .map(c => ({ pos: c.pos, range: this.getKiteRange(c) })), {
            flee: true,
            swampCost: 10,
            plainCost: 1,
            roomCallback(roomName) {
                const room = Game.rooms[roomName];
                if (!room)
                    return true;
                const matrix = new PathFinder.CostMatrix();
                room.edgePositions.forEach(p => matrix.set(p.pos.x, p.pos.y, 254));
                room
                    .find(FIND_STRUCTURES)
                    .filter(s => s.structureType === STRUCTURE_WALL)
                    .forEach(wall => matrix.set(wall.pos.x, wall.pos.y, 254));
                room.find(FIND_CREEPS).forEach(c => matrix.set(c.pos.x, c.pos.y, 254));
                return matrix;
            }
        });
        if (!path || path.incomplete) {
            if (creep.homeRoom && creep.homeRoom.storage) {
                creep.travel(creep.homeRoom.storage);
                return true;
            }
            else {
                return false;
            }
        }
        creep.moveByPath(path.path);
        return true;
    }
    static selfHeal(creep) {
        const hostileTowers = creep.room.find(FIND_HOSTILE_STRUCTURES).filter(s => s.structureType === STRUCTURE_TOWER);
        const hostileCreeps = creep.room.find(FIND_HOSTILE_CREEPS);
        if (hostileCreeps.length + hostileTowers.length === 0)
            return false;
        creep.heal(creep);
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], Attacker, "handleCreep", null);

const CONFIG$j = Config.BaseGclFarmHauler;
class GclFarmHauler {
    static handle() {
        Creeps.getByRole(CONFIG$j.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$j.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        creep.recycleFinal(150) || this.withdrawEnergyFromHomeStorage(creep) || this.storeEnergyToTargetRoomStorage(creep);
    }
    static handleSpawn() {
        Rooms.myRooms.forEach(room => {
            var _a;
            if (!room.isGclFarm) {
                return;
            }
            if (room.isAbandoning) {
                return;
            }
            if (room.gclMasterRooms.length === 0) {
                return;
            }
            if (room.level < 4 && !room.terminal) {
                // replace with missing energy for lvl 6 upgrade
                return;
            }
            if (!room.controller) {
                return;
            }
            if (!room.storage) {
                return;
            }
            if (room.storage.store.energy > 300000) {
                return;
            }
            if (this.isTerminalActive(room)) {
                return;
            }
            const energyToLevel6 = this.calculateEnergyToLevel6(room.controller);
            if (room.storage.store.energy + (((_a = room.terminal) === null || _a === void 0 ? void 0 : _a.store.energy) || 0) >= energyToLevel6) {
                return;
            }
            if (room.storage.store.getFreeCapacity(RESOURCE_ENERGY) < 100000) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({
                minTicksToLive: 300,
                role: CONFIG$j.roleName,
                targetRoom: room.name
            });
            if (creepsCount >= 10) {
                return;
            }
            Spawns.addToQue(room.gclMasterRooms, {
                body: BodyParts.new().move(25).carry(25),
                priority: CONFIG$j.spawnPriority,
                role: CONFIG$j.roleName,
                memory: {
                    targetRoom: room.name
                }
            });
        });
    }
    static calculateEnergyToLevel6(controller) {
        if (controller.level >= 6) {
            return 0;
        }
        let points = controller.progressTotal - controller.progress;
        if (controller.level === 5) {
            return points;
        }
        points += CONTROLLER_LEVELS[5];
        if (controller.level === 4) {
            return points;
        }
        points += CONTROLLER_LEVELS[4];
        if (controller.level === 3) {
            return points;
        }
        points += CONTROLLER_LEVELS[3];
        if (controller.level === 2) {
            return points;
        }
        points += CONTROLLER_LEVELS[2];
        return points;
    }
    static isTerminalActive(room) {
        return room.level > 5 && room.terminal instanceof StructureTerminal;
    }
    static storeEnergyToTargetRoomStorage(creep) {
        if (creep.store.getUsedCapacity() === 0) {
            return false;
        }
        if (!creep.targetRoom) {
            return false;
        }
        if (!creep.targetRoom.storage) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.targetRoom.storage);
        if (distance > 2) {
            creep.travel(creep.targetRoom.storage);
        }
        else if (distance > 1) {
            creep.travel(creep.targetRoom.storage, { freshPath: true, ignoreCreeps: false });
        }
        else {
            creep.transfer(creep.targetRoom.storage, RESOURCE_ENERGY);
        }
        return true;
    }
    static withdrawEnergyFromHomeStorage(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (!creep.homeRoom) {
            return false;
        }
        if (!creep.homeRoom.storage) {
            return false;
        }
        if (creep.withdraw(creep.homeRoom.storage, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.homeRoom.storage);
        }
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], GclFarmHauler, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], GclFarmHauler, "handleSpawn", null);

const CONFIG$i = Config.BaseGclFarmUpgrader;
class GclFarmUpgrader {
    static handle() {
        Creeps.getByRole(CONFIG$i.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$i.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        this.unboost(creep, 20);
        this.unloadEnergy(creep, 2) ||
            this.pickupBoosts(creep, 20) ||
            this.storeBoosts(creep, 20) ||
            this.withdrawFromTerminal(creep) ||
            this.withdrawFromStorage(creep);
        this.buildStructures(creep) || this.upgradeController(creep);
        creep.boost() ||
            this.die(creep) ||
            this.moveToTargetRoom(creep) ||
            this.isInGoodPosition(creep) ||
            // this.moveNearTerminal(creep) ||
            this.moveNearStorage(creep);
    }
    static unboost(creep, maxTicks) {
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > maxTicks) {
            return false;
        }
        if (!creep.isBoosted()) {
            return false;
        }
        const lab = creep.pos.findInRange(FIND_MY_STRUCTURES, 1, {
            filter: s => s.structureType === STRUCTURE_LAB && !s.cooldown
        })[0];
        if (!lab) {
            return false;
        }
        lab.unboostCreep(creep);
        return true;
    }
    static unloadEnergy(creep, maxTicks) {
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > maxTicks) {
            return false;
        }
        const resource = Resources.firstStoreResource(creep.store);
        if (!resource) {
            return true;
        }
        const storage = creep.pos.findInRange(FIND_STRUCTURES, 1, {
            filter: s => (s.structureType === STRUCTURE_TERMINAL || s.structureType === STRUCTURE_STORAGE) &&
                s.store.getFreeCapacity() > 10 &&
                s.isActive()
        })[0];
        if (!storage) {
            return true;
        }
        creep.transfer(storage, resource);
        return true;
    }
    static storeBoosts(creep, maxTicks) {
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > maxTicks) {
            return false;
        }
        const resource = Object.keys(creep.store).find(r => r !== RESOURCE_ENERGY);
        if (!resource) {
            return false;
        }
        const storage = creep.pos.findInRange(FIND_STRUCTURES, 1, {
            filter: s => (s.structureType === STRUCTURE_TERMINAL || s.structureType === STRUCTURE_STORAGE) &&
                s.store.getFreeCapacity() > 10 &&
                s.isActive()
        })[0];
        if (!storage) {
            return false;
        }
        creep.transfer(storage, resource);
        return true;
    }
    static pickupBoosts(creep, maxTicks) {
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > maxTicks) {
            return false;
        }
        if (creep.store.getFreeCapacity() < 10) {
            return false;
        }
        const droppedResource = creep.pos.findInRange(FIND_DROPPED_RESOURCES, 1)[0];
        if (!droppedResource) {
            return false;
        }
        creep.pickup(droppedResource);
        return true;
    }
    static die(creep) {
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > 3) {
            return false;
        }
        const storage = creep.pos.findInRange(FIND_MY_STRUCTURES, 1, {
            filter: s => (s.structureType === STRUCTURE_STORAGE || s.structureType === STRUCTURE_TERMINAL) &&
                s.store.getFreeCapacity() >= 200 &&
                s.cachedIsActive()
        })[0];
        if (!storage) {
            return false;
        }
        if (creep.store.energy > 0) {
            creep.transfer(storage, RESOURCE_ENERGY);
            return true;
        }
        creep.suicide();
        return true;
    }
    static buildStructures(creep) {
        const construction = creep.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 3, {
            filter: s => s.structureType === STRUCTURE_TERMINAL || s.structureType === STRUCTURE_STORAGE
        })[0];
        if (!construction) {
            return false;
        }
        creep.build(construction);
        return true;
    }
    static moveToTargetRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        if (creep.memory.targetRoom === creep.room.name) {
            return false;
        }
        return creep.travelToRoom(creep.memory.targetRoom);
    }
    static withdrawFromTerminal(creep) {
        if (creep.store.energy > creep.body.filter(b => b.type === WORK).length * 2) {
            return false;
        }
        const terminal = creep.pos.findInRange(FIND_STRUCTURES, 1, {
            filter: s => s.structureType === STRUCTURE_TERMINAL && s.store.energy >= 100
        })[0];
        if (!terminal) {
            return false;
        }
        creep.withdraw(terminal, RESOURCE_ENERGY);
        return true;
    }
    static withdrawFromStorage(creep) {
        if (creep.store.energy > creep.body.filter(b => b.type === WORK).length * 2) {
            return false;
        }
        const storage = creep.pos.findInRange(FIND_STRUCTURES, 1, {
            filter: s => s.structureType === STRUCTURE_STORAGE && s.store.energy >= 100
        })[0];
        if (!storage) {
            return false;
        }
        creep.withdraw(storage, RESOURCE_ENERGY);
        return true;
    }
    static handleSpawn() {
        Rooms.myRooms.forEach(room => {
            if (!room.isGclFarm) {
                return;
            }
            if (room.gclMasterRooms.length === 0) {
                return;
            }
            if (room.isAbandoning) {
                return;
            }
            if (!room.storage) {
                return;
            }
            if (room.storage.store.energy < 50000) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({
                minTicksToLive: 250,
                targetRoom: room.name,
                role: CONFIG$i.roleName
            });
            const spots = this.openSpots(room) - 2;
            const averageEnergy = room.gclMasterRooms.reduce((total, r) => { var _a; return total + (((_a = r.storage) === null || _a === void 0 ? void 0 : _a.store.energy) || 0); }, 0) /
                room.gclMasterRooms.length;
            const maxCreeps = Math.min(spots, averageEnergy / 20000);
            if (creepsCount >= maxCreeps) {
                return;
            }
            for (let i = 0; i < maxCreeps - creepsCount; i++) {
                Spawns.addToQue(room.gclMasterRooms, {
                    body: BodyParts.new().move(25).work(23).carry(2),
                    boosts: this.roomBoosts(room.gclMasterRooms[0]),
                    memory: {
                        targetRoom: room.name,
                        stationary: true
                    },
                    priority: room.level === 8 ? 0 /* Highest */ : 6 /* Lowest */,
                    role: CONFIG$i.roleName
                });
            }
        });
    }
    static roomBoosts(room) {
        if (room.level < 6) {
            return [BOOST_ALIAS.UPGRADE_3, BOOST_ALIAS.UPGRADE_2, BOOST_ALIAS.UPGRADE_1];
        }
        const boosts = [];
        if (room.storage) {
            if (room.storage.store[BOOST_ALIAS.UPGRADE_3] > 1000) {
                boosts.push(BOOST_ALIAS.UPGRADE_3);
            }
            if (room.storage.store[BOOST_ALIAS.UPGRADE_2] > 1000) {
                boosts.push(BOOST_ALIAS.UPGRADE_2);
            }
            if (room.storage.store[BOOST_ALIAS.UPGRADE_1] > 1000) {
                boosts.push(BOOST_ALIAS.UPGRADE_1);
            }
        }
        return boosts;
    }
    static openSpots(room) {
        const controller = room.controller;
        if (!controller) {
            return 0;
        }
        const spots = {};
        if (room.storage && room.storage.store.energy > 100000) {
            room.storage.pos.openSpots.forEach(pos => {
                if (!controller.pos.inRangeTo(pos, 3)) {
                    return;
                }
                spots[`${pos.x}-${pos.y}`] = "nice";
            });
        }
        if (room.terminal && room.terminal.isActive() && room.terminal.store.energy > 100000) {
            room.terminal.pos.openSpots.forEach(pos => {
                if (!controller.pos.inRangeTo(pos, 3)) {
                    return;
                }
                spots[`${pos.x}-${pos.y}`] = "nice";
            });
        }
        return Object.keys(spots).length;
    }
    static isInGoodPosition(creep) {
        if (!creep.room.controller) {
            return false;
        }
        if (creep.pos.lookFor(LOOK_FLAGS).length > 0) {
            return false;
        }
        return (!!(creep.room.terminal &&
            creep.room.terminal.store.energy > 200 &&
            creep.pos.inRangeTo(creep.room.terminal, 1)) || !!(creep.room.storage && creep.room.storage.store.energy > 200 && creep.pos.inRangeTo(creep.room.storage, 1)));
    }
    static moveNearStorage(creep) {
        if (!creep.room.controller) {
            return false;
        }
        if (!creep.room.center) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        const storages = creep.room.controller.pos.findInRange(FIND_STRUCTURES, 5, {
            filter: s => (s.structureType === STRUCTURE_STORAGE || s.structureType === STRUCTURE_TERMINAL) && s.store.energy > 100
        });
        if (storages.length === 0) {
            return false;
        }
        const controller = creep.room.controller;
        const openPosition = storages
            .map(p => p.pos.openSpots)
            .reduce((value, poses) => {
            value.push(...poses);
            return value;
        }, [])
            .filter(pos => !pos.isRoomEdge)
            .filter(pos => pos.inRangeTo(controller, 3))
            .filter(pos => !pos.hasCreep)
            .filter(pos => pos.lookFor(LOOK_FLAGS).filter(f => f.color === COLOR_WHITE && f.secondaryColor === COLOR_GREY).length === 0)
            .filter(pos => !controller.room.center || !pos.isEqualTo(controller.room.center))
            .sort((a, b) => a.getRangeTo(controller) - b.getRangeTo(controller))[0];
        if (!openPosition) {
            return false;
        }
        creep.travel({ pos: openPosition }, { range: 0, ignoreCreeps: false });
        return true;
    }
    static upgradeController(creep) {
        if (creep.store.energy === 0) {
            return false;
        }
        if (!creep.room.controller) {
            return false;
        }
        if (!creep.room.controller.my) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.controller);
        if (distance > 3) {
            return false;
        }
        creep.upgradeController(creep.room.controller);
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], GclFarmUpgrader, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], GclFarmUpgrader, "handleSpawn", null);

const CONFIG$h = Config.BaseGclFarmCenterBalancer;
class GclFarmCenterBalancer {
    static handle() {
        Creeps.getByRole(CONFIG$h.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$h.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        this.moveToCenter(creep);
        this.renewCreep(creep);
        // suicide if room level under 6
        if (this.suicide(creep)) {
            return;
        }
        if (creep.idle()) {
            return;
        }
        if (creep.store.getUsedCapacity() === 0) {
            this.withdrawEnergyFromLink(creep) ||
                this.withdrawEnergyFromTerminal(creep) ||
                this.withdrawResourcesFromStorage(creep) ||
                this.goIdle(creep);
        }
        else {
            this.storeEnergyToSpawn(creep) ||
                this.storeEnergyToStorage(creep) ||
                this.storeEnergyToTerminal(creep) ||
                this.storeResourcesToTerminal(creep) ||
                this.goIdle(creep);
        }
    }
    static handleSpawn() {
        Rooms.myRooms.forEach(room => {
            if (!room.storage) {
                return;
            }
            if (!room.isGclFarm) {
                return;
            }
            if (!room.terminal) {
                return;
            }
            if (room.level < 6) {
                return;
            }
            if (!room.center) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({ homeRoom: room.name, role: CONFIG$h.roleName });
            if (creepsCount >= 1) {
                return;
            }
            Spawns.addToQue(room, {
                body: BodyParts.new().move(1).carry(4),
                optionalBody: BodyParts.new().carry(16),
                priority: CONFIG$h.spawnPriority,
                role: CONFIG$h.roleName,
                directionToCenter: true,
                memory: { stationary: true }
            });
        });
    }
    static goIdle(creep) {
        creep.memory.idleUntill = Game.time + 20;
    }
    static storeResourcesToTerminal(creep) {
        if (!creep.room.terminal) {
            return false;
        }
        if (!creep.room.terminal.isActive()) {
            return false;
        }
        const resource = Object.keys(creep.store).find(s => s !== RESOURCE_ENERGY);
        if (!resource) {
            return false;
        }
        creep.transfer(creep.room.terminal, resource);
        return true;
    }
    static withdrawResourcesFromStorage(creep) {
        if (!creep.room.terminal) {
            return false;
        }
        if (!creep.room.terminal.isActive()) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        if (creep.pos.getRangeTo(creep.room.storage) > 1) {
            return false;
        }
        const resource = Object.keys(creep.room.storage.store).find(s => s !== RESOURCE_ENERGY);
        if (!resource) {
            return false;
        }
        creep.withdraw(creep.room.storage, resource);
        return true;
    }
    static suicide(creep) {
        if (creep.store.energy > 0) {
            return false;
        }
        if (creep.ticksToLive && creep.ticksToLive < 10) {
            creep.die();
            return true;
        }
        if (creep.room.level < 6) {
            creep.die();
            return true;
        }
        return false;
    }
    static withdrawEnergyFromLink(creep) {
        const link = creep.pos.findInRange(FIND_MY_STRUCTURES, 1, {
            filter: s => s.structureType === STRUCTURE_LINK && s.cachedIsActive() && s.store.energy >= 200
        })[0];
        if (!link) {
            return false;
        }
        creep.withdraw(link, RESOURCE_ENERGY);
        return true;
    }
    static withdrawEnergyFromTerminal(creep) {
        if (!creep.room.terminal) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        if (creep.room.terminal.store.energy < 50000) {
            return false;
        }
        if (creep.room.storage.store.getFreeCapacity(RESOURCE_ENERGY) < 5000) {
            return false;
        }
        creep.withdraw(creep.room.terminal, RESOURCE_ENERGY);
        return true;
    }
    static moveToCenter(creep) {
        if (!creep.room.center) {
            return false;
        }
        if (creep.pos.isEqualTo(creep.room.center)) {
            return false;
        }
        const blockingCreep = creep.room.center.lookFor(LOOK_CREEPS)[0];
        if (blockingCreep) {
            blockingCreep.moveTo(creep);
        }
        creep.moveTo(creep.room.center);
        return true;
    }
    static renewCreep(creep) {
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > 1300) {
            return false;
        }
        if (creep.store.getCapacity() < 1000) {
            return false;
        }
        const spawns = creep.room
            .find(FIND_MY_SPAWNS)
            .filter(s => s.spawning === null && !s.actionPending && s.store.energy >= 100 && s.cachedIsActive());
        if (spawns.length === 0) {
            return false;
        }
        for (const spawn of spawns) {
            if (spawn.renewCreepV2(creep)) {
                return true;
            }
        }
        return false;
    }
    static storeEnergyToSpawn(creep) {
        if (creep.store.energy === 0) {
            return false;
        }
        const spawn = creep.pos.findInRange(FIND_MY_SPAWNS, 1, {
            filter: s => s.store.getFreeCapacity(RESOURCE_ENERGY) > 0
        })[0];
        if (!spawn) {
            return false;
        }
        creep.transfer(spawn, RESOURCE_ENERGY);
        return true;
    }
    static storeEnergyToStorage(creep) {
        if (creep.store.energy === 0) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.storage);
        if (distance > 1) {
            return false;
        }
        creep.transfer(creep.room.storage, RESOURCE_ENERGY);
        return true;
    }
    static storeEnergyToTerminal(creep) {
        if (creep.store.energy === 0) {
            return false;
        }
        if (!creep.room.terminal) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.terminal);
        if (distance > 1) {
            return false;
        }
        creep.transfer(creep.room.terminal, RESOURCE_ENERGY);
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], GclFarmCenterBalancer, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], GclFarmCenterBalancer, "handleSpawn", null);

class DisableCreepNotifications {
    static handle() {
        General.interval(10, () => {
            Creeps.myCreeps.forEach(creep => {
                if (!creep.ticksToLive) {
                    return;
                }
                if (creep.memory.notificationsDisabled) {
                    return;
                }
                const response = creep.notifyWhenAttacked(false);
                if (response === OK) {
                    creep.memory.notificationsDisabled = true;
                }
                else {
                    Log.object(creep, "failed to turn of notifications for creep, code ", response);
                }
            });
        });
    }
}

const CONFIG$g = Config.BaseNewbieHauler;
class Spawner {
    static handle() {
        if (!General.expansionWithSupport()) {
            return;
        }
        Rooms.myRooms.forEach(room => {
            this.homeRoomSpawner(room);
        });
    }
    static homeRoomSpawner(room) {
        if (room.isGclFarm) {
            return;
        }
        if (room.mySpawns.length === 0) {
            return;
        }
        if (room.level < 1) {
            return;
        }
        if (room.level >= 6 && room.terminal) {
            return;
        }
        if (room.storage && room.storage.store.energy > 200000) {
            return;
        }
        if (room.isAbandoning) {
            return;
        }
        const spawnRooms = Geo.closestHomeRoomsByRange(room.name, 4, {
            maxDistance: MAX_EXPANSION_RANGE * 1.5,
            room: r => r.level >= 8 && r.storage !== undefined && r.storage.store.energy > 80000
        });
        if (spawnRooms.length === 0) {
            return;
        }
        for (let i = 0; i < 10; i++) {
            Spawns.addToQue(spawnRooms, {
                body: BodyParts.new().addMultiple([CARRY, MOVE], 25),
                role: CONFIG$g.roleName,
                priority: 6 /* Lowest */,
                memory: { targetRoom: room.name }
            });
        }
        spawnRooms.forEach(r => {
            r.mem.increasedSpawnUntil = Game.time + 1500;
        });
    }
}
class Worker {
    static handle(creep) {
        this.withdrawEnergy(creep) ||
            this.travelToTargetRoom(creep) ||
            // this.transferToTargetControllerContainer(creep) ||
            // this.transferToTargetStorage(creep) ||
            // this.pickTombstones(creep) ||
            this.suicide(creep);
    }
    static suicide(creep) {
        var _a;
        if (creep.room.name !== ((_a = creep.targetRoom) === null || _a === void 0 ? void 0 : _a.name)) {
            return false;
        }
        creep.recycleFinal(1500);
        return true;
    }
    static pickTombstones(creep) {
        var _a;
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (creep.room.name !== ((_a = creep.targetRoom) === null || _a === void 0 ? void 0 : _a.name)) {
            return false;
        }
        const tombstone = creep.pos.findInRange(FIND_TOMBSTONES, 5, { filter: t => t.store.energy > 50 })[0];
        if (!tombstone) {
            return false;
        }
        const distance = creep.pos.getRangeTo(tombstone);
        if (distance > 1) {
            creep.travel(tombstone);
        }
        else {
            creep.withdraw(tombstone, RESOURCE_ENERGY);
        }
        return true;
    }
    static transferToTargetStorage(creep) {
        var _a;
        if (creep.store.energy === 0) {
            return false;
        }
        if (creep.room.name !== ((_a = creep.targetRoom) === null || _a === void 0 ? void 0 : _a.name)) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.storage);
        if (distance > 1) {
            creep.travel(creep.room.storage);
        }
        else {
            creep.transfer(creep.room.storage, RESOURCE_ENERGY);
        }
        return true;
    }
    static transferToTargetControllerContainer(creep) {
        var _a;
        if (creep.store.energy === 0) {
            return false;
        }
        if (creep.room.name !== ((_a = creep.targetRoom) === null || _a === void 0 ? void 0 : _a.name)) {
            return false;
        }
        if (!creep.room.controller) {
            return false;
        }
        const container = creep.room.controller.pos
            .findInRange(FIND_STRUCTURES, 3, {
            filter: s => s.structureType === STRUCTURE_CONTAINER && s.store.getFreeCapacity() > 500
        })
            .sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep))[0];
        if (!container) {
            return false;
        }
        const distance = creep.pos.getRangeTo(container);
        if (distance > 1) {
            creep.travel(container);
        }
        else {
            creep.transfer(container, RESOURCE_ENERGY);
        }
        return true;
    }
    static travelToTargetRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        return creep.travelToRoom(creep.memory.targetRoom, { ignoreHostiles: false });
    }
    static withdrawEnergy(creep) {
        var _a;
        if (creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {
            return false;
        }
        if (((_a = creep.homeRoom) === null || _a === void 0 ? void 0 : _a.name) !== creep.room.name) {
            return false;
        }
        if (!creep.room.storage) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.storage);
        if (distance > 1) {
            creep.travel(creep.room.storage);
        }
        else {
            creep.withdraw(creep.room.storage, RESOURCE_ENERGY);
        }
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], Worker, "handle", null);
class BaseNewbieHauler {
    static handle() {
        Creeps.getByRole(CONFIG$g.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            ProfilerLegacy2.creepTick(BaseNewbieHauler.name);
            General.visualCreepCpu(creep, () => Worker.handle(creep));
        });
        General.interval(100, () => TickAction.add(() => Spawner.handle()));
    }
}

const CONFIG$f = Config.BaseGclFarmResetter;
class GclFarmResetter {
    static handle() {
        Creeps.getByRole(CONFIG$f.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$f.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        if (!creep.room.isGclFarm) {
            Log.object(creep, "GclFarmResetter", "creep trying to reset not gcl farm room jesus crist");
            return;
        }
        this.moveToController(creep) || this.unclaim(creep) || this.claim(creep) || creep.die();
    }
    static moveToController(creep) {
        if (!creep.room.controller) {
            Log.object(creep, "GclFarmResetter", "nigga missing controller");
            return true;
        }
        const distance = creep.pos.getRangeTo(creep.room.controller);
        if (distance <= 1) {
            return false;
        }
        creep.moveTo(creep.room.controller, { ignoreCreeps: true });
        creep.pos.findInRange(FIND_MY_CREEPS, 1, { filter: c => c.id !== creep.id }).forEach(c => c.moveTo(creep));
        return true;
    }
    static claim(creep) {
        var _a;
        if (!creep.room.controller) {
            Log.object(creep, "GclFarmResetter", "nigga missing controller");
            return true;
        }
        if (((_a = creep.room.controller.owner) === null || _a === void 0 ? void 0 : _a.username) === USERNAME.ME) {
            return false;
        }
        creep.claimController(creep.room.controller);
        return true;
    }
    static unclaim(creep) {
        var _a;
        if (!creep.room.controller) {
            Log.object(creep, "GclFarmResetter", "nigga missing controller");
            return true;
        }
        if (creep.room.controller.level < 7) {
            return false;
        }
        if (((_a = creep.room.controller.owner) === null || _a === void 0 ? void 0 : _a.username) !== USERNAME.ME) {
            return false;
        }
        creep.room.controller.unclaim();
        return true;
    }
    static handleSpawn() {
        Rooms.myRooms.forEach(room => {
            if (!room.isGclFarm) {
                return;
            }
            if (room.isAbandoning) {
                return;
            }
            if (!room.controller) {
                return;
            }
            if (!room.controller.my) {
                return;
            }
            if (room.controller.level < 7) {
                return;
            }
            if (room.controller.level === 7 && room.controller.progressTotal - room.controller.progress > 300000) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({
                minTicksToLive: 0,
                targetRoom: room.name,
                role: CONFIG$f.roleName
            });
            if (creepsCount >= 1) {
                return;
            }
            Spawns.addToQue(room, {
                body: BodyParts.new().claim().move(),
                boosts: [],
                memory: {
                    targetRoom: room.name,
                    stationary: true
                },
                priority: 0 /* Highest */,
                role: CONFIG$f.roleName
            });
        });
    }
}
__decorate([
    Profiler.subprofile("creep")
], GclFarmResetter, "handleCreep", null);

const CONFIG$e = Config.Stronghold1Attacker;
class Stronghold1Attacker {
    static handle() {
        Creeps.getByRole(CONFIG$e.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.work(creep);
        });
        General.interval(50, () => TickAction.add(() => this.spawn()));
    }
    static work(creep) {
        creep.heal(creep);
        creep.rangedBestAttack() || this.attackContainer(creep) || this.attackRoad(creep);
        creep.boost({ minTicksToLive: 1000 }) ||
            this.moveToRoom(creep) ||
            this.moveToCore(creep) ||
            this.moveToRampart(creep) ||
            this.moveToContainer(creep) ||
            this.moveToRoad(creep) ||
            this.moveToHostiles(creep);
    }
    static spawn() {
        Object.values(Memory.strongholds).forEach(stronghold => {
            if (stronghold.level !== 1) {
                return;
            }
            if (!stronghold.isAlive) {
                return;
            }
            if (stronghold.startsAt) {
                return;
            }
            if (stronghold.attackerCount > stronghold.attackerCountMax) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({ role: CONFIG$e.roleName, targetRoom: stronghold.targetRoom });
            if (creepsCount >= 1) {
                return;
            }
            const spawnRooms = stronghold.homeRooms.map(roomName => Game.rooms[roomName]).filter(Boolean);
            if (spawnRooms.length === 0) {
                return;
            }
            Spawns.addToQue(spawnRooms, {
                body: BodyParts.new().rangedAttack(12).move(25).heal(13),
                boosts: [RESOURCE_CATALYZED_KEANIUM_ALKALIDE, RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE],
                priority: 3 /* Medium */,
                role: CONFIG$e.roleName,
                memory: {
                    targetRoom: stronghold.targetRoom
                }
            });
            stronghold.attackerCount++;
        });
    }
    static moveToHostiles(creep) {
        const hostile = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
        if (!hostile) {
            return false;
        }
        creep.travel(hostile, { range: 3 });
        return true;
    }
    static moveToContainer(creep) {
        const container = creep.pos.findClosestByRange(FIND_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_CONTAINER && s.ticksToDecay && s.ticksToDecay > 5000
        });
        if (!container) {
            return false;
        }
        creep.travel(container);
        return true;
    }
    static moveToRoad(creep) {
        const road = creep.pos.findClosestByRange(FIND_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_ROAD && s.ticksToDecay && s.ticksToDecay > 5000
        });
        if (!road) {
            return false;
        }
        creep.travel(road);
        return true;
    }
    static attackContainer(creep) {
        const container = creep.pos.findInRange(FIND_STRUCTURES, 3, {
            filter: s => s.structureType === STRUCTURE_CONTAINER && s.ticksToDecay && s.ticksToDecay > 5000
        })[0];
        if (!container) {
            return false;
        }
        creep.rangedAttack(container);
        return true;
    }
    static attackRoad(creep) {
        const road = creep.pos.findInRange(FIND_STRUCTURES, 3, {
            filter: s => s.structureType === STRUCTURE_ROAD && s.ticksToDecay && s.ticksToDecay > 5000
        })[0];
        if (!road) {
            return false;
        }
        creep.rangedAttack(road);
        return true;
    }
    static moveToRampart(creep) {
        const rampart = creep.pos.findClosestByRange(FIND_HOSTILE_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_RAMPART
        });
        if (!rampart) {
            return false;
        }
        creep.travel(rampart);
        return true;
    }
    static moveToCore(creep) {
        if (!creep.room.invaderCore) {
            return false;
        }
        if (creep.pos.getRangeTo(creep.room.invaderCore) <= 1) {
            return true;
        }
        creep.travel(creep.room.invaderCore);
        return true;
    }
    static moveToRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        return creep.travelToRoom(creep.memory.targetRoom);
    }
}
__decorate([
    Profiler.subprofile("creep")
], Stronghold1Attacker, "work", null);
__decorate([
    Profiler.subprofile("spawn")
], Stronghold1Attacker, "spawn", null);

const CONFIG$d = Config.Stronghold2Attacker;
class Stronghold2Attacker {
    static handle() {
        Creeps.getByRole(CONFIG$d.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.work(creep);
        });
        General.interval(50, () => TickAction.add(() => this.spawn()));
    }
    static work(creep) {
        creep.healMele() || creep.prehealMele();
        this.snipeCore(creep) || creep.rangedBestAttack();
        creep.boost({ minTicksToLive: 1000 }) ||
            this.moveToRoom(creep) ||
            this.kiteBack(creep) ||
            this.moveToSnipePosition(creep) ||
            this.moveToHostileStructures(creep) ||
            this.moveToHostiles(creep);
    }
    static spawn() {
        Object.values(Memory.strongholds).forEach(stronghold => {
            if (stronghold.level !== 2) {
                return;
            }
            if (!stronghold.isAlive) {
                return;
            }
            if (stronghold.startsAt) {
                return;
            }
            if (stronghold.attackerCount > stronghold.attackerCountMax) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({ role: CONFIG$d.roleName, targetRoom: stronghold.targetRoom });
            if (creepsCount >= 1) {
                return;
            }
            const spawnRooms = stronghold.homeRooms.map(roomName => Game.rooms[roomName]).filter(Boolean);
            if (spawnRooms.length === 0) {
                return;
            }
            Spawns.addToQue(spawnRooms, {
                body: BodyParts.new().tough(5).rangedAttack(10).move(25).heal(10),
                boosts: [
                    RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
                    RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
                    RESOURCE_CATALYZED_GHODIUM_ALKALIDE
                ],
                priority: 3 /* Medium */,
                role: CONFIG$d.roleName,
                memory: {
                    targetRoom: stronghold.targetRoom
                }
            });
            stronghold.attackerCount++;
        });
    }
    static snipeCore(creep) {
        if (!creep.room.invaderCore) {
            return false;
        }
        if (creep.pos.getRangeTo(creep.room.invaderCore) > 3) {
            return false;
        }
        creep.rangedAttack(creep.room.invaderCore);
        return true;
    }
    static moveToHostiles(creep) {
        const hostile = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
        if (!hostile) {
            return false;
        }
        creep.travel(hostile, { range: 3 });
        return true;
    }
    static mostEffectiveDamagePos(creep) {
        const stronghold = Memory.strongholds[creep.room.name];
        if (!stronghold) {
            return undefined;
        }
        const coordinates = [];
        const minX = Math.max(stronghold.pos.x - 3, 1);
        const maxX = Math.min(stronghold.pos.x + 3, 48);
        const minY = Math.max(stronghold.pos.y - 3, 1);
        const maxY = Math.min(stronghold.pos.y + 3, 48);
        for (let x = minX; x <= maxX; x++) {
            for (let y = minY; y <= maxY; y++) {
                const pos = new RoomPosition(x, y, creep.room.name);
                const structures = pos
                    .lookFor(LOOK_STRUCTURES)
                    .filter(s => s.structureType !== STRUCTURE_ROAD && s.structureType !== STRUCTURE_CONTAINER);
                if (structures.length > 0)
                    continue;
                const suroundingStructures = pos
                    .findInRange(FIND_STRUCTURES, 1)
                    .filter(s => s.structureType === STRUCTURE_RAMPART);
                if (suroundingStructures.length >= 8)
                    continue;
                const creeps = pos.lookFor(LOOK_CREEPS).filter(c => c.id !== creep.id);
                if (creeps.length > 0)
                    continue;
                coordinates.push(pos);
            }
        }
        return coordinates.sort((a, b) => {
            const rampartsInRangeA = a
                .findInRange(FIND_HOSTILE_STRUCTURES, 3)
                .filter(s => s.structureType === STRUCTURE_RAMPART)
                .reduce((totalDmg, struct) => {
                const range = a.getRangeTo(struct);
                return totalDmg + 1000 * (MASS_RANGED_ATTACK_DECAY[range] || 0);
            }, 0);
            const rampartsInRangeB = b
                .findInRange(FIND_HOSTILE_STRUCTURES, 3)
                .filter(s => s.structureType === STRUCTURE_RAMPART)
                .reduce((totalDmg, struct) => {
                const range = b.getRangeTo(struct);
                return totalDmg + 1000 * (MASS_RANGED_ATTACK_DECAY[range] || 0);
            }, 0);
            return rampartsInRangeB - rampartsInRangeA;
        })[0];
    }
    static hasHostileStructures(creep) {
        return (creep.room
            .find(FIND_HOSTILE_STRUCTURES)
            .filter(s => s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_TOWER).length > 0);
    }
    static moveToHostileStructures(creep) {
        if (!this.hasHostileStructures(creep)) {
            return false;
        }
        const bestPos = this.mostEffectiveDamagePos(creep);
        if (!bestPos) {
            return false;
        }
        creep.travel({ pos: bestPos });
        return true;
    }
    static moveToSnipePosition(creep) {
        if (!creep.room.invaderCore) {
            return false;
        }
        const rampartBuffer = [];
        creep.room
            .find(FIND_HOSTILE_STRUCTURES)
            .filter(s => s.structureType === STRUCTURE_RAMPART)
            .forEach(rampart => {
            for (let x = Math.max(rampart.pos.x - 1, 0); x <= Math.min(rampart.pos.x + 1, 49); x++) {
                for (let y = Math.max(rampart.pos.y - 1, 0); y <= Math.min(rampart.pos.y + 1, 49); y++) {
                    rampartBuffer.push(new RoomPosition(x, y, creep.room.name));
                }
            }
        });
        creep.travel(creep.room.invaderCore, {
            range: 3,
            obstacles: rampartBuffer
        });
        return true;
    }
    static kiteBack(creep) {
        if (creep.hits / creep.hitsMax > 0.9) {
            return false;
        }
        if (!creep.room.invaderCore) {
            return false;
        }
        const path = PathFinder.search(creep.pos, { pos: creep.room.invaderCore.pos, range: 20 }, { flee: true, swampCost: 2, plainCost: 1 });
        if (!path || path.incomplete)
            return false;
        creep.moveByPath(path.path);
        return true;
    }
    static moveToRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        return creep.travelToRoom(creep.memory.targetRoom);
    }
}
__decorate([
    Profiler.subprofile("creep")
], Stronghold2Attacker, "work", null);
__decorate([
    Profiler.subprofile("spawn")
], Stronghold2Attacker, "spawn", null);

const CONFIG$c = Config.Stronghold3Attacker;
class Stronghold3Attacker {
    static handle() {
        Creeps.getByRole(CONFIG$c.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.work(creep);
        });
        General.interval(50, () => TickAction.add(() => this.spawn()));
    }
    static work(creep) {
        creep.healMele() || creep.prehealMele();
        this.attackSingleHostile(creep) || this.snipeCore(creep) || creep.rangedBestAttack();
        creep.boost({ minTicksToLive: 1000 }) ||
            this.moveToRoom(creep) ||
            this.kiteBack(creep) ||
            this.moveToSnipePosition(creep) ||
            this.moveToHostileStructures(creep) ||
            this.moveToHostiles(creep);
    }
    static spawn() {
        Object.values(Memory.strongholds).forEach(stronghold => {
            if (stronghold.level !== 3) {
                return;
            }
            if (!stronghold.isAlive) {
                return;
            }
            if (stronghold.startsAt) {
                return;
            }
            if (!stronghold.endsAt) {
                return;
            }
            if (stronghold.attackerCount > stronghold.attackerCountMax) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({ role: CONFIG$c.roleName, targetRoom: stronghold.targetRoom });
            if (creepsCount >= 1) {
                return;
            }
            const spawnRooms = stronghold.homeRooms.map(roomName => Game.rooms[roomName]).filter(Boolean);
            if (spawnRooms.length === 0) {
                return;
            }
            Spawns.addToQue(spawnRooms, {
                body: BodyParts.new().tough(6).rangedAttack(22).move(10).heal(12),
                boosts: [
                    RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
                    RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
                    RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
                    RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE
                ],
                priority: 3 /* Medium */,
                role: CONFIG$c.roleName,
                memory: {
                    targetRoom: stronghold.targetRoom
                }
            });
            Log.room(stronghold.targetRoom, "Stronghold", `Spawning stronghold 3 attacker in ${spawnRooms.map(r => r.name).join(", ")} rooms`);
            stronghold.attackerCount++;
        });
    }
    static moveToHostiles(creep) {
        const hostile = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS, { filter: c => !c.isNPC });
        if (!hostile) {
            return false;
        }
        creep.travel(hostile, { range: 3 });
        return true;
    }
    static mostEffectiveDamagePos(creep) {
        const stronghold = Memory.strongholds[creep.room.name];
        if (!stronghold) {
            return undefined;
        }
        const coordinates = [];
        const minX = Math.max(stronghold.pos.x - 3, 1);
        const maxX = Math.min(stronghold.pos.x + 3, 48);
        const minY = Math.max(stronghold.pos.y - 3, 1);
        const maxY = Math.min(stronghold.pos.y + 3, 48);
        for (let x = minX; x <= maxX; x++) {
            for (let y = minY; y <= maxY; y++) {
                const pos = new RoomPosition(x, y, creep.room.name);
                const structures = pos
                    .lookFor(LOOK_STRUCTURES)
                    .filter(s => s.structureType !== STRUCTURE_ROAD && s.structureType !== STRUCTURE_CONTAINER);
                if (structures.length > 0)
                    continue;
                const suroundingStructures = pos
                    .findInRange(FIND_STRUCTURES, 1)
                    .filter(s => s.structureType === STRUCTURE_RAMPART);
                if (suroundingStructures.length >= 8)
                    continue;
                const creeps = pos.lookFor(LOOK_CREEPS).filter(c => c.id !== creep.id);
                if (creeps.length > 0)
                    continue;
                coordinates.push(pos);
            }
        }
        return coordinates.sort((a, b) => {
            const rampartsInRangeA = a
                .findInRange(FIND_HOSTILE_STRUCTURES, 3)
                .filter(s => s.structureType === STRUCTURE_RAMPART)
                .reduce((totalDmg, struct) => {
                const range = a.getRangeTo(struct);
                return totalDmg + 1000 * (MASS_RANGED_ATTACK_DECAY[range] || 0);
            }, 0);
            const rampartsInRangeB = b
                .findInRange(FIND_HOSTILE_STRUCTURES, 3)
                .filter(s => s.structureType === STRUCTURE_RAMPART)
                .reduce((totalDmg, struct) => {
                const range = b.getRangeTo(struct);
                return totalDmg + 1000 * (MASS_RANGED_ATTACK_DECAY[range] || 0);
            }, 0);
            return rampartsInRangeB - rampartsInRangeA;
        })[0];
    }
    static hostileStructure(creep) {
        return creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_TOWER
        });
    }
    static moveToHostileStructures(creep) {
        const structure = this.hostileStructure(creep);
        if (!structure) {
            return false;
        }
        creep.moveTo(structure);
        return true;
    }
    static moveToSnipePosition(creep) {
        if (!creep.room.invaderCore) {
            return false;
        }
        creep.travel(creep.room.invaderCore, {
            range: 3,
            roomCallback: (room, matrix) => {
                room
                    .find(FIND_HOSTILE_STRUCTURES)
                    .filter(s => s.structureType === STRUCTURE_RAMPART)
                    .forEach(rampart => {
                    for (let x = Math.max(rampart.pos.x - 1, 0); x <= Math.min(rampart.pos.x + 1, 49); x++) {
                        for (let y = Math.max(rampart.pos.y - 1, 0); y <= Math.min(rampart.pos.y + 1, 49); y++) {
                            matrix.set(x, y, 240);
                        }
                    }
                });
                return matrix;
            }
        });
        return true;
    }
    static kiteBack(creep) {
        if (creep.hits / creep.hitsMax > 0.9) {
            return false;
        }
        if (!creep.room.invaderCore) {
            return false;
        }
        const path = PathFinder.search(creep.pos, { pos: creep.room.invaderCore.pos, range: 20 }, { flee: true, swampCost: 2, plainCost: 1 });
        if (!path || path.incomplete) {
            return false;
        }
        creep.moveByPath(path.path);
        return true;
    }
    static attackSingleHostile(creep) {
        const hostile = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3)[0];
        if (!hostile) {
            return false;
        }
        if (hostile.pos.rampart) {
            return false;
        }
        creep.rangedAttack(hostile);
        return true;
    }
    static snipeCore(creep) {
        if (!creep.room.invaderCore) {
            return false;
        }
        if (creep.pos.getRangeTo(creep.room.invaderCore) > 3) {
            return false;
        }
        const rampart = creep.room.invaderCore.pos
            .lookFor(LOOK_STRUCTURES)
            .find(s => s.structureType === STRUCTURE_RAMPART);
        creep.rangedAttack(rampart || creep.room.invaderCore);
        return true;
    }
    static moveToRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        return creep.travelToRoom(creep.memory.targetRoom);
    }
}
__decorate([
    Profiler.subprofile("creep")
], Stronghold3Attacker, "work", null);
__decorate([
    Profiler.subprofile("spawn")
], Stronghold3Attacker, "spawn", null);

const CONFIG$b = Config.StrongholdDismantler;
class StrongholdDismantler {
    static handle() {
        Creeps.getByRole(CONFIG$b.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.work(creep);
        });
        General.interval(50, () => TickAction.add(() => this.spawn()));
    }
    static work(creep) {
        var _a;
        if (!creep.memory.targetRoom ||
            !((_a = Memory.strongholds) === null || _a === void 0 ? void 0 : _a[creep.memory.targetRoom]) ||
            Memory.strongholds[creep.memory.targetRoom].structureHits === 0) {
            creep.recycleFinal(1500);
            return;
        }
        // if (!creep.targetRoom.memory.strongholdHasStructures) {
        //   creep.recycleFinal(1500);
        //
        //   return;
        // }
        this.attackStructures(creep);
        this.moveToRoom(creep) || this.moveToStronhgoldStructure(creep);
    }
    static spawn() {
        Object.values(Memory.strongholds).forEach(stronghold => {
            if (stronghold.isAlive) {
                return;
            }
            if (stronghold.structureHits === 0) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({
                minTicksToLive: 300,
                role: CONFIG$b.roleName,
                targetRoom: stronghold.targetRoom
            });
            const creepNeededCount = Math.ceil(stronghold.structureHits / 1200000);
            if (creepsCount >= creepNeededCount) {
                return;
            }
            const spawnRooms = stronghold.homeRooms.map(roomName => Game.rooms[roomName]).filter(Boolean);
            if (spawnRooms.length === 0) {
                return;
            }
            Spawns.addToQue(spawnRooms, {
                body: BodyParts.new().work(25).move(25),
                priority: 3 /* Medium */,
                role: CONFIG$b.roleName,
                memory: {
                    targetRoom: stronghold.targetRoom
                }
            });
            console.log("spawned dismantler");
        });
    }
    static attackStructures(creep) {
        if (!creep.targetRoomModel) {
            return false;
        }
        if (creep.targetRoomModel.roomName !== creep.room.name) {
            return false;
        }
        const structure = creep.pos
            .findInRange(FIND_STRUCTURES, 1, {
            filter: s => this.structureAttackable(s)
        })
            .sort((a, b) => a.hits - b.hits)[0];
        if (!structure) {
            return false;
        }
        creep.dismantle(structure);
        return true;
    }
    static moveToStronhgoldStructure(creep) {
        if (!creep.targetRoom) {
            return false;
        }
        if (creep.targetRoom.name !== creep.room.name) {
            return false;
        }
        const structuresInRange = creep.pos.findInRange(FIND_STRUCTURES, 1, { filter: s => this.structureAttackable(s) });
        if (structuresInRange.length > 0) {
            return true;
        }
        const structure = creep.pos.findClosestByPath(FIND_STRUCTURES, {
            ignoreCreeps: false,
            filter: s => this.structureAttackable(s)
        });
        if (!structure) {
            return false;
        }
        creep.travel(structure, { ignoreCreeps: false });
        return true;
    }
    static structureAttackable(structure) {
        return (structure.hits > 0 &&
            (("my" in structure && !structure.my) ||
                ("ticksToDecay" in structure && structure.ticksToDecay !== undefined && structure.ticksToDecay > 5000)));
    }
    static moveToRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        return creep.travelToRoom(creep.memory.targetRoom, { ignoreHostiles: false });
    }
}
__decorate([
    Profiler.subprofile("creep")
], StrongholdDismantler, "work", null);
__decorate([
    Profiler.subprofile("spawn")
], StrongholdDismantler, "spawn", null);

const CONFIG$a = Config.StrongholdHauler;
const EXPECTED_HAUL_TRIPS = 1;
const CARRY_CAPACITY$1 = 25 * 50;
class StrongholdHauler {
    static handle() {
        Creeps.getByRole(CONFIG$a.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.work(creep);
        });
        General.interval(50, () => TickAction.add(() => this.spawn()));
    }
    static work(creep) {
        var _a;
        if (!creep.targetRoomModel) {
            return;
        }
        if (!((_a = Memory.strongholds[creep.targetRoomModel.roomName]) === null || _a === void 0 ? void 0 : _a.lootableAmount)) {
            creep.recycleFinal(1500);
            return;
        }
        this.moveToRoom(creep) ||
            this.pickupRuins(creep) ||
            this.withdrawFromContainers(creep) ||
            this.storeToTerminal(creep) ||
            this.storeToStorage(creep);
    }
    static spawn() {
        Object.values(Memory.strongholds).forEach(stronghold => {
            if (stronghold.isAlive) {
                return;
            }
            if (stronghold.lootableAmount === 0) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({
                minTicksToLive: 300,
                role: CONFIG$a.roleName,
                targetRoom: stronghold.targetRoom
            });
            const creepsNeededCount = Math.ceil(stronghold.lootableAmount / EXPECTED_HAUL_TRIPS / CARRY_CAPACITY$1);
            if (creepsCount >= creepsNeededCount) {
                return;
            }
            const spawnRooms = stronghold.homeRooms.map(roomName => Game.rooms[roomName]).filter(Boolean);
            if (spawnRooms.length === 0) {
                return;
            }
            Spawns.addToQue(spawnRooms, {
                body: new BodyParts().add(CARRY, 25).add(MOVE, 25).get(),
                priority: 3 /* Medium */,
                role: CONFIG$a.roleName,
                memory: {
                    targetRoom: stronghold.targetRoom
                }
            });
            console.log("spawned hauler");
        });
    }
    static storeToTerminal(creep) {
        if (creep.store.getUsedCapacity() === 0) {
            return false;
        }
        if (!creep.homeRoom) {
            return false;
        }
        if (!creep.homeRoom.terminal) {
            return false;
        }
        const resource = Resources.firstStoreResource(creep.store);
        if (!resource) {
            return false;
        }
        if (creep.transfer(creep.homeRoom.terminal, resource) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.homeRoom.terminal, { ignoreHostiles: false });
        }
        return true;
    }
    static storeToStorage(creep) {
        if (creep.store.getUsedCapacity() === 0) {
            return false;
        }
        if (!creep.homeRoom) {
            return false;
        }
        if (!creep.homeRoom.storage) {
            return false;
        }
        const resource = Resources.firstStoreResource(creep.store);
        if (!resource) {
            return false;
        }
        if (creep.transfer(creep.homeRoom.storage, resource) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.homeRoom.storage, { ignoreHostiles: false });
        }
        return true;
    }
    static pickupRuins(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (creep.memory.targetRoom !== creep.room.name) {
            return false;
        }
        const ruin = creep.pos.findClosestByRange(FIND_RUINS, {
            filter: r => r.ticksToDecay > 5000 &&
                (r.structure.structureType === STRUCTURE_CONTAINER || r.structure.structureType === STRUCTURE_INVADER_CORE) &&
                r.store.getUsedCapacity() > 0
        });
        if (!ruin) {
            return false;
        }
        const ruinResource = Resources.firstStoreResource(ruin.store);
        if (!ruinResource) {
            return false;
        }
        if (creep.withdraw(ruin, ruinResource) === ERR_NOT_IN_RANGE) {
            creep.travel(ruin, { ignoreHostiles: false });
        }
        return true;
    }
    static withdrawFromContainers(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        if (creep.memory.targetRoom !== creep.room.name) {
            return false;
        }
        const container = creep.pos.findClosestByRange(FIND_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_CONTAINER && s.ticksToDecay > 5000 && s.store.getUsedCapacity() > 0
        });
        if (!container) {
            return false;
        }
        const containerResource = Resources.firstStoreResource(container.store);
        if (!containerResource) {
            return false;
        }
        const response = creep.withdraw(container, containerResource);
        if (response === ERR_NOT_IN_RANGE) {
            creep.travel(container, { ignoreHostiles: false });
        }
        return true;
    }
    static moveToRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        if (creep.store.getUsedCapacity() > 0) {
            return false;
        }
        return creep.travelToRoom(creep.memory.targetRoom, { ignoreHostiles: false });
    }
    static totalLootAmount(room) {
        return (this.invaderCoresWithLoot(room).reduce((total, ruin) => total + ruin.store.getUsedCapacity(), 0) +
            this.containersWithLoot(room).reduce((total, container) => total + container.store.getUsedCapacity(), 0));
    }
    static invaderStructures(room) {
        return room
            .find(FIND_HOSTILE_STRUCTURES)
            .filter(s => s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_TOWER)
            .filter(s => { var _a; return s.owner && ((_a = s.owner) === null || _a === void 0 ? void 0 : _a.username) === "Invader"; });
    }
    static invaderCoresWithLoot(room) {
        return room
            .find(FIND_RUINS)
            .filter(r => r.structure.structureType === STRUCTURE_INVADER_CORE && r.store.getUsedCapacity() > 0);
    }
    static containersWithLoot(room) {
        return room
            .find(FIND_STRUCTURES)
            .filter(s => s.structureType === STRUCTURE_CONTAINER && s.ticksToDecay > 5000 && s.store.getUsedCapacity() > 0);
    }
}
__decorate([
    Profiler.subprofile("creep")
], StrongholdHauler, "work", null);
__decorate([
    Profiler.subprofile("spawn")
], StrongholdHauler, "spawn", null);

const CONFIG$9 = Config.StrongholdProtector;
class StrongholdProtector {
    static handle() {
        Creeps.getByRole(CONFIG$9.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.work(creep);
        });
        General.interval(50, () => TickAction.add(() => this.spawn()));
    }
    static work(creep) {
        this.healSelf(creep);
        this.moveToRoom(creep) ||
            this.attackHostiles(creep) ||
            this.healFriendlies(creep) ||
            this.attackContainers(creep) ||
            this.moveToSoonestLair(creep);
    }
    static spawn() {
        const creeps = Creeps.getByRole(CONFIG$9.roleName);
        const que = Creeps.queByRole(CONFIG$9.roleName);
        Object.values(Memory.strongholds).forEach(stronghold => {
            if (stronghold.isAlive) {
                return;
            }
            if (stronghold.structureHits === 0 && stronghold.lootableAmount === 0) {
                return;
            }
            const spawnRooms = stronghold.homeRooms.map(roomName => Game.rooms[roomName]).filter(Boolean);
            if (spawnRooms.length === 0) {
                return;
            }
            spawnRooms
                .reduce((rooms, homeRoom) => {
                const route = Geo.findRouteCached(homeRoom.name, stronghold.targetRoom);
                route.forEach(roomName => {
                    if (rooms.indexOf(roomName) !== -1) {
                        return;
                    }
                    const mem = Rooms.memory(roomName);
                    if (mem.type !== RoomTypeEnum.SK) {
                        return;
                    }
                    rooms.push(roomName);
                });
                return rooms;
            }, [])
                .forEach(targetRoom => {
                if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === targetRoom; }).length > 0) {
                    return;
                }
                const maxCreeps = targetRoom === stronghold.targetRoom ? 3 : 1;
                if (creeps.filter(q => q.memory.targetRoom === targetRoom).length >= maxCreeps) {
                    return;
                }
                Spawns.addToQue(spawnRooms, {
                    body: new BodyParts()
                        .add(ATTACK)
                        .add(MOVE, 23)
                        .add(ATTACK, 16)
                        .add(RANGED_ATTACK)
                        .add(HEAL, 5)
                        .add(RANGED_ATTACK)
                        .add(MOVE, 2)
                        .add(HEAL)
                        .get(),
                    priority: 4 /* Low */,
                    role: CONFIG$9.roleName,
                    memory: {
                        targetRoom
                    }
                });
                console.log("spawned protector", "for", targetRoom);
            });
        });
    }
    static attackContainers(creep) {
        const container = creep.pos.findClosestByRange(FIND_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_CONTAINER &&
                s.ticksToDecay > 2000 &&
                !s.pos.lookFor(LOOK_STRUCTURES).find(ls => ls.structureType === STRUCTURE_RAMPART)
        });
        if (!container) {
            return false;
        }
        if (creep.attack(container) === ERR_NOT_IN_RANGE) {
            creep.travel(container);
        }
        return true;
    }
    static moveToSoonestLair(creep) {
        const lair = creep.room.find(FIND_STRUCTURES).filter(s => s.structureType === STRUCTURE_KEEPER_LAIR).sort((a, b) => (a.ticksToSpawn || 300) - (b.ticksToSpawn || 300))[0];
        if (!lair) {
            return false;
        }
        creep.travel(lair, { range: 2 });
        return true;
    }
    static healSelf(creep) {
        if (creep.hitsMax === creep.hits) {
            return;
        }
        if (creep.healPower === 0) {
            return;
        }
        if (creep.pos.findInRange(FIND_HOSTILE_CREEPS, 1).length > 0) {
            return;
        }
        creep.heal(creep);
    }
    static attackHostiles(creep) {
        if (creep.attackPower === 0) {
            return false;
        }
        const hostile = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {
            filter: c => !c.isUnderRampart
        });
        if (!hostile) {
            return false;
        }
        if (hostile.owner.username === USERNAME.INVADER && creep.hits < 2000) {
            return false;
        }
        creep.attack(hostile);
        creep.travel(hostile);
        creep.rangedBestAttack();
        return true;
    }
    static healFriendlies(creep) {
        const friendly = creep.pos.findClosestByRange(FIND_MY_CREEPS, { filter: c => c.hitsMax !== c.hits });
        if (!friendly) {
            return false;
        }
        creep.moveTo(friendly);
        if (creep.pos.inRangeTo(friendly, 1)) {
            creep.heal(friendly);
        }
        else {
            creep.rangedHeal(friendly);
        }
        return true;
    }
    static moveToRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        return creep.travelToRoom(creep.memory.targetRoom);
    }
}
__decorate([
    Profiler.subprofile("creep")
], StrongholdProtector, "work", null);
__decorate([
    Profiler.subprofile("spawn")
], StrongholdProtector, "spawn", null);

class EngineUtils {
    static getRoomNameFromXY(x, y) {
        if (x < 0) {
            x = "W" + String(-x - 1);
        }
        else {
            x = "E" + String(x);
        }
        if (y < 0) {
            y = "N" + String(-y - 1);
        }
        else {
            y = "S" + String(y);
        }
        return "" + x + y;
    }
    static roomNameToXY(name) {
        let xx = parseInt(name.substr(1), 10);
        let verticalPos = 2;
        if (xx >= 100) {
            verticalPos = 4;
        }
        else if (xx >= 10) {
            verticalPos = 3;
        }
        let yy = parseInt(name.substr(verticalPos + 1), 10);
        const horizontalDir = name.charAt(0);
        const verticalDir = name.charAt(verticalPos);
        if (horizontalDir === "W" || horizontalDir === "w") {
            xx = -xx - 1;
        }
        if (verticalDir === "N" || verticalDir === "n") {
            yy = -yy - 1;
        }
        return [xx, yy];
    }
    static calcBodyEffectiveness(body, bodyPartType, methodName, basePower, withoutOldHits) {
        let power = 0;
        body.forEach(i => {
            if (!i.hits || i.type !== bodyPartType) {
                return;
            }
            let iPower = basePower;
            if (i.boost && BOOSTS[bodyPartType][i.boost] && BOOSTS[bodyPartType][i.boost][methodName]) {
                iPower *= BOOSTS[bodyPartType][i.boost][methodName];
            }
            power += iPower;
        });
        return power;
    }
}

class StrongholdUtils {
    static focusMax(room) {
        const defenders = room.find(FIND_CREEPS).filter(c => c.owner.username === USERNAME.INVADER);
        const towers = room
            .find(FIND_STRUCTURES)
            .filter(s => s.structureType === STRUCTURE_TOWER && s.owner.username === USERNAME.INVADER);
        const hostiles = room.find(FIND_MY_CREEPS);
        if (!_.some(hostiles)) {
            return null;
        }
        const activeTowers = _.filter(towers, t => t.store.energy >= TOWER_ENERGY_COST);
        const hostile = _.max(hostiles, creep => {
            let damage = _.sum(activeTowers, tower => {
                let r = creep.pos.getRangeTo(tower);
                let amount = TOWER_POWER_ATTACK;
                if (r > TOWER_OPTIMAL_RANGE) {
                    if (r > TOWER_FALLOFF_RANGE) {
                        r = TOWER_FALLOFF_RANGE;
                    }
                    amount -= (amount * TOWER_FALLOFF * (r - TOWER_OPTIMAL_RANGE)) / (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
                }
                [PWR_OPERATE_TOWER, PWR_DISRUPT_TOWER].forEach(power => {
                    const effect = _.find(tower.effects, { power });
                    if (effect && effect.ticksRemaining + Game.time > Game.time) {
                        if ("level" in effect) {
                            amount *= POWER_INFO[power].effect[effect.level - 1];
                        }
                    }
                });
                return Math.floor(amount);
            });
            damage += _.sum(defenders, defender => {
                let d = 0;
                if (defender.pos.getRangeTo(creep) <= 3 && _.some(defender.body, { type: RANGED_ATTACK })) {
                    d += EngineUtils.calcBodyEffectiveness(defender.body, RANGED_ATTACK, "rangedAttack", RANGED_ATTACK_POWER);
                }
                if (defender.pos.getRangeTo(creep) <= 1 && _.some(defender.body, { type: ATTACK })) {
                    d += EngineUtils.calcBodyEffectiveness(defender.body, ATTACK, "attack", ATTACK_POWER);
                }
                return d;
            });
            return damage;
        });
        return hostile;
    }
    static focusMax2(room) {
        const defenders = room.find(FIND_CREEPS).filter(c => c.owner.username === USERNAME.INVADER);
        const towers = room
            .find(FIND_STRUCTURES)
            .filter(s => s.structureType === STRUCTURE_TOWER && s.owner.username === USERNAME.INVADER);
        const hostiles = room.find(FIND_MY_CREEPS);
        if (!_.some(hostiles)) {
            return [];
        }
        const activeTowers = _.filter(towers, t => t.store.energy >= TOWER_ENERGY_COST);
        const creeps = [];
        hostiles.forEach(creep => {
            let damage = _.sum(activeTowers, tower => {
                let r = creep.pos.getRangeTo(tower);
                let amount = TOWER_POWER_ATTACK;
                if (r > TOWER_OPTIMAL_RANGE) {
                    if (r > TOWER_FALLOFF_RANGE) {
                        r = TOWER_FALLOFF_RANGE;
                    }
                    amount -= (amount * TOWER_FALLOFF * (r - TOWER_OPTIMAL_RANGE)) / (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
                }
                [PWR_OPERATE_TOWER, PWR_DISRUPT_TOWER].forEach(power => {
                    const effect = _.find(tower.effects, { power });
                    if (effect && effect.ticksRemaining + Game.time > Game.time) {
                        if ("level" in effect) {
                            amount *= POWER_INFO[power].effect[effect.level - 1];
                        }
                    }
                });
                return Math.floor(amount);
            });
            damage += _.sum(defenders, defender => {
                let d = 0;
                if (defender.pos.getRangeTo(creep) <= 3 && _.some(defender.body, { type: RANGED_ATTACK })) {
                    d += EngineUtils.calcBodyEffectiveness(defender.body, RANGED_ATTACK, "rangedAttack", RANGED_ATTACK_POWER);
                }
                if (defender.pos.getRangeTo(creep) <= 1 && _.some(defender.body, { type: ATTACK })) {
                    d += EngineUtils.calcBodyEffectiveness(defender.body, ATTACK, "attack", ATTACK_POWER);
                }
                return d;
            });
            creeps.push({ damage, creep });
        });
        return creeps.sort((a, b) => b.damage - a.damage).filter(c => c.damage === creeps[0].damage);
    }
}

class QuadUtils {
    static blockingCoordinatesInverse(pos) {
        const positions = [];
        const OFFSETS = [
            { x: -1, y: -1 },
            { x: 0, y: -1 },
            { x: -1, y: 0 }
        ];
        OFFSETS.forEach(off => {
            const newX = pos.x + off.x;
            if (newX > 49 || newX < 0) {
                return;
            }
            const newY = pos.y + off.y;
            if (newY > 49 || newY < 0) {
                return;
            }
            positions.push({ x: newX, y: newY });
        });
        return positions;
    }
    static quadCoordinates(pos) {
        const positions = [];
        const OFFSETS = [
            { x: 0, y: 0 },
            { x: 1, y: 1 },
            { x: 0, y: 1 },
            { x: 1, y: 0 }
        ];
        OFFSETS.forEach(off => {
            const newX = pos.x + off.x;
            if (newX > 49 || newX < 0) {
                return;
            }
            const newY = pos.y + off.y;
            if (newY > 49 || newY < 0) {
                return;
            }
            positions.push({ x: newX, y: newY });
        });
        return positions;
    }
}

const CONFIG$8 = Config.Stronghold4Attacker;
class Stronghold4Attacker {
    static handle() {
        Quads.allByrole(CONFIG$8.roleName).forEach(quad => {
            try {
                this.workQuad(quad);
                // console.log((end - start).toFixed(2));
            }
            catch (e) {
                console.log(e);
                // quad.stage = QuadGroupStage.RETREATING;
            }
        });
        General.interval(CONFIG$8.spawnInterval, () => TickAction.add(() => this.spawn()));
    }
    static workQuad(quadMemory) {
        var _a;
        const quad = new QuadModel(quadMemory);
        quad.getCreeps().forEach(creep => {
            if (creep.spawning) {
                return;
            }
            this.workCreep(creep, quad);
        });
        const stronghold = (_a = Memory.strongholds) === null || _a === void 0 ? void 0 : _a[quad.memory.targetRoom];
        quad
            .inStage(QuadGroupStage.SPAWNING, () => {
            if (!stronghold || !stronghold.isAlive) {
                quad.setStage(QuadGroupStage.RETREATING);
                return;
            }
            quad.refresh() || quad.waitTillAllAlive() || quad.setStage(QuadGroupStage.BOOSTING);
        })
            .inStage(QuadGroupStage.BOOSTING, () => {
            if (!stronghold || !stronghold.isAlive) {
                quad.setStage(QuadGroupStage.RETREATING);
                return;
            }
            quad.boost() || quad.setStage(QuadGroupStage.TRAVELING);
        })
            .inStage(QuadGroupStage.TRAVELING, () => {
            if (!stronghold || !stronghold.isAlive) {
                quad.setStage(QuadGroupStage.RETREATING);
                return;
            }
            const invaderPosition = new RoomPosition(stronghold.pos.x, stronghold.pos.y, quad.memory.targetRoom);
            const distance = quad.anchorCreep.wpos.getRangeTo(invaderPosition.wpos);
            if (distance < 30 &&
                quad.anchorCreep.pos.x < 47 &&
                quad.anchorCreep.pos.x > 1 &&
                quad.anchorCreep.pos.y < 47 &&
                quad.anchorCreep.pos.y > 1) {
                quad.setStage(QuadGroupStage.ATTACKING);
                quad.anchorCreep.say("attacking");
                return;
            }
            quad.travelTo(invaderPosition, 5);
        })
            .inStage(QuadGroupStage.ATTACKING, () => {
            if (!stronghold || (!stronghold.isAlive && quad.memory.ticksToLive < 300)) {
                quad.setStage(QuadGroupStage.RETREATING);
                return;
            }
            const invaderPosition = new RoomPosition(stronghold.pos.x, stronghold.pos.y, quad.memory.targetRoom);
            if (quad.hitsMax - quad.hits >= 2000) {
                quad.kite();
            }
            if (quad.retreatWhenNotFull() || quad.formQuadIfPossible() || quad.turnTowards(invaderPosition, 10)) {
                return;
            }
            const targetRoom = Game.rooms[quad.memory.targetRoom];
            if (targetRoom) {
                if (targetRoom.invaderCore) {
                    this.resetTargetPos(quad);
                    const targetPos = this.findTargetPos(quad, targetRoom);
                    if (targetPos) {
                        quad.moveTo(targetPos, 0, {
                            callback: (room, matrix) => {
                                if (room) {
                                    room
                                        .find(FIND_HOSTILE_STRUCTURES, {
                                        filter: s => s.structureType === STRUCTURE_RAMPART && !s.pos.hasStructureObstacle
                                    })
                                        .forEach(rampart => {
                                        rampart.pos.quadCoordinatesAround(1).forEach(p => {
                                            matrix.set(p.x, p.y, 100);
                                        });
                                    });
                                }
                            }
                        });
                    }
                }
                else {
                    const possibleLocations = this.possibleDeadStrongholdStandingPositions(quad.anchorCreep.room)
                        .filter(pos => quad.canFormQuadOn(pos))
                        .sort((a, b) => this.quadDamageOutput(targetRoom.invaderCore, b) - this.quadDamageOutput(targetRoom.invaderCore, a));
                    // figure best position for shit and go there
                    if (possibleLocations.length === 0) {
                        return;
                    }
                    new RoomVisual(possibleLocations[0].roomName).circle(possibleLocations[0], { radius: 0.5 });
                    // if (possibleLocations.find(p => p.isEqualTo(quad.anchorCreep.pos))) {
                    //   return;
                    // }
                    quad.moveTo(possibleLocations[0], 0);
                }
            }
            else {
                quad.anchorCreep.say("1");
                quad.moveTo(invaderPosition, 5);
            }
        })
            // .inStage(QuadGroupStage.ATTACKING, () => {
            //   quad.attak() || quad.setStage(QuadGroupStage.RETREATING);
            // })
            .inStage(QuadGroupStage.RETREATING, () => {
            quad.retreat();
        });
    }
    static resetTargetPos(quad) {
        if (!quad.memory.targetPos) {
            return;
        }
        if (!quad.memory.targetRoom) {
            return;
        }
        const room = Game.rooms[quad.memory.targetRoom];
        if (!room) {
            return;
        }
        if (quad.memory.targetPos && quad.memory.targetPos.updatedAt < Game.time - 50) {
            quad.memory.targetPos = undefined;
            console.log("quad siege 4", "reseting target pos periodicaly");
            return;
        }
        const rampartDestroyedEvents = room
            .getEventLog()
            .filter(l => l.event === EVENT_OBJECT_DESTROYED && (l.data.type === "rampart" || l.data.type === "invaderCore"));
        if (rampartDestroyedEvents.length > 0) {
            quad.memory.targetPos = undefined;
            console.log("quad siege 4", "object destroyed, resetting target pos");
            return;
        }
    }
    static findTargetPos(quad, targetRoom) {
        if (quad.memory.targetPos) {
            return new RoomPosition(quad.memory.targetPos.x, quad.memory.targetPos.y, quad.memory.targetRoom);
        }
        const otherQuads = Object.values(Memory.quads || {}).filter(q => q.targetRoom === targetRoom.name && q.id !== quad.memory.id);
        const otherQuadPositions = otherQuads.reduce((positions, quadMemory) => {
            if (!quadMemory.targetPos) {
                return positions;
            }
            QuadUtils.quadCoordinates(quadMemory.targetPos).forEach(memberPos => QuadUtils.blockingCoordinatesInverse(memberPos).forEach(pos => positions.push(pos)));
            return positions;
        }, []);
        otherQuadPositions.forEach(p => {
            new RoomVisual(quad.memory.targetRoom).circle(p.x, p.y, { radius: 0.5 });
        });
        const possibleLocations = this.possibleActiveStrongholdStandingPositions(targetRoom)
            .filter(pos => otherQuadPositions.filter(pos2 => pos.x === pos2.x && pos.y === pos2.y).length === 0)
            .filter(pos => quad.canFormQuadOn(pos))
            .filter(pos => this.quadCanReachPos(quad, pos))
            .sort((a, b) => this.quadDamageOutput(targetRoom.invaderCore, b) - this.quadDamageOutput(targetRoom.invaderCore, a));
        if (!possibleLocations.length) {
            return;
        }
        quad.memory.targetPos = { x: possibleLocations[0].x, y: possibleLocations[0].y, updatedAt: Game.time };
        return possibleLocations[0];
    }
    static quadCanReachPos(quad, pos) {
        const ret = PathFinder.search(quad.anchorCreep.pos, pos, {
            maxOps: 10000,
            roomCallback(roomName) {
                // if (![quad.anchorCreep.room.name, quad.anchorCreep.memory.targetRoom].includes(roomName)) {
                //   return false;
                // }
                const matrix = Rooms.quadMatrix(roomName);
                const creepIds = Object.values(quad.creeps).map(c => c === null || c === void 0 ? void 0 : c.id);
                const room = Game.rooms[roomName];
                if (room) {
                    room
                        .find(FIND_CREEPS)
                        .filter(c => !creepIds.includes(c.id))
                        .forEach(c => QuadUtils.blockingCoordinatesInverse(c.pos).forEach(p => matrix.set(p.x, p.y, 255)));
                    room
                        .find(FIND_HOSTILE_STRUCTURES, {
                        filter: s => s.structureType === STRUCTURE_RAMPART && !s.pos.hasStructureObstacle
                    })
                        .forEach(rampart => {
                        rampart.pos.quadCoordinatesAround(1).forEach(p => {
                            matrix.set(p.x, p.y, 255);
                        });
                    });
                }
                return matrix;
            }
        });
        if (ret.incomplete) {
            new RoomVisual(pos.roomName).circle(pos, { radius: 1 });
            return false;
        }
        return true;
    }
    static quadDamageOutput(invaderCore, pos) {
        let damage = 0;
        Object.values(Quads.getPositions(pos)).forEach(wpos => {
            wpos.pos
                .findInRange(FIND_HOSTILE_STRUCTURES, 3, { filter: s => s.structureType === STRUCTURE_RAMPART })
                .forEach(rampart => {
                const distance = rampart.wpos.getRangeTo(wpos);
                damage += MASS_RANGED_ATTACK_DECAY[distance] || 0;
            });
            // if (invaderCore && wpos.getRangeTo(invaderCore.wpos) <= 3) {
            //   damage += 20;
            // }
        });
        return damage;
    }
    static possibleActiveStrongholdStandingPositions(room) {
        return TickCache.cache({
            key: `${this.constructor.name}.${room.name}.possibleActiveStrongholdStandingPositions`,
            callback: () => {
                const ramparts = room.find(FIND_HOSTILE_STRUCTURES, { filter: s => s.structureType === STRUCTURE_RAMPART });
                const walkableRamparts = ramparts.filter(r => !r.pos.hasStructureObstacle);
                const nonWalkableRamparts = ramparts.filter(r => r.pos.hasStructureObstacle);
                const unique = {};
                walkableRamparts.forEach(rampart => {
                    rampart.pos.quadCoordinatesAround(2).forEach(p => {
                        unique[`${p.x}.${p.y}`] = new RoomPosition(p.x, p.y, room.name);
                    });
                });
                nonWalkableRamparts.forEach(rampart => {
                    rampart.pos.quadCoordinatesAround(1).forEach(p => {
                        unique[`${p.x}.${p.y}`] = new RoomPosition(p.x, p.y, room.name);
                    });
                });
                walkableRamparts.forEach(rampart => {
                    rampart.pos.quadCoordinatesAround(1).forEach(p => {
                        delete unique[`${p.x}.${p.y}`];
                    });
                    delete unique[`${rampart.pos.x}.${rampart.pos.y}`];
                });
                Object.values(unique).forEach(pos => {
                    room.visual.circle(pos.x, pos.y, { radius: 0.1 });
                });
                return Object.values(unique);
            }
        });
    }
    static possibleDeadStrongholdStandingPositions(room) {
        return TickCache.cache({
            key: `${this.constructor.name}.${room.name}.possibleDeadStrongholdStandingPositions`,
            callback: () => {
                const ramparts = room.find(FIND_HOSTILE_STRUCTURES, { filter: s => s.structureType === STRUCTURE_RAMPART });
                const unique = {};
                ramparts.forEach(rampart => {
                    rampart.pos.quadCoordinatesAround(1).forEach(p => {
                        unique[`${p.x}.${p.y}`] = new RoomPosition(p.x, p.y, room.name);
                    });
                });
                ramparts.forEach(rampart => {
                    delete unique[`${rampart.pos.x}.${rampart.pos.y}`];
                });
                Object.values(unique).forEach(pos => {
                    room.visual.circle(pos.x, pos.y, { radius: 0.1, fill: "yellow" });
                });
                return Object.values(unique);
            }
        });
    }
    static workCreep(creep, quad) {
        creep.healMele() || this.healSelf(creep) || this.prehealAttacker(creep); // ||
        // this.prehealSelfAttacker(creep) ||
        // this.preheal(creep) ||
        // creep.prehealMele();
        this.attack(creep, quad);
    }
    static healSelf(creep) {
        if (creep.hits >= creep.hitsMax - 200) {
            return false;
        }
        if (!creep.healPower) {
            return false;
        }
        creep.heal(creep);
        return true;
    }
    static spawn() {
        Object.values(Memory.strongholds).forEach(stronghold => {
            if (stronghold.level !== 4) {
                return;
            }
            if (!stronghold.isAlive) {
                return;
            }
            if (stronghold.startsAt) {
                return;
            }
            if (!stronghold.endsAt) {
                return;
            }
            const targetRoomMemory = RoomModel.get(stronghold.targetRoom);
            if (!targetRoomMemory.terrainWallsCount || targetRoomMemory.terrainWallsCount > STRONGHLD_4_MAX_ROOM_WALLS) {
                return;
            }
            const spawnRooms = stronghold.homeRooms
                .map(roomName => Game.rooms[roomName])
                .filter(Boolean)
                .filter(room => room.my &&
                room.myActiveSpawns.length > 0 &&
                !Quads.isSpawningInRoom(room.name) &&
                !Duos.isSpawningInRoom(room.name));
            if (spawnRooms.length === 0) {
                return;
            }
            if (!Memory.quads) {
                Memory.quads = {};
            }
            const allQuads = Object.values(Memory.quads).filter(g => g.targetRoom === stronghold.targetRoom && g.role === CONFIG$8.roleName);
            const quadsCanSpawnMore = CONFIG$8.maxQuads - allQuads.filter(q => q.stage !== QuadGroupStage.RETREATING && q.ticksToLive > 400).length;
            if (quadsCanSpawnMore <= 0) {
                return;
            }
            spawnRooms.forEach((spawnRoom, index) => {
                var _a;
                if (quadsCanSpawnMore <= index) {
                    return;
                }
                const center = ((_a = spawnRoom.storage) === null || _a === void 0 ? void 0 : _a.pos) || spawnRoom.center;
                if (!center) {
                    return;
                }
                const roomQuads = allQuads.filter(quad => quad.homeRoom === spawnRoom.name);
                if (roomQuads.filter(q => q.stage === "spawning").length >= 1) {
                    return;
                }
                if (stronghold.attackerCount > stronghold.attackerCountMax) {
                    return;
                }
                console.log("spawning in ", spawnRoom.name);
                const creeps = {
                    [QuadPosition.BOTTOM_LEFT]: `biatch-${General.uniqueId()}`,
                    [QuadPosition.BOTTOM_RIGHT]: `biatch-${General.uniqueId()}`,
                    [QuadPosition.TOP_LEFT]: `biatch-${General.uniqueId()}`,
                    [QuadPosition.TOP_RIGHT]: `biatch-${General.uniqueId()}`
                };
                const quadId = Quads.create({
                    homeRoom: spawnRoom.name,
                    role: CONFIG$8.roleName,
                    stage: QuadGroupStage.SPAWNING,
                    targetRoom: stronghold.targetRoom,
                    creeps
                });
                const creepNames = Object.values(creeps);
                for (let i = 0; i < 4; i++) {
                    if (i % 2 === 0) {
                        Spawns.addToQue(spawnRoom, {
                            // body: BodyParts.new().tough(10).rangedAttack(2).heal(28).move(10),
                            body: BodyParts.new().tough(8).rangedAttack(20).move(10).heal(12),
                            priority: 0 /* Highest */,
                            role: CONFIG$8.roleName,
                            boosts: [BOOST_ALIAS.TOUGH_3, BOOST_ALIAS.RANGED_ATTACK_3, BOOST_ALIAS.MOVE_3, BOOST_ALIAS.HEAL_3],
                            memory: {
                                quad: {
                                    id: quadId,
                                    attacker: true
                                }
                            },
                            maxQueTime: 1000,
                            name: creepNames[i]
                        });
                    }
                    else {
                        Spawns.addToQue(spawnRoom, {
                            // body: BodyParts.new().tough(10).move(8).heal(30).move(2),
                            body: BodyParts.new().tough(5).move(10).heal(35),
                            priority: 0 /* Highest */,
                            role: CONFIG$8.roleName,
                            boosts: [BOOST_ALIAS.TOUGH_3, BOOST_ALIAS.RANGED_ATTACK_3, BOOST_ALIAS.MOVE_3, BOOST_ALIAS.HEAL_3],
                            memory: {
                                quad: {
                                    id: quadId,
                                    healer: true
                                }
                            },
                            maxQueTime: 1000,
                            name: creepNames[i]
                        });
                    }
                }
                stronghold.attackerCount++;
                spawnRoom.mem.increasedSpawnUntil = Game.time + 1500;
            });
        });
    }
    static prehealSelfAttacker(creep) {
        var _a;
        if (creep.room.my) {
            return false;
        }
        if ((_a = creep.memory.quad) === null || _a === void 0 ? void 0 : _a.attacker) {
            return false;
        }
        creep.heal(creep);
        return true;
    }
    // private preheal2(): boolean {
    //   if (this.creep.room.my) return false;
    //   if (this.creep.Misc.quad?.role !== "healer") return false;
    //
    //   const attackers = this.creep.pos.findInRange(FIND_MY_CREEPS, 1).find(c => c.Misc.quad?.role === "attacker");
    //
    //   return true;
    // }
    static prehealAttacker(creep) {
        if (creep.room.my) {
            return false;
        }
        if (!creep.healPower) {
            return false;
        }
        const attacker = creep.pos
            .findInRange(FIND_MY_CREEPS, 1, {
            filter: c => { var _a; return (_a = c.memory.quad) === null || _a === void 0 ? void 0 : _a.attacker; }
        })
            .sort((a, b) => a.preheal - b.preheal)[0];
        if (!attacker) {
            return false;
        }
        creep.heal(attacker);
        attacker.preheal += creep.healPower;
        return true;
    }
    static preheal(creep) {
        var _a;
        if (creep.room.my) {
            return false;
        }
        if (creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3).length === 0) {
            return false;
        }
        if (!creep.body.find(b => b.type === HEAL && b.hits > 0)) {
            return false;
        }
        const prehealee = ((_a = StrongholdUtils.focusMax2(creep.room)
            .filter(c => c.creep.pos.inRangeTo(creep, 1))
            .sort((a, b) => a.creep.preheal - b.creep.preheal)[0]) === null || _a === void 0 ? void 0 : _a.creep) ||
            creep.pos.findInRange(FIND_MY_CREEPS, 1).sort((a, b) => a.preheal - b.preheal)[0];
        if (!creep) {
            return false;
        }
        if (creep.heal(creep) === OK) {
            prehealee.preheal = prehealee.preheal + creep.healPower;
        }
        return true;
    }
    static attack(creep, quad) {
        this.attackHostileCreeps(creep) ||
            this.snipeCore(creep) ||
            creep.rangedBestAttack() ||
            this.attackInvaderStructures(creep, quad);
    }
    static attackInvaderStructures(creep, quad) {
        if (!creep.rangedAttackPower) {
            return false;
        }
        if (creep.room.name !== quad.memory.targetRoom) {
            return false;
        }
        const hostile = creep.pos.findInRange(FIND_STRUCTURES, 3, {
            filter: c => ((c.structureType === STRUCTURE_CONTAINER && (c.ticksToDecay || 0) > CONTAINER_DECAY_TIME) ||
                (c.structureType === STRUCTURE_ROAD && (c.ticksToDecay || 0) > ROAD_DECAY_TIME)) &&
                !c.pos.rampart
        })[0];
        if (!hostile) {
            return false;
        }
        creep.rangedAttack(hostile);
        return true;
    }
    static attackHostileCreeps(creep) {
        if (!creep.rangedAttackPower) {
            return false;
        }
        const hostile = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3, { filter: c => !c.pos.rampart })[0];
        if (!hostile) {
            return false;
        }
        creep.rangedAttack(hostile);
        return true;
    }
    static snipeCore(creep) {
        if (!creep.room.invaderCore) {
            return false;
        }
        if (creep.pos.getRangeTo(creep.room.invaderCore) > 3) {
            return false;
        }
        if (creep.room.find(FIND_HOSTILE_CREEPS, { filter: c => c.body.filter(b => b.type === WORK).length > 0 }).length > 0) {
            return false;
        }
        const rampart = creep.room.invaderCore.pos
            .lookFor(LOOK_STRUCTURES)
            .find(s => s.structureType === STRUCTURE_RAMPART);
        creep.rangedAttack(rampart || creep.room.invaderCore);
        return true;
    }
}

class SectorMemory {
    static handle() {
        Object.values(Game.rooms).forEach(room => {
            this.handleRoom(room);
            //
            // this.handleRoom(room);
        });
        General.interval(500, () => {
            this.removeExpiredStrongholds();
        });
    }
    static removeExpiredStrongholds() {
        if (!Memory.sectors) {
            return;
        }
        for (const sectorKey in Memory.sectors) {
            const sector = Memory.sectors[sectorKey];
            if (!sector) {
                continue;
            }
            if (!sector.stronghold) {
                continue;
            }
            if (sector.stronghold.endsAt < Game.time) {
                continue;
            }
            Memory.sectors[sectorKey].stronghold = undefined;
        }
    }
    // @profiler.subprofile()
    static handleRoom(room) {
        this.createSector(room);
        this.updateStronghold(room);
    }
    static createSector(room) {
        if (!room.mem.sectorName) {
            return;
        }
        if (!Memory.sectors) {
            Memory.sectors = {};
        }
        if (Memory.sectors[room.mem.sectorName]) {
            return;
        }
        Memory.sectors[room.mem.sectorName] = { name: room.mem.sectorName };
    }
    static updateStronghold(room) {
        if (room.mem.type !== RoomTypeEnum.SK) {
            return;
        }
        if (!room.mem.sectorName) {
            return;
        }
        if (!Memory.sectors) {
            Memory.sectors = {};
        }
        if (Memory.sectors[room.mem.sectorName].stronghold) {
            return;
        }
        const invaderCore = room.find(FIND_STRUCTURES, { filter: s => s.structureType === STRUCTURE_INVADER_CORE })[0];
        if (!(invaderCore instanceof StructureInvaderCore)) {
            return;
        }
        const collapseEffect = invaderCore.effects.find(e => e.effect === EFFECT_COLLAPSE_TIMER);
        if (!collapseEffect) {
            return;
        }
        const closingTime = collapseEffect.ticksRemaining + Game.time;
        Memory.sectors[room.mem.sectorName].stronghold = {
            room: room.name,
            level: invaderCore.level,
            endsAt: closingTime
        };
    }
}

const ROLE_NAME$7 = roles.AttackerRanged;
class AttackerRanged {
    static handle() {
        Creeps.getByRole(ROLE_NAME$7)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(55, () => TickAction.add(() => this.flagSpawner()));
        General.interval(200, () => TickAction.add(() => this.flagDowngradeSpawner()));
        General.interval(50, () => TickAction.add(() => this.newbieAttackSpawner()));
        // General.interval(50, () => TickAction.add(() => this.powerBankCompetitionSpawner()));
    }
    static handleCreep(creep) {
        var _a, _b, _c;
        this.clearTargetPos(creep);
        this.heal(creep);
        this.attack(creep);
        if (creep.targetFlag && (creep.targetFlag.roomMem.safeModeEndsAt || ((_b = (_a = creep.targetFlag.room) === null || _a === void 0 ? void 0 : _a.controller) === null || _b === void 0 ? void 0 : _b.safeMode))) {
            creep.recycleFinal(1500);
            return;
        }
        if ((_c = creep.targetRoomModel) === null || _c === void 0 ? void 0 : _c.isInSafeMode) {
            creep.recycleFinal(1500);
            return;
        }
        // creep.boost({ minTicksToLive: 1000 }) ||
        //   // this.idle(creep) ||
        //   // this.escapeSuperiorOffensive(creep) || // when room offensive bigger then my offensive by multiple times
        //   this.kite(creep) || // when next tick calculated loss
        //   this.waitMeleAttacker(creep) ||
        //   // this.moveToHostileStructure(creep) ||
        //   // this.standAtFlagTemp(creep) ||
        //   // this.moveToHostileAttacker(creep) ||
        //   this.moveToFlagRoom(creep) ||
        //   this.moveToHostile(creep) ||
        //   // this.moveToTargetRoom(creep) ||
        //   this.moveToHostileStructure(creep) ||
        //   // this.moveOnToConstruction(creep) ||
        //   this.moveToInvaderCore(creep) ||
        //   this.moveToFlag(creep);
        creep.boost({ minTicksToLive: 1000 }) ||
            // this.goUnderRampart(creep) ||
            // this.moveToHealer(creep) ||
            this.escapeToHealUp(creep) ||
            this.moveToFlagRoom(creep) ||
            this.kite(creep) || // when next tick calculated loss
            // kite to other room
            this.waitMeleAttacker(creep) ||
            this.moveToConstructionSite(creep, 2000) ||
            this.moveToHostile(creep) ||
            this.moveToHostileStructure(creep) ||
            this.moveToHostileRampart(creep) ||
            this.moveToInvaderCore(creep) ||
            this.moveToConstructionSite(creep, 1000) ||
            this.moveToFlag(creep);
        // creep.boost({ minTicksToLive: 1000 }) || this.moveToFlagRoom(creep) || this.moveToFlag(creep);
    }
    static recovering(creep) {
        if (creep.hitsMax === creep.hits) {
            creep.memory.recovering = undefined;
            return false;
        }
        if (!creep.memory.recovering && creep.hits / creep.hitsMax > 0.8) {
            return false;
        }
        creep.memory.recovering = true;
        return true;
    }
    static escapeToHealUp(creep) {
        const AVOID_RANGE = 5;
        if (!this.recovering(creep)) {
            return false;
        }
        const hostiles = creep.pos.findInRange(FIND_HOSTILE_CREEPS, AVOID_RANGE, {
            filter: c => c.attackPower || c.rangedAttackPower
        });
        if (hostiles.length === 0) {
            return false;
        }
        const ret = PathFinder.search(creep.pos, creep.room.find(FIND_HOSTILE_CREEPS).map(c => ({ pos: c.pos, range: AVOID_RANGE })), {
            flee: true,
            swampCost: 20,
            plainCost: 1,
            roomCallback(roomName) {
                const matrix = new PathFinder.CostMatrix();
                if (roomName === creep.room.name) {
                    creep.room
                        .find(FIND_STRUCTURES)
                        .filter(s => OBSTACLE_OBJECT_TYPES.includes(s.structureType) ||
                        (s.structureType === STRUCTURE_RAMPART && !s.my))
                        .forEach(wall => matrix.set(wall.pos.x, wall.pos.y, 254));
                    creep.room.find(FIND_CREEPS).forEach(c => matrix.set(c.pos.x, c.pos.y, 254));
                }
                return matrix;
            }
        });
        // if (ret.incomplete) {
        //   if (this.creep.homeRoom && this.creep.homeRoom.storage) {
        //     this.creep.travel(this.creep.homeRoom.storage);
        //     return true;
        //   } else {
        //     return false;
        //   }
        // }
        creep.moveByPath(ret.path);
        return true;
    }
    static clearTargetPos(creep) {
        var _a;
        const targetRoomName = ((_a = creep.targetFlag) === null || _a === void 0 ? void 0 : _a.pos.roomName) || creep.memory.targetRoom;
        if (!targetRoomName) {
            return;
        }
        if (targetRoomName !== creep.room.name) {
            creep.memory.targetPos = undefined;
            return;
        }
        const roomLog = creep.room.getEventLog();
        if (roomLog.filter(l => l.event === EVENT_OBJECT_DESTROYED && l.data.type !== "creep").length > 0) {
            creep.memory.targetPos = undefined;
            return;
        }
    }
    static standAtFlagTemp(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        if (creep.targetFlag.color !== COLOR_BLUE || creep.targetFlag.secondaryColor !== COLOR_RED) {
            return false;
        }
        if (!creep.pos.isEqualTo(creep.targetFlag.pos)) {
            return false;
        }
        return true;
    }
    // private static moveOnToConstruction(creep: Creep): boolean {}
    static heal(creep) {
        creep.healMele() || creep.prehealMele();
    }
    static attack(creep) {
        creep.rangedBestAttack();
    }
    static flagDowngradeSpawner() {
        Flags.flags(FlagType.controllerAttacker).forEach(flag => {
            const targetRoomName = flag.pos.roomName;
            const roomModel = RoomModel.get(targetRoomName);
            if (roomModel.ownerUsername !== USERNAME.ME && roomModel.isInSafeMode) {
                return;
            }
            const creepsCount = Creeps.creepsCountWithQue({
                minTicksToLive: 800,
                role: ROLE_NAME$7,
                targetRoom: flag.pos.roomName
            });
            if (creepsCount >= 1) {
                return;
            }
            const spawnRooms = Geo.closestHomeRoomsByRange(targetRoomName, 3, {
                maxDistance: MAX_EXPANSION_RANGE * 2,
                minLevel: 8
            });
            Spawns.addToQue(spawnRooms, {
                body: BodyParts.new().rangedAttack(20).move(25).heal(5),
                priority: 3 /* Medium */,
                role: ROLE_NAME$7,
                memory: {
                    targetRoom: flag.pos.roomName
                }
            });
            spawnRooms.forEach(room => (room.mem.increasedSpawnUntil = Game.time + 1500));
        });
    }
    static newbieAttackSpawner() {
        const que = Creeps.queByRole(ROLE_NAME$7);
        const creeps = Creeps.getByRole(ROLE_NAME$7).filter(c => !c.ticksToLive || c.ticksToLive > 500);
        Rooms.memoryObjectRoomValues.forEach(room => {
            if (Game.cpu.bucket < 1000) {
                return;
            }
            if (room.isMine) {
                return;
            }
            if (room.ownerUsername === "XianDengDuoQi") {
                return;
            }
            if (room.isInSafeMode()) {
                return this.harassRemotesSpawner(room, que, creeps);
            }
            // if (roomModel.level >= 7) {
            //   return;
            // }
            if (!room.ownerUsername) {
                return;
            }
            // if (room.ownerUsername === "6g3y") {
            //   return;
            // }
            // if (FRIENDLIES.includes(roomModel.ownerUsername)) {
            //   return;
            // }
            if (!room.hostileCreepCount) {
                return;
            }
            if ((room.towerCount || 0) > 0 && (room.hitsDefenceBuildingAverageHits || 0) > 1000000) {
                return;
            }
            if (room.status === "closed" || room.status === "respawn") {
                return;
            }
            const creepsCount = que.filter(c => { var _a; return ((_a = c.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === room.roomName; }).length +
                creeps.filter(c => c.memory.targetRoom === room.roomName).length;
            switch (room.towerCount || 0) {
                // case 6:
                // case 5:
                // case 4:
                case 3:
                    if (creepsCount >= 1) {
                        return;
                    }
                    return this.newbieThreeTowerAttackSpawner(room);
                case 2:
                    if (creepsCount >= 1) {
                        return;
                    }
                    return this.newbieTwoTowerAttackSpawner(room);
                case 1:
                    if (creepsCount >= 1) {
                        return;
                    }
                    return this.newbieOneTowerAttackSpawner(room);
                case 0:
                    return this.newbieTowerlessAttackSpawner(room, creepsCount);
            }
        });
    }
    static powerBankCompetitionSpawner() {
        const que = Creeps.queByRole(ROLE_NAME$7);
        const creeps = Creeps.getByRole(ROLE_NAME$7).filter(c => !c.ticksToLive || c.ticksToLive > 500);
        Object.values(Memory.powerBanks).forEach(adventure => {
            if (!adventure.hasCompetitors) {
                return;
            }
            if (adventure.attackersCount >= 9) {
                return;
            }
            if (adventure.hits === 0) {
                return;
            }
            const creepCount = que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === adventure.targetRoom; }).length +
                creeps.filter(c => c.memory.targetRoom === adventure.targetRoom).length;
            if (creepCount >= 2) {
                return;
            }
            const spawnRooms = adventure.homeRooms.map(roomName => Game.rooms[roomName]).filter(Boolean);
            for (let i = 0; i < 3 - creepCount; i++) {
                Spawns.addToQue(spawnRooms, {
                    body: BodyParts.new().rangedAttack(15).move(25).heal(10),
                    // boosts: [BOOST_ALIAS.RANGED_ATTACK_3, BOOST_ALIAS.MOVE_3, BOOST_ALIAS.HEAL_3, BOOST_ALIAS.TOUGH_3],
                    priority: 3 /* Medium */,
                    role: ROLE_NAME$7,
                    memory: {
                        targetRoom: adventure.targetRoom
                    }
                });
            }
        });
    }
    static newbieThreeTowerAttackSpawner(room) {
        const spawnRooms = Geo.closestHomeRoomsByRange(room.roomName, 2, {
            minLevel: 8,
            maxDistance: MAX_EXPANSION_RANGE,
            room: (r) => !r.isAbandoning &&
                r.store[RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE] > 400 &&
                r.store[RESOURCE_CATALYZED_GHODIUM_ALKALIDE] > 200 &&
                r.store[RESOURCE_CATALYZED_KEANIUM_ALKALIDE] > 300 &&
                r.store[RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE] > 300
        });
        if (spawnRooms.length === 0) {
            return;
        }
        Log.room(room.roomName, "spawning beginner siege for 3 tower");
        Spawns.addToQue(spawnRooms, {
            body: new BodyParts().add(TOUGH, 5).add(RANGED_ATTACK, 15).add(MOVE, 10).add(HEAL, 20).get(),
            priority: 3 /* Medium */,
            role: ROLE_NAME$7,
            boosts: [BOOST_ALIAS.TOUGH_3, BOOST_ALIAS.HEAL_3, BOOST_ALIAS.RANGED_ATTACK_3, BOOST_ALIAS.MOVE_3],
            memory: {
                targetRoom: room.roomName
            }
        });
    }
    static newbieTwoTowerAttackSpawner(room) {
        const spawnRooms = Geo.closestHomeRoomsByRange(room.roomName, 2, {
            minLevel: 8,
            maxDistance: MAX_EXPANSION_RANGE,
            room: (r) => !r.isAbandoning &&
                r.store[RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE] > 400 &&
                r.store[RESOURCE_CATALYZED_GHODIUM_ALKALIDE] > 200 &&
                r.store[RESOURCE_CATALYZED_KEANIUM_ALKALIDE] > 400
        });
        if (spawnRooms.length === 0) {
            return;
        }
        Log.room(room.roomName, "spawning beginner siege for 2 tower");
        Spawns.addToQue(spawnRooms, {
            body: new BodyParts().add(TOUGH, 4).add(MOVE, 25).add(RANGED_ATTACK, 11).add(HEAL, 10).get(),
            priority: 3 /* Medium */,
            role: ROLE_NAME$7,
            boosts: [BOOST_ALIAS.TOUGH_3, BOOST_ALIAS.HEAL_3, BOOST_ALIAS.RANGED_ATTACK_3],
            memory: {
                targetRoom: room.roomName
            }
        });
    }
    static newbieOneTowerAttackSpawner(room) {
        const spawnRooms = Geo.closestHomeRoomsByRange(room.roomName, 2, {
            minLevel: 8,
            maxDistance: MAX_EXPANSION_RANGE,
            room: (r) => !r.isAbandoning &&
                r.store[BOOST_ALIAS.RANGED_ATTACK_3] > 200 &&
                r.store[BOOST_ALIAS.MOVE_3] > 100 &&
                r.store[BOOST_ALIAS.HEAL_3] > 100 &&
                r.store[BOOST_ALIAS.TOUGH_3] > 100
        });
        if (spawnRooms.length === 0) {
            return;
        }
        Log.room(room.roomName, "spawning beginner siege for 1 tower");
        Spawns.addToQue(spawnRooms, {
            body: BodyParts.new().tough(5).rangedAttack(30).move(10).heal(5),
            boosts: [BOOST_ALIAS.RANGED_ATTACK_3, BOOST_ALIAS.MOVE_3, BOOST_ALIAS.HEAL_3, BOOST_ALIAS.TOUGH_3],
            priority: 3 /* Medium */,
            role: ROLE_NAME$7,
            memory: {
                targetRoom: room.roomName
            }
        });
    }
    static newbieTowerlessAttackSpawner(room, creepsCount) {
        const deaths = room.recentDeaths || 0;
        const kills = room.recentKills || 0;
        if (deaths + kills === 0) {
            if (creepsCount >= 2) {
                return;
            }
            const spawnRooms = Geo.closestHomeRoomsByRange(room.roomName, 2, {
                minLevel: 8,
                maxDistance: 20,
                room: r => !r.isAbandoning
            });
            if (spawnRooms.length === 0) {
                return;
            }
            Spawns.addToQue(spawnRooms, {
                body: (room.hostileCreepCount || 0) > 3
                    ? BodyParts.new().rangedAttack(20).move(25).heal(5)
                    : BodyParts.new().move(6).rangedAttack(5).heal(1),
                priority: 3 /* Medium */,
                role: ROLE_NAME$7,
                memory: {
                    targetRoom: room.roomName
                }
            });
        }
        else if (deaths >= 7) {
            if (creepsCount >= 1) {
                return;
            }
            const spawnRooms = Geo.closestHomeRoomsByRange(room.roomName, 2, {
                minLevel: 8,
                maxDistance: 20,
                room: r => !r.isAbandoning
            });
            if (spawnRooms.length === 0) {
                return;
            }
            Spawns.addToQue(spawnRooms, {
                body: BodyParts.new().tough(5).rangedAttack(30).move(10).heal(5),
                boosts: [BOOST_ALIAS.RANGED_ATTACK_3, BOOST_ALIAS.MOVE_3, BOOST_ALIAS.HEAL_3, BOOST_ALIAS.TOUGH_3],
                priority: 3 /* Medium */,
                role: ROLE_NAME$7,
                memory: {
                    targetRoom: room.roomName
                }
            });
        }
        else if (deaths + kills > 0) {
            if (creepsCount >= 1) {
                return;
            }
            const spawnRooms = Geo.closestHomeRoomsByRange(room.roomName, 2, {
                minLevel: 8,
                maxDistance: 20,
                room: r => !r.isAbandoning
            });
            if (spawnRooms.length === 0) {
                return;
            }
            Spawns.addToQue(spawnRooms, {
                body: BodyParts.new().rangedAttack(20).move(25).heal(5),
                priority: 3 /* Medium */,
                role: ROLE_NAME$7,
                memory: {
                    targetRoom: room.roomName
                }
            });
        }
    }
    static harassRemotesSpawner(room, que, creeps) {
        Object.values(Game.map.describeExits(room.roomName)).forEach(exitRoomName => {
            if (!exitRoomName) {
                return;
            }
            const exitRoom = Rooms.memory(exitRoomName);
            if (exitRoom.type === RoomTypeEnum.SK) {
                return;
            }
            if (exitRoom.ownerUsername) {
                return;
            }
            if (exitRoom.reservationUsername && exitRoom.reservationUsername !== room.ownerUsername) {
                return;
            }
            if (exitRoom.hostileCreepCount === 0) {
                return;
            }
            if ((exitRoom.towerCount || 0) > 0) {
                return;
            }
            if (exitRoom.status === "closed" || exitRoom.status === "respawn") {
                return;
            }
            const creepsCount = que.filter(c => { var _a; return ((_a = c.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === exitRoom.roomName; }).length +
                creeps.filter(c => c.memory.targetRoom === exitRoom.roomName).length;
            if (creepsCount > 0) {
                return;
            }
            const spawnRooms = Geo.closestHomeRoomsByRange(exitRoom.roomName, 2, {
                minLevel: 8,
                maxDistance: 20,
                room: r => !r.isAbandoning
            });
            if (spawnRooms.length === 0) {
                return;
            }
            Spawns.addToQue(spawnRooms, {
                body: (exitRoom.recentDeaths || 0) > 0
                    ? BodyParts.new().add(RANGED_ATTACK, 20).add(MOVE, 25).add(HEAL, 5).get()
                    : BodyParts.new().rangedAttack(5).move(6).heal(),
                priority: 3 /* Medium */,
                role: ROLE_NAME$7,
                memory: {
                    targetRoom: exitRoom.roomName
                }
            });
        });
    }
    static flagSpawner() {
        Flags.flags(FlagType.rangedAttackerTier0, FlagType.rangedAttackerTier1, FlagType.rangedAttackerTier2, FlagType.rangedAttackerTier3).forEach(flag => {
            const targetRoomName = flag.pos.roomName;
            const roomModel = RoomModel.get(targetRoomName);
            if (roomModel.ownerUsername !== USERNAME.ME && roomModel.isInSafeMode) {
                return;
            }
            // const spawnRoom = Geo.closestHomeRoomByRange(targetRoomName, {
            //   maxDistance: 20,
            //   minLevel: 8
            // });
            //
            // if (!spawnRoom) {
            //   return;
            // }
            //
            // const distance = Geo.findRouteCached(flag.pos.roomName, spawnRoom.name).length;
            //
            // const creepsCount = Creeps.creepsCountWithQue({
            //   minTicksToLive: 150 + 50 + distance * 50,
            //   role: ROLE_NAME,
            //   targetFlag: flag.name
            // });
            const creepsCount = Creeps.creepsCountWithQue({
                minTicksToLive: 600,
                role: ROLE_NAME$7,
                targetFlag: flag.name
            });
            if (creepsCount >= 1) {
                return;
            }
            const spawnRooms = Geo.closestHomeRoomsByRange(targetRoomName, 3, {
                maxDistance: MAX_EXPANSION_RANGE * 2,
                minLevel: 8
            });
            const body = this.getFlagBody(flag);
            Spawns.addToQue(spawnRooms, Object.assign(Object.assign({}, body), { priority: 3 /* Medium */, role: ROLE_NAME$7, memory: {
                    targetFlag: flag.name
                } }));
            spawnRooms.forEach(room => (room.mem.increasedSpawnUntil = Game.time + 1500));
        });
    }
    static getFlagBody(flag) {
        const flagType = Flags.getType(flag);
        if (flagType === FlagType.rangedAttackerTier3) {
            return {
                body: BodyParts.new().tough(5).rangedAttack(30).move(10).heal(5),
                boosts: [BOOST_ALIAS.TOUGH_3, BOOST_ALIAS.HEAL_3, BOOST_ALIAS.RANGED_ATTACK_3, BOOST_ALIAS.MOVE_3]
            };
        }
        if (flagType === FlagType.rangedAttackerTier2) {
            return {
                body: BodyParts.new().tough(4).rangedAttack(23).move(13).heal(10),
                boosts: [BOOST_ALIAS.TOUGH_3, BOOST_ALIAS.HEAL_2, BOOST_ALIAS.RANGED_ATTACK_2, BOOST_ALIAS.MOVE_2]
            };
        }
        if (flagType === FlagType.rangedAttackerTier1) {
            return {
                body: BodyParts.new().tough(2).rangedAttack(26).move(17).heal(5),
                boosts: [BOOST_ALIAS.TOUGH_3, BOOST_ALIAS.HEAL_1, BOOST_ALIAS.RANGED_ATTACK_1, BOOST_ALIAS.MOVE_1]
            };
        }
        return {
            body: BodyParts.new().rangedAttack(13).move(25).heal(10).rangedAttack(2),
            boosts: [BOOST_ALIAS.TOUGH_3]
        };
    }
    static idle(creep) {
        const creepsInRange = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3);
        const creepsNotOnEdge = creepsInRange.filter(c => !c.pos.isRoomEdge);
        if (creepsNotOnEdge.length > 0) {
            return false;
        }
        if (creep.memory.idleUntill && creep.memory.idleUntill > Game.time) {
            return true;
        }
        const creepsOnEdge = creepsInRange.filter(c => c.pos.isRoomEdge);
        if (creepsOnEdge.length > 0) {
            creep.memory.idleUntill = Game.time + 10;
            return true;
        }
        return false;
    }
    static waitMeleAttacker(creep) {
        if (creep.room.controller && creep.room.controller.my && creep.room.controller.safeMode) {
            return false;
        }
        const hostileMele = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3, { filter: c => c.attackPower && !c.isNPC });
        if (hostileMele.length > 0) {
            return true;
        }
        return false;
    }
    static moveToFlag(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        if (creep.pos.isEqualTo(creep.targetFlag.pos)) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.targetFlag);
        if (distance === 1 && creep.targetFlag.pos.hasCreep) {
            return true;
        }
        creep.travel(creep.targetFlag, { range: 0 });
        return true;
    }
    static moveToHostileAttacker(creep) {
        var _a;
        const hostile = ((_a = creep.room.controller) === null || _a === void 0 ? void 0 : _a.owner) ? creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
            filter: c => !!c.body.find(b => b.type === ATTACK || b.type === RANGED_ATTACK) &&
                !c.isNPC &&
                !c.pos.isRoomEdge &&
                !c.pos.rampart &&
                !c.isFriendly
        })
            : creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {
                filter: c => !!c.body.find(b => b.type === ATTACK || b.type === RANGED_ATTACK) &&
                    !c.isNPC &&
                    !c.pos.isRoomEdge &&
                    !c.pos.rampart &&
                    !c.isFriendly
            });
        if (!hostile) {
            return false;
        }
        const distance = creep.pos.getRangeTo(hostile);
        if (hostile.attackPower) {
            creep.travel(hostile, {
                range: hostile.attackPower ? 2 : 0,
                ignoreCreeps: false,
                obstacles: creep.room.edgePositions.map(p => p.pos)
            });
        }
        else {
            if (distance > 1) {
                creep.travel(hostile, {
                    range: 1,
                    ignoreCreeps: false,
                    freshPath: true,
                    obstacles: creep.room.edgePositions.map(p => p.pos)
                });
            }
            else {
                if (!hostile.pos.isRoomEdge) {
                    creep.moveTo(hostile);
                }
            }
        }
        return true;
    }
    static findBestPositionForHostileRamparts(creep) {
        var _a;
        const positions = {};
        const storage = ((_a = creep.room.storage) === null || _a === void 0 ? void 0 : _a.isWorthless) ? undefined : creep.room.storage;
        const ramparts = creep.room.find(FIND_HOSTILE_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_RAMPART
        });
        const walls = creep.room.find(FIND_STRUCTURES, { filter: s => s.structureType === STRUCTURE_WALL });
        const myCreeps = creep.room.find(FIND_MY_CREEPS);
        ramparts.forEach(rampart => {
            rampart.pos.openSpots.forEach(pos => {
                if (positions[`${pos.x}-${pos.y}`]) {
                    return;
                }
                if (myCreeps.filter(c => c.memory.targetPos && c.memory.targetPos.x === pos.x && c.memory.targetPos.y === pos.y)
                    .length > 0) {
                    return;
                }
                if (pos.rampart && !pos.rampart.my) {
                    return;
                }
                if (storage && !storage.pos.rampart && storage.pos.getRangeTo(pos.x, pos.y) <= 4) {
                    return;
                }
                if (pos.creep && pos.creep.id !== creep.id) {
                    return;
                }
                if (pos.findInRange(FIND_MY_CREEPS, 2, { filter: c => c.dismantlePower >= 500 }).length > 0) {
                    return;
                }
                if (pos.findInRange(FIND_HOSTILE_STRUCTURES, 1, { filter: s => s.structureType === STRUCTURE_RAMPART }).length ===
                    0) {
                    return;
                }
                positions[`${pos.x}-${pos.y}`] = pos;
            });
        });
        const bestPositions = Object.values(positions)
            .filter(pos => {
            const ret = PathFinder.search(creep.pos, pos, {
                maxRooms: 1,
                roomCallback(roomName) {
                    const matrix = new PathFinder.CostMatrix();
                    ramparts.forEach(rampart => {
                        matrix.set(rampart.pos.x, rampart.pos.y, 255);
                    });
                    walls.forEach(wall => {
                        matrix.set(wall.pos.x, wall.pos.y, 255);
                    });
                    return matrix;
                }
            });
            return !ret.incomplete;
        })
            .sort((a, b) => {
            const aDamage = a
                .findInRange(FIND_HOSTILE_STRUCTURES, 3, { filter: s => s.structureType === STRUCTURE_RAMPART })
                .reduce((total, rampart) => {
                const range = a.getRangeTo(rampart);
                const damage = MASS_RANGED_ATTACK_DECAY[range];
                return total + damage;
            }, 0);
            const bDamage = b
                .findInRange(FIND_HOSTILE_STRUCTURES, 3, { filter: s => s.structureType === STRUCTURE_RAMPART })
                .reduce((total, rampart) => {
                const range = b.getRangeTo(rampart);
                const damage = MASS_RANGED_ATTACK_DECAY[range];
                return total + damage;
            }, 0);
            return bDamage - aDamage;
        });
        return bestPositions[0];
    }
    static moveToHostileRampart(creep) {
        if (!creep.memory.targetPos) {
            const bestPos = this.findBestPositionForHostileRamparts(creep);
            if (!bestPos) {
                return false;
            }
            creep.memory.targetPos = { x: bestPos.x, y: bestPos.y };
        }
        if (!creep.memory.targetPos) {
            return false;
        }
        if (creep.memory.targetPos.x === creep.pos.x && creep.memory.targetPos.y === creep.pos.y) {
            return true;
        }
        creep.travel({ pos: new RoomPosition(creep.memory.targetPos.x, creep.memory.targetPos.y, creep.room.name) }, {
            range: 0,
            ignoreCreeps: false
        });
        return true;
    }
    static moveToHostileStructure(creep) {
        const structure = creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
            filter: s => s.structureType !== STRUCTURE_RAMPART &&
                s.structureType !== STRUCTURE_POWER_BANK &&
                (s.structureType !== STRUCTURE_STORAGE || s.isWorthless) &&
                s.hits > 0 &&
                !s.pos.rampart
        });
        if (!structure) {
            return false;
        }
        const distance = creep.pos.getRangeTo(structure);
        if (distance > 1) {
            creep.travel(structure, { range: 1 });
        }
        return true;
    }
    static moveToHostile(creep) {
        var _a;
        const hostile = ((_a = creep.room.controller) === null || _a === void 0 ? void 0 : _a.owner) ? creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
            filter: c => !c.isNPC && !c.pos.isRoomEdge && !c.pos.rampart && c.body.length > 1,
            costCallback: (roomName, costMatrix) => {
                if (creep.room.name !== roomName) {
                    return costMatrix;
                }
                creep.room
                    .find(FIND_MY_STRUCTURES, { filter: s => s.structureType === STRUCTURE_RAMPART })
                    .forEach(rampart => {
                    costMatrix.set(rampart.pos.x, rampart.pos.y, 1);
                });
                return costMatrix;
            }
        })
            : creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {
                filter: c => !c.isNPC && !c.pos.isRoomEdge && !c.pos.rampart && c.body.length > 1
            });
        if (!hostile) {
            return false;
        }
        const distance = creep.pos.getRangeTo(hostile);
        if (hostile.pos.isRoomEdge && distance <= 3) {
            return true;
        }
        if (distance > 1) {
            creep.travel(hostile, {
                range: 1
            });
        }
        else if (!hostile.pos.isRoomEdge) {
            creep.moveTo(hostile);
        }
        return true;
    }
    static moveToInvaderCore(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        if (creep.room.name !== creep.targetFlag.pos.roomName) {
            return false;
        }
        if (!creep.room.invaderCore) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.invaderCore);
        if (distance > 1) {
            creep.travel(creep.room.invaderCore, { range: 1 });
        }
        else {
            creep.moveTo(creep.room.invaderCore);
        }
        return true;
    }
    static moveToConstructionSite(creep, minProgress) {
        const construction = creep.pos.findClosestByPath(FIND_HOSTILE_CONSTRUCTION_SITES, {
            filter: c => c.progress > minProgress && !c.pos.rampart
        });
        if (!construction) {
            return false;
        }
        const distance = creep.pos.getRangeTo(construction);
        if (distance > 1) {
            creep.travel(construction, { range: 1 });
        }
        else {
            creep.moveTo(construction, { range: 0 });
        }
        return true;
    }
    static moveToHealer(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        if (creep.targetFlag.pos.roomName !== creep.pos.roomName) {
            return false;
        }
        const healer = creep.pos.findClosestByRange(FIND_MY_CREEPS, { filter: c => c.healPower > 1000 });
        if (!healer) {
            return false;
        }
        const distance = creep.pos.getRangeTo(healer);
        if (distance > 1) {
            creep.travel(healer);
        }
        else {
            creep.moveTo(healer, { range: 0 });
        }
        return true;
    }
    static moveToFlagRoom(creep) {
        var _a;
        const targetRoom = ((_a = creep.targetFlag) === null || _a === void 0 ? void 0 : _a.pos.roomName) || creep.memory.targetRoom;
        if (!targetRoom) {
            return false;
        }
        if (creep.room.name === targetRoom) {
            return false;
        }
        (creep.targetFlag ? creep.travel(creep.targetFlag) : false) || creep.travelToRoom(targetRoom);
        return true;
    }
    // private static escapeSuperiorOffensive(creep: Creep): boolean {
    //   const hostileDamage = creep.room.model.hostilePower(RANGED_ATTACK);
    //
    //   const myDamage = creep.room
    //     .find(FIND_MY_CREEPS)
    //     .reduce((total, c) => total + c.attackPower + c.rangedAttackPower, 0);
    //
    //   if(hostileDamage)
    // }
    static kite(creep) {
        if (creep.room.controller && creep.room.controller.my && creep.room.controller.safeMode) {
            return false;
        }
        // if my damage + heal < enemy damage + heal = kite
        // const expectedDamage = creep.expectedDamageTakenNextTick2();
        //
        // const expectedRealDamage = creep.realDamageTaken(expectedDamage);
        //
        // const allyHealPower = creep.pos.findInRange(FIND_MY_CREEPS, 1).reduce((total, c) => total + c.healPower, 0);
        // const allyDamage =
        //   creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3)[0]?.expectedDamageTakenNextTick2({
        //     hostileCreeps: false,
        //     hostileTowers: false,
        //     myCreeps: true,
        //     myTowers: true
        //   }) || 0;
        // Log.object(creep, expectedRealDamage, allyHealPower + allyDamage);
        const hostiles = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 2, {
            filter: c => c.attackPower
        });
        if (hostiles.length === 0) {
            return false;
        }
        const ret = PathFinder.search(creep.pos, creep.room.find(FIND_HOSTILE_CREEPS).map(c => ({ pos: c.pos, range: c.rangedAttackPower ? 5 : 3 })), {
            flee: true,
            swampCost: 20,
            plainCost: 1,
            roomCallback(roomName) {
                const matrix = new PathFinder.CostMatrix();
                if (roomName === creep.room.name) {
                    creep.room
                        .find(FIND_STRUCTURES)
                        .filter(s => OBSTACLE_OBJECT_TYPES.includes(s.structureType) ||
                        (s.structureType === STRUCTURE_RAMPART && !s.my))
                        .forEach(wall => matrix.set(wall.pos.x, wall.pos.y, 254));
                    creep.room.find(FIND_EXIT).forEach(exit => matrix.set(exit.x, exit.y, 2));
                    creep.room.find(FIND_CREEPS).forEach(c => matrix.set(c.pos.x, c.pos.y, 254));
                }
                return matrix;
            }
        });
        // if (ret.incomplete) {
        //   if (this.creep.homeRoom && this.creep.homeRoom.storage) {
        //     this.creep.travel(this.creep.homeRoom.storage);
        //     return true;
        //   } else {
        //     return false;
        //   }
        // }
        creep.moveByPath(ret.path);
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], AttackerRanged, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], AttackerRanged, "flagDowngradeSpawner", null);
__decorate([
    Profiler.subprofile("spawn")
], AttackerRanged, "newbieAttackSpawner", null);
__decorate([
    Profiler.subprofile("spawn")
], AttackerRanged, "powerBankCompetitionSpawner", null);
__decorate([
    Profiler.subprofile("spawn")
], AttackerRanged, "flagSpawner", null);

const CONFIG$7 = Config.Dismantler;
const ROLE_NAME$6 = roles.Dismantler;
class Dismantler {
    static handle() {
        Creeps.getByRole(ROLE_NAME$6)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.worker(creep);
        });
        General.interval(CONFIG$7.spawnFlagInterval, () => TickAction.add(() => this.flagSpawner()));
    }
    static worker(creep) {
        this.setFlagObjective(creep);
        if (creep.memory.action === "wait") {
            return;
        }
        if (creep.boost()) {
            return;
        }
        creep.rangedBestAttack();
        this.dismantleOnPath(creep) || this.attack(creep);
        this.move(creep);
    }
    static flagSpawner() {
        const creeps = Creeps.getByRole(ROLE_NAME$6);
        const que = Creeps.queByRole(ROLE_NAME$6);
        Flags.flags(FlagType.dismantler).forEach(flag => {
            const targetRoomName = flag.pos.roomName;
            const roomModel = RoomModel.get(targetRoomName);
            if (roomModel.isInSafeMode) {
                return;
            }
            if (flag.room) {
                const flagStructures = flag.pos.lookFor(LOOK_STRUCTURES);
                if (flagStructures.length === 0) {
                    flag.setColor(COLOR_ORANGE, COLOR_ORANGE);
                    Log.room(flag.room, "Dismantler", "removing flag cause no structure on it");
                    return;
                }
                if (flagStructures.length === 1 &&
                    flagStructures[0] instanceof StructureStorage &&
                    !flagStructures[0].isWorthless) {
                    flag.setColor(COLOR_ORANGE, COLOR_ORANGE);
                    Log.room(flag.room, "Dismantler", "removing flag cause no structure on it");
                    return;
                }
            }
            const spawnRoom = Geo.closestHomeRoomByRange(targetRoomName, {
                maxDistance: MAX_EXPANSION_RANGE * 1.5,
                minLevel: 8
            });
            if (!spawnRoom) {
                return;
            }
            const distance = Geo.findRouteCached(flag.pos.roomName, spawnRoom.name).length;
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetFlag) === flag.name; }).length > 0) {
                return;
            }
            if (creeps
                .filter(c => c.memory.targetFlag === flag.name)
                .filter(c => !c.ticksToLive || c.ticksToLive > 200 + 50 + distance * 50).length > 0) {
                return;
            }
            const body = this.getFlagBody(flag);
            Spawns.addToQue(spawnRoom, Object.assign(Object.assign({}, body), { priority: 3 /* Medium */, role: ROLE_NAME$6, memory: {
                    targetFlag: flag.name
                } }));
        });
    }
    static getFlagBody(flag) {
        Flags.getType(flag);
        // if (flagType === FlagType.rangedAttackerTier2){
        //   return {
        //     body: BodyParts.new().tough(4).move(13).rangedAttack(30).heal(5),
        //     boosts: [
        //       BOOST_ALIAS.TOUGH_2,
        //       BOOST_ALIAS.HEAL_2,
        //       BOOST_ALIAS.RANGED_ATTACK_2,
        //       BOOST_ALIAS.MOVE_2
        //     ]
        //   };
        // }
        // if (flagType === FlagType.rangedAttackerTier1){
        //   return {
        //     body: BodyParts.new().tough(2).rangedAttack(30).move(13).heal(5),
        //     boosts: [
        //       BOOST_ALIAS.TOUGH_1,
        //       BOOST_ALIAS.HEAL_1,
        //       BOOST_ALIAS.RANGED_ATTACK_1,
        //       BOOST_ALIAS.MOVE_1
        //     ]
        //   };
        // }
        return {
            body: BodyParts.new().rangedAttack().work(24).move(25),
            boosts: [BOOST_ALIAS.DISMANTLE_3, BOOST_ALIAS.RANGED_ATTACK_3]
        };
    }
    static setFlagObjective(creep) {
        var _a;
        if (!creep.targetFlag) {
            return;
        }
        if (!creep.targetFlag.room) {
            return;
        }
        if (creep.targetFlag.memory.lastX === creep.targetFlag.pos.x &&
            creep.targetFlag.memory.lastY === creep.targetFlag.pos.y &&
            creep.targetFlag.memory.lastRoom === creep.targetFlag.pos.roomName) {
            return;
        }
        if (!creep.homeRoom) {
            return;
        }
        if (!creep.homeRoom.storage) {
            return;
        }
        console.log(`generating dismantle path plan in room ${creep.targetFlag.pos.roomName}`);
        const route = Geo.findRouteCached(creep.homeRoom.name, creep.targetFlag.pos.roomName);
        const ret = PathFinder.search(creep.homeRoom.storage.pos, creep.targetFlag.pos, {
            swampCost: 1,
            plainCost: 1,
            maxOps: 40000,
            maxCost: Infinity,
            maxRooms: 64,
            roomCallback: (roomName) => {
                if (!route.includes(roomName)) {
                    return false;
                }
                const matrix = new PathFinder.CostMatrix();
                if (!creep.targetFlag || !creep.targetFlag.room) {
                    return matrix;
                }
                if (roomName !== creep.targetFlag.pos.roomName) {
                    return matrix;
                }
                const defenceStructures = creep.targetFlag.room
                    .find(FIND_STRUCTURES)
                    .filter(s => s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_WALL)
                    .sort((a, b) => b.hits - a.hits);
                if (defenceStructures.length) {
                    const highestHits = defenceStructures[0].hits;
                    defenceStructures.forEach(s => {
                        matrix.set(s.pos.x, s.pos.y, 50 + Math.ceil((200 * s.hits) / highestHits));
                    });
                }
                return matrix;
            }
        });
        const roomPath = ret.path.filter(p => { var _a; return p.roomName === ((_a = creep.targetFlag) === null || _a === void 0 ? void 0 : _a.pos.roomName); });
        const roomToEnterFrom = (_a = ret.path.reverse().find(p => { var _a; return p.roomName !== ((_a = creep.targetFlag) === null || _a === void 0 ? void 0 : _a.pos.roomName); })) === null || _a === void 0 ? void 0 : _a.roomName;
        roomPath.forEach(p => {
            new RoomVisual(p.roomName).circle(p, { radius: 0.2 });
        });
        creep.targetFlag.memory.lastX = creep.targetFlag.pos.x;
        creep.targetFlag.memory.lastY = creep.targetFlag.pos.y;
        creep.targetFlag.memory.lastRoom = creep.targetFlag.pos.roomName;
        creep.targetFlag.memory.attackPath = roomPath.map(r => ({ roomName: r.roomName, x: r.x, y: r.y }));
        creep.targetFlag.memory.enterRoomFrom = roomToEnterFrom;
    }
    static move(creep) {
        var _a, _b;
        if (creep.targetFlag && (creep.targetFlag.roomMem.safeModeEndsAt || ((_b = (_a = creep.targetFlag.room) === null || _a === void 0 ? void 0 : _a.controller) === null || _b === void 0 ? void 0 : _b.safeMode))) {
            creep.recycleFinal(1500);
            return;
        }
        this.moveToHeal(creep) ||
            this.moveToFlagRoom(creep) ||
            this.moveToTargetRoom(creep) ||
            this.moveToNextStructure(creep) ||
            this.moveToFlag(creep) ||
            this.moveToStructures(creep) ||
            this.moveToWalls(creep);
    }
    static moveToPreEnterRoom(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        if (creep.pos.roomName === creep.targetFlag.pos.roomName) {
            return false;
        }
        const enterRoomFrom = creep.targetFlag.memory.enterRoomFrom;
        if (!enterRoomFrom) {
            return false;
        }
        if (creep.pos.roomName === enterRoomFrom) {
            return false;
        }
        creep.travelToRoom(enterRoomFrom);
        return true;
    }
    static moveToFlagRoom(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        if (creep.pos.roomName === creep.targetFlag.pos.roomName) {
            return false;
        }
        if (creep.targetFlag.memory.attackPath) {
            creep.travel({
                pos: new RoomPosition(creep.targetFlag.memory.attackPath[0].x, creep.targetFlag.memory.attackPath[0].y, creep.targetFlag.pos.roomName)
            }, {
                range: 0,
                ignoreHostiles: false
            });
        }
        else {
            creep.travelToRoom(creep.targetFlag.pos.roomName, { ignoreHostiles: false });
        }
        return true;
    }
    static moveToTargetRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        if (creep.pos.roomName === creep.memory.targetRoom) {
            return false;
        }
        creep.travelToRoom(creep.memory.targetRoom, { ignoreHostiles: false });
        return true;
    }
    static moveToHeal(creep) {
        // if (creep.room.name !== creep.Misc.targetRoom) return false;
        if (creep.hits === creep.hitsMax) {
            return false;
        }
        if (creep.hitsMax - creep.hits < 50) {
            return false;
        }
        const healer = creep.pos.findClosestByRange(FIND_MY_CREEPS, {
            filter: c => c.body.filter(body => body.type === HEAL).length > 0
        });
        if (!healer) {
            return false;
        }
        const distance = creep.pos.getRangeTo(healer);
        if (distance > 1) {
            creep.travel(healer, { range: 1 });
        }
        else {
            creep.moveTo(healer);
        }
        return true;
    }
    static dismantleOnPath(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        if (!creep.targetFlag.memory.attackPath) {
            return false;
        }
        const room = creep.targetFlag.room;
        if (!room) {
            return false;
        }
        const nextStructurePos = creep.targetFlag.memory.attackPath.find(p => room
            .lookForAt(LOOK_STRUCTURES, p.x, p.y)
            .filter(s => s.structureType !== STRUCTURE_ROAD && s.structureType !== STRUCTURE_CONTAINER).length > 0);
        if (!nextStructurePos) {
            return false;
        }
        const nextStructure = new RoomPosition(nextStructurePos.x, nextStructurePos.y, nextStructurePos.roomName).lookFor(LOOK_STRUCTURES)[0];
        if (!nextStructure) {
            return false;
        }
        if (!creep.pos.isNearTo(nextStructure)) {
            return false;
        }
        creep.dismantle(nextStructure);
        return true;
    }
    static attack(creep) {
        var _a;
        if (creep.room.name !== (((_a = creep.targetFlag) === null || _a === void 0 ? void 0 : _a.pos.roomName) || creep.memory.targetRoom)) {
            return false;
        }
        if (creep.room.my) {
            return false;
        }
        if (!creep.dismantlePower) {
            return false;
        }
        const structures = creep.pos.findInRange(FIND_STRUCTURES, 1, { filter: s => s.hits > 0 });
        const hostileStructure = structures
            .filter(s => s.structureType !== STRUCTURE_RAMPART && s.structureType !== STRUCTURE_WALL && !s.pos.rampart)
            .sort((a, b) => a.hits - b.hits)[0] ||
            structures
                .filter(s => (s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_WALL) &&
                s.pos.lookFor(LOOK_FLAGS).filter(f => f.color === COLOR_YELLOW && f.secondaryColor === COLOR_GREY).length >
                    0)
                .sort((a, b) => a.hits - b.hits)[0] ||
            structures
                .filter(s => s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_WALL)
                .sort((a, b) => a.hits - b.hits)[0];
        if (!hostileStructure) {
            return false;
        }
        creep.dismantle(hostileStructure);
        return true;
    }
    static meleHostileStructure(creep) {
        const structures = creep.pos.findInRange(FIND_HOSTILE_STRUCTURES, 1, {
            filter: s => s.structureType !== STRUCTURE_CONTROLLER && (!(s instanceof StructureStorage) || s.isWorthless)
        });
        const onPathStructure = structures.find(s => {
            if (!creep.targetFlag) {
                return false;
            }
            if (!creep.targetFlag.memory.attackPath) {
                return false;
            }
            return !!creep.targetFlag.memory.attackPath.find(p => p.x === s.pos.x && p.y === s.pos.y);
        });
        if (onPathStructure) {
            return onPathStructure;
        }
        const rampartlessStructure = structures
            .filter(s => s.structureType !== STRUCTURE_RAMPART && s.structureType !== STRUCTURE_STORAGE && !s.pos.hasRampart)
            .sort((a, b) => a.hits - b.hits)[0];
        if (rampartlessStructure) {
            return rampartlessStructure;
        }
        return (structures
            .filter(s => s.structureType !== STRUCTURE_STORAGE && (s.structureType === STRUCTURE_RAMPART || !s.pos.hasRampart))
            .sort((a, b) => a.hits - b.hits)[0] || null);
    }
    static meleWallStructure(creep) {
        return (creep.pos
            .findInRange(FIND_STRUCTURES, 1, { filter: s => s.structureType === STRUCTURE_WALL })
            .sort((a, b) => a.hits - b.hits)[0] || null);
    }
    static attackRandom(creep) {
        const structure = this.meleHostileStructure(creep) || this.meleWallStructure(creep);
        if (!structure) {
            return false;
        }
        creep.dismantle(structure);
        return true;
    }
    static attackOnFlag(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        if (!creep.pos.inRangeTo(creep.targetFlag, 1)) {
            return false;
        }
        const structures = creep.targetFlag.pos
            .lookFor(LOOK_STRUCTURES)
            .filter(s => !(s instanceof StructureStorage) || s.isWorthless);
        if (structures.length === 0) {
            return false;
        }
        creep.dismantle(structures[0]);
        return true;
    }
    static moveToWalls(creep) {
        if (this.meleWallStructure(creep)) {
            return false;
        }
        const bestStructure = creep.pos.findClosestByPath(FIND_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_WALL
        });
        if (!bestStructure) {
            return false;
        }
        creep.room.visual.circle(bestStructure.pos, { radius: 0.4, fill: "#fff" });
        creep.moveTo(bestStructure, {
            ignoreCreeps: false,
            range: 1
        });
        return true;
    }
    static lowestPathableDefence(creep, room) {
        const structures = room
            .find(FIND_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_WALL || s.structureType === STRUCTURE_RAMPART
        })
            .sort((a, b) => a.hits - b.hits);
        for (const structure of structures) {
            const ret = PathFinder.search(creep.pos, { pos: structure.pos, range: 1 }, {
                maxRooms: 1,
                roomCallback(roomName) {
                    const matrix = Rooms.matrix(roomName);
                    room
                        .find(FIND_CREEPS)
                        .filter(c => c.id !== creep.id)
                        .forEach(c => matrix.set(c.pos.x, c.pos.y, 255));
                    return matrix;
                }
            });
            if (ret.incomplete) {
                continue;
            }
            return structure;
        }
        return;
    }
    static targetStructure(creep) {
        var _a;
        if (!creep.target || creep.target.pos.roomName !== creep.pos.roomName) {
            creep.target =
                ((_a = creep.targetFlag) === null || _a === void 0 ? void 0 : _a.pos.lookFor(LOOK_STRUCTURES)[0]) ||
                    creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
                        filter: s => s.structureType !== STRUCTURE_CONTROLLER &&
                            s.structureType !== STRUCTURE_RAMPART &&
                            (!(s instanceof StructureStorage) || s.isWorthless) &&
                            s.pos.lookFor(LOOK_STRUCTURES).filter(ls => ls.structureType === STRUCTURE_RAMPART).length === 0 &&
                            s.structureType !== STRUCTURE_INVADER_CORE &&
                            s.hits > 0
                    }) ||
                    creep.pos.findClosestByPath(FIND_STRUCTURES, {
                        filter: s => (s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_WALL) &&
                            s.pos
                                .lookFor(LOOK_STRUCTURES)
                                .filter(ls => ls.structureType !== STRUCTURE_ROAD &&
                                ls.structureType !== STRUCTURE_CONTAINER &&
                                ls.structureType !== STRUCTURE_RAMPART &&
                                ls.structureType !== STRUCTURE_WALL).length > 0 &&
                            s.hits > 0
                    }) ||
                    creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
                        filter: s => s.structureType !== STRUCTURE_CONTROLLER &&
                            s.structureType !== STRUCTURE_RAMPART &&
                            (!(s instanceof StructureStorage) || s.isWorthless) &&
                            s.structureType !== STRUCTURE_INVADER_CORE
                    }) ||
                    this.lowestPathableDefence(creep, creep.room) ||
                    creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
                        filter: s => s.structureType !== STRUCTURE_CONTROLLER &&
                            (!(s instanceof StructureStorage) || s.isWorthless) &&
                            s.structureType !== STRUCTURE_INVADER_CORE
                    });
        }
        return creep.target;
    }
    static moveToStructures(creep) {
        const target = this.targetStructure(creep);
        if (!target) {
            return false;
        }
        // const distance = creep.pos.getRangeTo(target);
        creep.room.visual.line(creep.pos, target.pos);
        creep.travel(target, {
            ignoreCreeps: false,
            freshPath: true,
            range: 1
        });
        return true;
    }
    static moveToNextStructure(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        if (creep.targetFlag.pos.roomName !== creep.pos.roomName) {
            return false;
        }
        if (!creep.targetFlag.memory.attackPath) {
            return false;
        }
        const room = creep.targetFlag.room;
        if (!room) {
            return false;
        }
        const nextStructureMemory = creep.targetFlag.memory.attackPath.find(p => room
            .lookForAt(LOOK_STRUCTURES, p.x, p.y)
            .filter(s => s.structureType !== STRUCTURE_ROAD && s.structureType !== STRUCTURE_CONTAINER).length > 0);
        if (!nextStructureMemory) {
            return false;
        }
        const nextStructurePos = new RoomPosition(nextStructureMemory.x, nextStructureMemory.y, room.name);
        const distance = creep.pos.getRangeTo(nextStructurePos);
        // creep.travelTo(creep.targetFlag, { allowSK: false });
        creep.travel({ pos: nextStructurePos }, {
            costRoomHighway: 1,
            costRoomStandart: 2,
            costRoomSk: 20,
            maxOps: distance <= 3 ? 200 : undefined,
            ignoreCreeps: distance > 2,
            freshPath: distance <= 2,
            range: creep.room.name === creep.targetFlag.pos.roomName ? 1 : 3
        });
        // }
        return true;
    }
    static moveToFlag(creep) {
        if (!creep.targetFlag) {
            return false;
        }
        // if (creep.targetFlag.room) {
        //   const target = creep.targetFlag.pos.lookFor(LOOK_STRUCTURES)[0];
        //   if (!target) return false;
        //
        //   const distance = creep.pos.getRangeTo(target);
        //   if (distance <= 1) return true;
        //   creep.travelTo(target, { maxRooms: 64, maxOps: 200_000 });
        // } else {
        if (creep.room.name === creep.targetFlag.pos.roomName) {
            if (creep.pos.getRangeTo(creep.targetFlag) <= 1) {
                return false;
            }
            const structures = creep.targetFlag.pos.lookFor(LOOK_STRUCTURES);
            if (structures.length === 0) {
                return false;
            }
            if (structures.length === 1) {
                const structure = structures[0];
                if (structure instanceof StructureStorage && !structure.isWorthless) {
                    return false;
                }
            }
        }
        const distance = creep.pos.getRangeTo(creep.targetFlag);
        // creep.travelTo(creep.targetFlag, { allowSK: false });
        creep.travel(creep.targetFlag, {
            // ignoreCreeps: false,
            // ignoreHostiles: false,
            costRoomHighway: 1,
            costRoomStandart: 2,
            costRoomSk: 20,
            maxOps: distance <= 3 ? 200 : undefined,
            ignoreCreeps: distance > 2,
            freshPath: distance <= 2,
            range: creep.room.name === creep.targetFlag.pos.roomName ? 1 : 3
        });
        // }
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], Dismantler, "worker", null);
__decorate([
    Profiler.subprofile("spawn")
], Dismantler, "flagSpawner", null);

const CONFIG$6 = Config.BaseEnergyHarvester;
const CONFIG_NEWBIE = Config.BaseNewbie;
class BaseEnergyHarvester {
    static handle() {
        const creeps = Creeps.getByRole(CONFIG$6.roleName);
        creeps
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(60, () => TickAction.add(() => this.handleSpawn(creeps)));
    }
    static handleCreep(creep) {
        this.suicide(creep);
        this.storeEnergyMeleLink(creep);
        this.moveToTargetPos(creep) ||
            this.buildContainer(creep) ||
            this.repairContainer(creep) ||
            this.mine(creep) ||
            this.storeEnergy(creep);
    }
    static handleSpawn(creeps) {
        const que = Creeps.queByRole(CONFIG$6.roleName);
        const newbieCreeps = Creeps.getByRole(CONFIG_NEWBIE.roleName);
        Rooms.myRooms.forEach(room => {
            if (!room.center) {
                return;
            }
            if (!room.shouldConstruct) {
                return;
            }
            if (newbieCreeps.filter(c => c.memory.targetRoom === room.name).length > 0) {
                return;
            }
            room.find(FIND_SOURCES).forEach(source => {
                var _a, _b;
                if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.sourceId) === source.id; }).length > 0) {
                    return;
                }
                const sourceCreeps = creeps.filter(c => c.memory.sourceId === source.id && (!c.ticksToLive || c.ticksToLive > 150));
                if (room.level >= 8) {
                    if (sourceCreeps.length >= 1) {
                        return;
                    }
                    const roomSourceOptions = room.sourceOptions(source);
                    if (!roomSourceOptions.miningPos) {
                        Log.object(source, "cant find mining pos", room.name);
                        return;
                    }
                    const targetPos = new RoomPosition(roomSourceOptions.miningPos.x, roomSourceOptions.miningPos.y, room.name);
                    if (!targetPos) {
                        return;
                    }
                    const workPartsNeeded = Math.ceil(source.energyCapacityWithRegen / ENERGY_REGEN_TIME / 2);
                    Spawns.addToQue(room, {
                        body: new BodyParts().move(1).work(2).carry(),
                        optionalBody: BodyParts.new()
                            .work(workPartsNeeded)
                            .move(workPartsNeeded)
                            .carry(workPartsNeeded / 3),
                        priority: 2 /* High */,
                        role: CONFIG$6.roleName,
                        memory: {
                            sourceId: source.id,
                            links: source.links.map(link => link.id),
                            container: (_a = source.container) === null || _a === void 0 ? void 0 : _a.id,
                            targetPos: { x: targetPos.x, y: targetPos.y },
                            targetRoom: source.room.name
                        }
                    });
                }
                else {
                    if (sourceCreeps.length >= source.pos.openSpots.length) {
                        return;
                    }
                    const currentWorkParts = sourceCreeps.reduce((total, creep) => total + creep.body.filter(b => b.type === WORK).length, 0);
                    const workPartsNeeded = Math.ceil(source.energyCapacityWithRegen / ENERGY_REGEN_TIME / 2);
                    if (currentWorkParts >= workPartsNeeded) {
                        return;
                    }
                    const roomSourceOptions = room.sourceOptions(source);
                    if (!roomSourceOptions.miningPos) {
                        Log.object(source, "cant find mining pos", room.name);
                        return;
                    }
                    const targetPos = new RoomPosition(roomSourceOptions.miningPos.x, roomSourceOptions.miningPos.y, room.name);
                    if (!targetPos) {
                        return;
                    }
                    Spawns.addToQue(room, {
                        body: new BodyParts().move(1).work(2),
                        optionalBody: new BodyParts().addMultiple(source.links.length > 0 ? [MOVE, WORK, WORK, CARRY] : [MOVE, WORK, WORK], Math.ceil(workPartsNeeded / 2)),
                        priority: 2 /* High */,
                        role: CONFIG$6.roleName,
                        memory: {
                            sourceId: source.id,
                            links: source.links.map(link => link.id),
                            container: (_b = source.container) === null || _b === void 0 ? void 0 : _b.id,
                            targetPos: { x: targetPos.x, y: targetPos.y },
                            targetRoom: source.room.name
                        }
                    });
                }
            });
        });
    }
    static buildContainer(creep) {
        if (!creep.source) {
            return false;
        }
        if (!creep.source.containerConstruction) {
            return false;
        }
        if (creep.store.energy === 0) {
            return false;
        }
        if (creep.pos.getRangeTo(creep.source.containerConstruction) > 3) {
            return false;
        }
        if (creep.store.energy / creep.store.getCapacity() < 0.5) {
            return false;
        }
        creep.build(creep.source.containerConstruction);
        return true;
    }
    static repairContainer(creep) {
        if (!creep.container) {
            return false;
        }
        if (creep.pos.getRangeTo(creep.container) > 3) {
            return false;
        }
        if (creep.container.hits > 200000) {
            return false;
        }
        if (creep.store.energy === 0) {
            return false;
        }
        if (creep.store.energy / creep.store.getCapacity() < 0.5) {
            return false;
        }
        creep.repair(creep.container);
        return true;
    }
    static storeEnergyMeleLink(creep) {
        if (!creep.room.my) {
            return;
        }
        if (creep.harvestPower * 2 <= creep.store.getFreeCapacity()) {
            return;
        }
        if (!creep.source) {
            return;
        }
        const link = creep.links
            .filter(l => l.store.getFreeCapacity(RESOURCE_ENERGY) > 0)
            .sort((a, b) => b.store.energy - a.store.energy)[0];
        if (!link) {
            return;
        }
        const distance = creep.pos.getRangeTo(link);
        if (distance <= 1) {
            creep.transfer(link, RESOURCE_ENERGY);
        }
    }
    static storeEnergy(creep) {
        if (!creep.room.my) {
            return false;
        }
        if (!creep.source) {
            return false;
        }
        const link = creep.links.sort((a, b) => a.store.energy - b.store.energy)[0];
        if (!link) {
            return false;
        }
        if (creep.transfer(link, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
            creep.travel(link, { ignoreCreeps: false });
        }
        return true;
    }
    static moveToTargetPos(creep) {
        var _a;
        if (!creep.memory.container && !((_a = creep.memory.links) === null || _a === void 0 ? void 0 : _a.length)) {
            return false;
        }
        if (!creep.memory.targetPos) {
            return false;
        }
        const targetPos = new RoomPosition(creep.memory.targetPos.x, creep.memory.targetPos.y, creep.room.name);
        if (creep.pos.isEqualTo(targetPos)) {
            return false;
        }
        creep.travel({ pos: targetPos }, { range: 0 });
        return true;
    }
    static mine(creep) {
        if (!creep.source) {
            return false;
        }
        if (creep.source.energy === 0) {
            return false;
        }
        if (creep.links.length) {
            if (creep.store.getFreeCapacity() < creep.harvestPower) {
                return false;
            }
        }
        const distance = creep.pos.getRangeTo(creep.source);
        if (distance > 2) {
            creep.travel(creep.source, { range: 1 });
        }
        else if (distance === 2) {
            creep.travel(creep.source, {
                ignoreCreeps: false,
                maxOps: 200,
                freshPath: true,
                range: 1,
                logIncomplete: false
            });
        }
        else {
            creep.harvest(creep.source);
        }
        return true;
    }
    static build(creep) {
        if (!(creep.target instanceof ConstructionSite)) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.target);
        if (distance > 3) {
            creep.travel(creep.target, { ignoreCreeps: false });
        }
        else if (distance > 1) {
            creep.travel(creep.target, {
                ignoreCreeps: false,
                freshPath: true,
                maxOps: 200
            });
        }
        if (distance <= 3) {
            creep.build(creep.target);
        }
        return true;
    }
    static suicide(creep) {
        if (!creep.source) {
            return false;
        }
        if (creep.pos.getRangeTo(creep.source) !== 2) {
            return false;
        }
        if (!creep.homeRoom) {
            return false;
        }
        if (creep.homeRoom.level < 5) {
            return false;
        }
        if (!creep.ticksToLive) {
            return false;
        }
        const replacemenet = creep.pos.findInRange(FIND_MY_CREEPS, 2, {
            filter: c => c.memory.sourceId === creep.memory.sourceId && c.memory.role === CONFIG$6.roleName && c.id !== creep.id
        })[0];
        if (!replacemenet) {
            return false;
        }
        if (!replacemenet.ticksToLive) {
            return false;
        }
        if (replacemenet.ticksToLive > creep.ticksToLive) {
            return false;
        }
        creep.say("die");
        replacemenet.die();
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseEnergyHarvester, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseEnergyHarvester, "handleSpawn", null);

const MAX_STORAGE_BASIC_MINERALS = 5000;
class FactoryStructureWorker {
    static handle() {
        General.interval(20, () => {
            Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            });
        });
    }
    static handleRoom(room) {
        if (room.level < 8) {
            return;
        }
        if (!room.factory) {
            return;
        }
        if (room.factory.cooldown) {
            return;
        }
        this.decompress(room.factory, room.storage) || this.compress(room.factory, room.storage);
    }
    static compress(factory, storage) {
        if (!storage) {
            return false;
        }
        // todo
        return true;
    }
    static decompress(factory, storage) {
        if (!storage) {
            return false;
        }
        for (const barResource in RESOURCE_BAR_DECOMPRESS_OUTCOMES) {
            const outcomeResource = RESOURCE_BAR_DECOMPRESS_OUTCOMES[barResource];
            if (!outcomeResource) {
                continue;
            }
            if ((factory.store[barResource] || 0) < 100) {
                continue;
            }
            if (storage.store[outcomeResource] > MAX_STORAGE_BASIC_MINERALS) {
                continue;
            }
            factory.produce(outcomeResource);
            return true;
        }
        return false;
    }
}

const CONFIG$5 = Config.BaseFactoryConstruction;
class BaseFactoryConstruction {
    static handle() {
        General.interval(CONFIG$5.interval, () => {
            Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            });
        });
    }
    static handleRoom(room) {
        if (room.level < 8) {
            return;
        }
        if (room.isGclFarm) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (!room.storage) {
            return;
        }
        if (room.factory) {
            return;
        }
        if (!Constructor.canBuildMore()) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_FACTORY)) {
            return;
        }
        const bestPosition = this.safePositions(room).sort((a, b) => {
            if (!room.storage)
                return -99999;
            return a.getRangeTo(room.storage) - b.getRangeTo(room.storage);
        })[0];
        if (!bestPosition) {
            return;
        }
        Constructor.createConstructionSite(room, bestPosition.x, bestPosition.y, STRUCTURE_FACTORY);
    }
    static safePositions(room) {
        const terrain = room.getTerrain();
        const positions = [];
        for (let x = 2; x <= 47; x++) {
            for (let y = 2; y <= 47; y++) {
                if (this.isPositionTooCloseToExit(room, x, y))
                    continue;
                if (this.isPositionTooCloseToLab(room, x, y))
                    continue;
                if (this.isPositionTooCloseToController(room, x, y))
                    continue;
                if (this.isPositionTooCloseToCenter(room, x, y))
                    continue;
                if (this.isPositionTooCloseToSource(room, x, y))
                    continue;
                if (this.isPositionTooCloseToMineral(room, x, y))
                    continue;
                if (this.isPositionTooCloseToNuker(room, x, y))
                    continue;
                if (!this.isPositionValid(room, terrain, x, y))
                    continue;
                positions.push(new RoomPosition(x, y, room.name));
            }
        }
        return positions;
    }
    static isPositionTooCloseToMineral(room, x, y) {
        return !!room.find(FIND_MINERALS).find(s => s.pos.getRangeTo(x, y) <= 4);
    }
    static isPositionTooCloseToNuker(room, x, y) {
        return (!!room
            .find(FIND_MY_STRUCTURES, { filter: s => s.structureType === STRUCTURE_NUKER })
            .find(s => s.pos.getRangeTo(x, y) <= 4) ||
            !!room
                .find(FIND_MY_CONSTRUCTION_SITES, { filter: s => s.structureType === STRUCTURE_NUKER })
                .find(s => s.pos.getRangeTo(x, y) <= 4));
    }
    static isPositionTooCloseToSource(room, x, y) {
        return !!room.find(FIND_SOURCES).find(s => s.pos.getRangeTo(x, y) <= 4);
    }
    static isPositionTooCloseToCenter(room, x, y) {
        if (!room.center)
            return true;
        return Math.max(Math.abs(x - room.center.x), Math.abs(y - room.center.y)) <= 4;
    }
    static isPositionTooCloseToLab(room, x, y) {
        return (new RoomPosition(x, y, room.name)
            .findInRange(FIND_FLAGS, 3)
            .filter(f => Flags.getType(f) === FlagType.baseLabBlock).length > 0);
    }
    static isPositionTooCloseToExit(room, x, y) {
        return new RoomPosition(x, y, room.name).findInRange(FIND_EXIT, 7).length > 0;
    }
    static isPositionTooCloseToController(room, x, y) {
        return (new RoomPosition(x, y, room.name).findInRange(FIND_STRUCTURES, 6, {
            filter: s => s.structureType === STRUCTURE_CONTROLLER
        }).length > 0);
    }
    static isPositionValid(room, terrain, x, y) {
        if (terrain.get(x, y) === TERRAIN_MASK_WALL)
            return false;
        const structures = room.lookForAt(LOOK_STRUCTURES, x, y);
        if (structures.length > 0)
            return false;
        const constructions = room.lookForAt(LOOK_CONSTRUCTION_SITES, x, y);
        if (constructions.length > 0)
            return false;
        return true;
    }
}

const CONFIG$4 = Config.BaseEnergyHarvesterHauler;
const CONFIG_HARVESTER = Config.BaseEnergyHarvester;
var Action$1;
(function (Action) {
    Action["pick"] = "pick";
    Action["spend"] = "spend";
})(Action$1 || (Action$1 = {}));
class BaseEnergyHarvesterHauler {
    static handle() {
        Creeps.getByRole(CONFIG$4.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(150, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        this.setAction(creep);
        if (creep.recycleFinal((creep.memory.targetDistance || 70) * 1.1)) {
            return;
        }
        switch (creep.memory.action) {
            case Action$1.spend:
                this.storeEnergyToStorage(creep) ||
                    this.storeToCenterContainer(creep) ||
                    this.storeEnergyToSpawn(creep) ||
                    this.moveToCenter(creep) ||
                    creep.idleAwayFrom([STRUCTURE_SPAWN], 3);
                break;
            case Action$1.pick:
                this.pickDroppedEnergy(creep) || this.withdrawEnergyFromContainer(creep) || this.moveNearSource(creep);
        }
    }
    static handleSpawn() {
        const harvesters = Creeps.getByRole(CONFIG_HARVESTER.roleName).filter(c => !c.ticksToLive || c.ticksToLive > 100);
        const que = Creeps.que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.role) === CONFIG$4.roleName; });
        const creeps = Creeps.getByRole(CONFIG$4.roleName).filter(c => !c.ticksToLive || c.ticksToLive > 50);
        Rooms.myRooms.forEach(room => {
            room.find(FIND_SOURCES).forEach(source => {
                var _a;
                if (source.links.length > 0) {
                    return;
                }
                if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.sourceId) === source.id; }).length > 0) {
                    return;
                }
                const sourceHarvesters = harvesters.filter(c => c.memory.sourceId === source.id);
                if (sourceHarvesters.length === 0) {
                    return;
                }
                const haulerCreeps = creeps.filter(c => c.memory.sourceId === source.id);
                const harvestPower = sourceHarvesters.reduce((total, creep) => total + creep.harvestPower, 0);
                const currentCarryCapacity = haulerCreeps.reduce((total, creep) => total + creep.store.getCapacity(), 0);
                const resourcePerTick = Math.min(harvestPower, Math.ceil(source.energyCapacityWithRegen / ENERGY_REGEN_TIME));
                const roomSourceOptions = room.sourceOptions(source);
                if (!roomSourceOptions.miningPos) {
                    Log.object(source, "missing mining position");
                    return;
                }
                const distance = room.distanceToTarget(source);
                const requiredCarryCapacity = distance * 2 * resourcePerTick;
                if (currentCarryCapacity >= requiredCarryCapacity) {
                    return;
                }
                Spawns.addToQue(room, {
                    body: new BodyParts().move(2).carry(2),
                    optionalBody: new BodyParts().addMultiple([MOVE, CARRY], requiredCarryCapacity / 50),
                    priority: 1 /* Higher */,
                    role: CONFIG$4.roleName,
                    memory: {
                        sourceId: source.id,
                        targetRoom: source.pos.roomName,
                        targetDistance: distance,
                        targetPos: roomSourceOptions.miningPos,
                        container: ((_a = source.container) === null || _a === void 0 ? void 0 : _a.id) || undefined
                    }
                });
            });
        });
    }
    static moveToCenter(creep) {
        if (!creep.homeRoom) {
            return false;
        }
        if (!creep.homeRoom.center) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.homeRoom.center);
        if (distance <= 6) {
            return false;
        }
        creep.travel({ pos: creep.homeRoom.center }, { range: 2 });
        return true;
    }
    static setAction(creep) {
        if (!creep.memory.action) {
            creep.memory.action = Action$1.pick;
            return;
        }
        if (creep.store.getUsedCapacity() === 0) {
            creep.memory.action = Action$1.pick;
        }
        else if (creep.store.getFreeCapacity() === 0) {
            creep.memory.action = Action$1.spend;
        }
    }
    static moveNearSource(creep) {
        if (!creep.source) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.source);
        if (distance <= 3) {
            return false;
        }
        creep.travel(creep.source, { cache: true, costSwamp: 10, costPlain: 2 });
        return true;
    }
    static storeToCenterContainer(creep) {
        if (!creep.homeRoom) {
            return false;
        }
        const container = creep.homeRoom.centerContainers
            .filter(c => c.store.getFreeCapacity(RESOURCE_ENERGY) > 0)
            .sort((a, b) => creep.pos.getRangeTo(a) - creep.pos.getRangeTo(b))[0];
        if (!container) {
            return false;
        }
        const distance = creep.pos.getRangeTo(container);
        if (distance <= 4 && container.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {
            return false;
        }
        if (distance > 1) {
            creep.travel(container);
        }
        else {
            creep.transfer(container, RESOURCE_ENERGY);
        }
        return true;
    }
    static storeEnergyToSpawn(creep) {
        if (!creep.homeRoom) {
            return false;
        }
        const spawn = creep.homeRoom.myActiveSpawns.find(s => s.store.getFreeCapacity(RESOURCE_ENERGY) > 0);
        if (!spawn) {
            return false;
        }
        const distance = creep.pos.getRangeTo(spawn);
        if (distance <= 4 && spawn.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {
            return false;
        }
        if (distance > 1) {
            creep.travel(spawn);
        }
        else {
            creep.transfer(spawn, RESOURCE_ENERGY);
        }
        return true;
    }
    static storeEnergyToStorage(creep) {
        if (!creep.homeRoom) {
            return false;
        }
        if (!creep.homeRoom.storage || !creep.homeRoom.storage.my) {
            return false;
        }
        if (!creep.homeRoom.storage.my) {
            return false;
        }
        if (creep.homeRoom.level < 4) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.homeRoom.storage);
        if (distance > 1) {
            creep.travel(creep.homeRoom.storage, { cache: true, costSwamp: 10, costPlain: 2 });
        }
        else {
            creep.transfer(creep.homeRoom.storage, RESOURCE_ENERGY);
        }
        return true;
    }
    static withdrawEnergyFromContainer(creep) {
        if (!creep.source) {
            return false;
        }
        if (!creep.source.container) {
            return false;
        }
        if (!creep.ticksToLive) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.source.container);
        if (distance > 1) {
            creep.travel(creep.source.container, { cache: true, costSwamp: 10, costPlain: 2 });
        }
        else {
            if (creep.ticksToLive > 250 && creep.source.container.store.energy < creep.store.getFreeCapacity()) {
                return true;
            }
            creep.withdraw(creep.source.container, RESOURCE_ENERGY);
        }
        return true;
    }
    static pickDroppedEnergy(creep) {
        if (!creep.source) {
            return false;
        }
        const droppedEnergy = creep.source.pos.findInRange(FIND_DROPPED_RESOURCES, 1, {
            filter: r => r.resourceType === RESOURCE_ENERGY && r.amount >= 20
        })[0];
        if (!droppedEnergy) {
            return false;
        }
        const distance = creep.pos.getRangeTo(droppedEnergy);
        if (distance > 1) {
            creep.travel(droppedEnergy, { cache: true, costSwamp: 10, costPlain: 2 });
        }
        else {
            creep.pickup(droppedEnergy);
        }
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseEnergyHarvesterHauler, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseEnergyHarvesterHauler, "handleSpawn", null);

function isCreepFriendlyRemote(creep) {
    var _a, _b;
    if (!((_b = (_a = creep.room.controller) === null || _a === void 0 ? void 0 : _a.reservation) === null || _b === void 0 ? void 0 : _b.username)) {
        return false;
    }
    if (!FRIENDLIES.includes(creep.owner.username)) {
        return false;
    }
    return creep.owner.username === creep.room.controller.reservation.username;
}

const CONFIG$3 = Config.PowerBankMinerDuo;
class PowerBankMinerDuo {
    static handle() {
        Duos.duosByName(CONFIG$3.duoName).forEach(duo => {
            this.worker(duo);
        });
        General.interval(CONFIG$3.spawnFlagInterval, () => TickAction.add(() => this.adventureSpawner()));
    }
    static worker(duo) {
        switch (duo.memory.stage) {
            case DuoGroupStage.SPAWNING: {
                duo.handleSpawning();
                break;
            }
            case DuoGroupStage.BOOSTING: {
                duo.handleBoosting();
                break;
            }
            case DuoGroupStage.WORKING: {
                if (!duo.attacker || !duo.healer) {
                    duo.memory.stage = DuoGroupStage.RETREATING;
                    return;
                }
                this.handleAttacker(duo.attacker);
                this.handleHealer(duo.healer, duo.attacker);
                this.groupUp(duo.attacker, duo.healer) ||
                    this.waitFatigue(duo.attacker, duo.healer) ||
                    this.travelToTargetRoom(duo, duo.attacker, duo.healer) ||
                    this.moveToHostile(duo, duo.attacker, duo.healer, 10) ||
                    this.moveToPowerBank(duo.attacker, duo.healer) ||
                    this.moveFromPower(duo.attacker, duo.healer) ||
                    this.setRetreatingStage(duo);
                break;
            }
            case DuoGroupStage.RETREATING: {
                if (duo.attacker) {
                    this.handleAttacker(duo.attacker);
                }
                if (duo.healer) {
                    this.handleHealer(duo.healer, duo.attacker);
                }
                if (duo.attacker && duo.healer) {
                    this.recycle(duo.attacker, duo.healer) ||
                        this.groupUp(duo.attacker, duo.healer) ||
                        this.moveToHostile(duo, duo.attacker, duo.healer, 50) ||
                        this.moveToHomeRoom(duo.attacker, duo.healer);
                }
                else {
                    duo.handleRetreating();
                }
                break;
            }
        }
    }
    static moveToHomeRoom(attacker, healer) {
        if (!attacker.homeRoom) {
            return false;
        }
        attacker.travelToRoom(attacker.homeRoom.name);
        healer.moveTo(attacker);
        return true;
    }
    static recycle(attacker, healer) {
        if (attacker.room.name !== attacker.memory.homeRoom) {
            return false;
        }
        attacker.recycleFinal(1500);
        healer.recycleFinal(1500);
        return true;
    }
    static setRetreatingStage(duo) {
        const adventure = Memory.powerBanks[duo.memory.targetRoom];
        if (adventure) {
            return false;
        }
        duo.memory.stage = DuoGroupStage.RETREATING;
        return true;
    }
    static waitFatigue(attacker, healer) {
        return attacker.fatigue !== 0 || healer.fatigue !== 0;
    }
    static groupUp(attacker, healer) {
        const distance = attacker.wpos.getRangeTo(healer.wpos);
        if (distance <= 1) {
            return false;
        }
        if (attacker.pos.isRoomEdge && distance <= 2) {
            return false;
        }
        if (healer.pos.isRoomEdge && distance <= 2) {
            return false;
        }
        healer.travel(attacker, { freshPath: true, ignoreCreeps: false });
        return true;
    }
    static moveFromPower(attacker, healer) {
        const power = attacker.pos.findClosestByRange(FIND_DROPPED_RESOURCES, { filter: r => r.resourceType === RESOURCE_POWER }) ||
            attacker.pos.findClosestByRange(FIND_RUINS, { filter: r => Object.keys(r.store).includes(RESOURCE_POWER) });
        if (!power) {
            return false;
        }
        if (power.pos.getRangeTo(attacker) >= 9) {
            return false;
        }
        const path = PathFinder.search(attacker.pos, { pos: power.pos, range: 10 }, { flee: true });
        attacker.moveByPath(path.path);
        healer.moveTo(attacker);
        return true;
    }
    static moveToPowerBank(attacker, healer) {
        if (!attacker.room.powerBank) {
            return false;
        }
        const distance = attacker.pos.getRangeTo(attacker.room.powerBank);
        if (distance >= 4) {
            attacker.travel(attacker.room.powerBank);
            healer.moveTo(attacker);
        }
        else if (distance > 1) {
            attacker.travel(attacker.room.powerBank, { ignoreCreeps: false, freshPath: true, maxOps: 2000 });
            healer.moveTo(attacker);
        }
        return true;
    }
    static moveToHostile(duo, attacker, healer, range) {
        if (duo.memory.targetRoom !== attacker.pos.roomName) {
            return false;
        }
        const hostile = attacker.pos
            .findInRange(FIND_HOSTILE_CREEPS, range, {
            filter: c => c.body.length > 1 && c.body.filter(b => b.type === HEAL).length > 10 && !isCreepFriendlyRemote(c)
        })
            .sort((a, b) => attacker.pos.getRangeTo(a) - attacker.pos.getRangeTo(b))[0] ||
            attacker.pos
                .findInRange(FIND_HOSTILE_CREEPS, range, { filter: c => c.body.length > 1 && !isCreepFriendlyRemote(c) })
                .sort((a, b) => attacker.pos.getRangeTo(a) - attacker.pos.getRangeTo(b))[0];
        if (!hostile) {
            return false;
        }
        const distance = attacker.pos.getRangeTo(hostile);
        if (distance > range) {
            return false;
        }
        if (attacker.pos.getRangeTo(hostile) !== 1 || !hostile.isOnRoomEdge) {
            attacker.travel(hostile, { freshPath: true, ignoreCreeps: false });
            healer.moveTo(attacker);
        }
        return true;
    }
    static travelToTargetRoom(duo, attacker, healer) {
        if (!duo.targetRoom) {
            return false;
        }
        if (duo.targetRoom.roomName === attacker.room.name) {
            return false;
        }
        attacker.travelToRoom(duo.targetRoom.roomName);
        healer.moveTo(attacker);
        return true;
    }
    static handleHealer(creep, attacker) {
        creep.rangedBestAttack();
        if (!creep.healPower) {
            return;
        }
        creep.healMele() || this.prehealAttackerNearPowerBank(creep, attacker) || creep.prehealMele();
    }
    static prehealAttackerNearPowerBank(creep, attacker) {
        if (!attacker) {
            return false;
        }
        if (!creep.room.powerBank) {
            return false;
        }
        if (creep.pos.getRangeTo(creep.room.powerBank) > 2) {
            return false;
        }
        creep.heal(attacker);
        return true;
    }
    static handleAttacker(creep) {
        if (creep.room.my) {
            return;
        }
        const target = this.attackableObject(creep);
        if (!target) {
            return;
        }
        if (target instanceof StructurePowerBank && creep.hits !== creep.hitsMax) {
            return;
        }
        creep.attack(target);
        return;
    }
    static attackableObject(creep) {
        const hostileCreep = creep.pos
            .findInRange(FIND_HOSTILE_CREEPS, 1)
            .filter(c => !isCreepFriendlyRemote(c))
            .sort((a, b) => b.healPower - a.healPower)[0] || null;
        if (hostileCreep) {
            return hostileCreep;
        }
        if (!creep.room.powerBank) {
            return null;
        }
        if (!this.shouldAttackPowerBank(creep)) {
            return null;
        }
        if (!creep.pos.isNearTo(creep.room.powerBank)) {
            return null;
        }
        return creep.room.powerBank;
    }
    static shouldAttackPowerBank(creep) {
        if (!creep.room.powerBank) {
            return false;
        }
        if ((creep.ticksToLive || 0) < 20) {
            return true;
        }
        return creep.room.powerBank.hits > 10000 || this.roomCarryCapacity(creep.room) >= creep.room.powerBank.power;
    }
    static roomCarryCapacity(room) {
        return room.find(FIND_MY_CREEPS).reduce((total, c) => total + c.store.getCapacity(RESOURCE_POWER), 0);
    }
    static adventureSpawner() {
        const creeps = Creeps.getByRole(CONFIG$3.duoName);
        const que = Creeps.queByRole(CONFIG$3.duoName);
        const duos = Duos.duosByName(CONFIG$3.duoName);
        Object.values(Memory.powerBanks).forEach(adventure => {
            if (adventure.hasCompetitors) {
                return;
            }
            if (adventure.hasAvoidingUsersNearby) {
                return;
            }
            const estimatedDuoLifetimeDamage = (1500 - PowerBankConfig.maxRange * 50) * 600;
            if (adventure.attackersCount >= 9) {
                return;
            }
            if (adventure.hits === 0) {
                return;
            }
            if (adventure.endsAt < Game.time + PowerBankConfig.maxRange * 50 + 500) {
                return;
            }
            const adventureQue = que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === adventure.targetRoom; });
            if (adventureQue.length > 0) {
                return;
            }
            const adventureDuos = duos.filter(d => d.memory.targetRoom === adventure.targetRoom);
            if (adventureDuos.filter(d => d.memory.stage === DuoGroupStage.SPAWNING).length > 0) {
                return;
            }
            const spawnRooms = adventure.homeRooms
                .map(roomName => Game.rooms[roomName])
                .filter(Boolean)
                .filter(room => !room.isSpawningDuo && !room.isSpawningQuad);
            const adventureAttackerCreeps = creeps.filter(c => c.memory.targetRoom === adventure.targetRoom && c.memory.duoAttacker === true);
            const estimatedDamageWithCurrentCreeps = adventureAttackerCreeps.reduce((total, creep) => total +
                ((creep.ticksToLive || 1500) - PowerBankConfig.maxRange * 50) * (adventure.hasCompetitors ? 1800 : 600), 0);
            if (estimatedDamageWithCurrentCreeps >= adventure.hits) {
                return;
            }
            if (adventureAttackerCreeps.length >= adventure.openSlotCount) {
                return;
            }
            if (adventure.hits < estimatedDamageWithCurrentCreeps) {
                return;
            }
            const duosCountNeeded = (adventure.hits - estimatedDamageWithCurrentCreeps) / estimatedDuoLifetimeDamage;
            if (duosCountNeeded <= 0) {
                return;
            }
            for (let i = 0; i < Math.min(duosCountNeeded, spawnRooms.length, adventure.openSlotCount, 2); i++) {
                const spawnRoom = spawnRooms[i];
                spawnRoom._isSpawningDuo = undefined;
                const duoId = Duos.create({
                    homeRoom: spawnRoom.name,
                    name: CONFIG$3.duoName,
                    targetRoom: adventure.targetRoom
                });
                Spawns.addToQue(spawnRoom, {
                    body: BodyParts.new().tough(5).move(25).attack(20),
                    // boosts: adventure.hasCompetitors ? [BOOST_TOUGH_TIER_3, BOOST_ATTACK_TIER_2] : [],
                    priority: 0 /* Highest */,
                    role: CONFIG$3.duoName,
                    memory: {
                        duoId,
                        duoAttacker: true,
                        targetRoom: adventure.targetRoom
                    }
                });
                Spawns.addToQue(spawnRoom, {
                    body: BodyParts.new().move(25).heal(25),
                    // boosts: adventure.hasCompetitors ? [BOOST_HEAL_TIER_3] : [],
                    priority: 0 /* Highest */,
                    role: CONFIG$3.duoName,
                    memory: {
                        duoId,
                        duoHealer: true,
                        targetRoom: adventure.targetRoom
                    }
                });
                adventure.attackersCount++;
                spawnRoom.mem.increasedSpawnUntil = Game.time + 2000;
                // Log.room(adventure.targetRoom, "spawning duo for power bank");
            }
            // for (let i = 0; i < 3; i++) {
            //   // todo fuckit just quad
            //   Spawns.addToQue(spawnRooms, {
            //     body: BodyParts.new().rangedAttack(20).move(25).heal(5),
            //     boosts: [],
            //     priority: SpawnPriority.High,
            //     role: roles.AttackerRanged,
            //     memory: {
            //       targetRoom: adventure.targetRoom
            //     }
            //   });
            // }
        });
    }
}
__decorate([
    Profiler.subprofile("duo")
], PowerBankMinerDuo, "worker", null);
__decorate([
    Profiler.subprofile("spawn")
], PowerBankMinerDuo, "adventureSpawner", null);

const CONFIG$2 = Config.PowerBankHauler;
class PowerBankHauler {
    static handle() {
        Creeps.getByRole(CONFIG$2.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$2.spawnInterval, () => TickAction.add(() => this.handleAdventureSpawn()));
    }
    static handleCreep(creep) {
        this.suicide(creep) ||
            creep.kite() ||
            this.moveToRoom(creep) ||
            this.withdrawPower(creep) ||
            this.pickPower(creep) ||
            this.moveToPowerBank(creep) ||
            this.moveToHomeRoom(creep) ||
            this.storePowerToTerminal(creep);
    }
    static handleAdventureSpawn() {
        const creeps = Creeps.getByRole(CONFIG$2.roleName).filter(c => !c.ticksToLive || c.ticksToLive > 300);
        const que = Creeps.queByRole(CONFIG$2.roleName);
        Object.values(Memory.powerBanks).forEach(adventure => {
            if (adventure.hasCompetitors) {
                return;
            }
            if (adventure.hasAvoidingUsersNearby) {
                return;
            }
            if (adventure.homeRooms.length === 0) {
                return;
            }
            const targetRoom = Game.rooms[adventure.targetRoom];
            if (!targetRoom) {
                return;
            }
            const multiplier = Math.min(2, adventure.openSlotCount);
            if (adventure.hits > multiplier * 500000) {
                return;
            }
            const creepsNeededInTotal = Math.ceil(adventure.power / 1250);
            const advenureCreeps = creeps.filter(c => c.memory.targetRoom === adventure.targetRoom);
            const adventureQue = que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === adventure.targetRoom; });
            const creepsCount = advenureCreeps.length + adventureQue.length;
            if (creepsCount >= creepsNeededInTotal) {
                return;
            }
            const spawnRooms = adventure.homeRooms.map(roomName => Game.rooms[roomName]).filter(Boolean);
            if (spawnRooms.length === 0) {
                return;
            }
            const closestRoom = spawnRooms[0];
            for (let i = 0; i < creepsNeededInTotal - creepsCount; i++) {
                Spawns.addToQue(spawnRooms, {
                    body: BodyParts.new().add(CARRY, 25).add(MOVE, 25),
                    priority: 1 /* Higher */,
                    role: CONFIG$2.roleName,
                    memory: {
                        targetRoom: adventure.targetRoom,
                        homeRoom: closestRoom.name
                    },
                    maxQueTime: 1500
                });
            }
        });
    }
    static suicide(creep) {
        if (!creep.memory.targetRoom || !Memory.powerBanks[creep.memory.targetRoom]) {
            return creep.recycleFinal(1500);
        }
        if (!creep.room.my) {
            return false;
        }
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > 1200) {
            return false;
        }
        return creep.recycleFinal();
    }
    static moveToPowerBank(creep) {
        if (creep.store.getUsedCapacity() > 0) {
            return false;
        }
        if (!creep.room.powerBank) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.powerBank);
        creep.travel(creep.room.powerBank, { range: 3, ignoreCreeps: false, freshPath: distance < 4 });
        return true;
    }
    static moveToRoom(creep) {
        if (creep.store.getUsedCapacity() > 0) {
            return false;
        }
        const targetRoom = creep.memory.targetRoom;
        if (!targetRoom) {
            return false;
        }
        return creep.travelToRoom(targetRoom);
    }
    static pickPower(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        const droppedPower = creep.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {
            filter: r => r.resourceType === RESOURCE_POWER
        });
        if (!droppedPower) {
            return false;
        }
        const distance = creep.pos.getRangeTo(droppedPower);
        if (distance >= 4) {
            creep.travel(droppedPower);
        }
        else if (distance > 1) {
            creep.travel(droppedPower, { ignoreCreeps: false, freshPath: true, maxOps: 1000 });
        }
        else {
            creep.pickup(droppedPower);
        }
        return true;
    }
    static withdrawPower(creep) {
        if (creep.store.getFreeCapacity() === 0) {
            return false;
        }
        const ruin = creep.pos.findClosestByRange(FIND_RUINS, {
            filter: r => r.store.power > 0
        });
        if (!ruin) {
            return false;
        }
        if (creep.withdraw(ruin, RESOURCE_POWER) === ERR_NOT_IN_RANGE) {
            creep.travel(ruin);
        }
        return true;
    }
    static moveToHomeRoom(creep) {
        if (creep.store.getUsedCapacity() === 0) {
            return false;
        }
        if (!creep.memory.homeRoom) {
            return false;
        }
        if (creep.memory.homeRoom === creep.room.name) {
            return false;
        }
        creep.travelToRoom(creep.memory.homeRoom);
        return true;
    }
    static storePowerToTerminal(creep) {
        if (creep.store.getUsedCapacity() === 0) {
            return false;
        }
        if (creep.memory.homeRoom !== creep.room.name) {
            return false;
        }
        const terminal = creep.room.terminal;
        if (!terminal) {
            return false;
        }
        if (creep.transfer(terminal, RESOURCE_POWER) === ERR_NOT_IN_RANGE) {
            creep.travel(terminal);
        }
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], PowerBankHauler, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], PowerBankHauler, "handleAdventureSpawn", null);

const COORDINATES = { x: 1, y: -1 };
class BaseCenterNewbieContainerConstruction {
    static handle() {
        General.interval(Config.BaseCenterNewbieContainerConstruction.interval, () => {
            Rooms.myRooms.forEach(room => {
                this.handleRoom(room);
            });
        });
    }
    static handleRoom(room) {
        if (room.isGclFarm) {
            return;
        }
        if (!room.shouldConstruct) {
            return;
        }
        if (!room.controller) {
            return;
        }
        if (room.level >= 6) {
            return;
        }
        if (!room.center) {
            return;
        }
        if (!Constructor.canBuildMore()) {
            return;
        }
        if (!Constructor.roomCanBuildMore(room, STRUCTURE_CONTAINER)) {
            return;
        }
        const x = room.center.x + COORDINATES.x;
        const y = room.center.y + COORDINATES.y;
        if (room
            .lookForAt(LOOK_STRUCTURES, x, y)
            .filter(s => s.structureType !== STRUCTURE_ROAD && s.structureType !== STRUCTURE_RAMPART).length > 0) {
            return;
        }
        if (room.lookForAt(LOOK_CONSTRUCTION_SITES, x, y).length > 0) {
            return;
        }
        room
            .lookForAt(LOOK_STRUCTURES, x, y)
            .filter(s => s.structureType === STRUCTURE_ROAD)
            .forEach(s => s.destroy());
        Constructor.createConstructionSite(room, x, y, STRUCTURE_CONTAINER);
    }
}

const CPU_HOME = 3.2;
const CPU_SK = 2.5; // should optimize
const CPU_STANDARD = {
    // 1: 0.8,
    1: 0.6,
    // 2: 1.2
    2: 0.9
};
const REMOTE_SOURCE_LIMIT = 10;
class MemoryRoomRemotes {
    static handle() {
        if (Game.cpu.bucket < 5000) {
            return;
        }
        if (Memory.remoteRooms === undefined || Memory.remoteSkRooms === undefined) {
            this.recreate();
        }
        else {
            General.interval(12000, () => this.recreate());
        }
        General.interval(50, () => this.updateMissingRemoteSources());
        General.interval(50, () => this.updateMissingRemoteSkSources());
        General.interval(50, () => this.updateMissingRemoteSkMinerals());
        General.interval(10, () => this.updateRemoteRoomAvoidance());
        General.interval(10, () => this.updateRemoteSkRoomAvoidance());
    }
    static updateRemoteRoomAvoidance() {
        if (!Memory.remoteRooms) {
            return;
        }
        Object.values(Memory.remoteRooms).forEach(remoteRoomMemory => {
            if (remoteRoomMemory.avoidUntill && remoteRoomMemory.avoidUntill > Game.time) {
                return;
            }
            for (const roomName of remoteRoomMemory.route) {
                if (Rooms.model(roomName).hostilePower(ATTACK, RANGED_ATTACK) > 0) {
                    remoteRoomMemory.avoidUntill = Game.time + 100;
                    return;
                }
            }
        });
    }
    static updateRemoteSkRoomAvoidance() {
        if (!Memory.remoteSkRooms) {
            return;
        }
        Object.values(Memory.remoteSkRooms).forEach(remoteRoomMemory => {
            if (remoteRoomMemory.avoidUntill && remoteRoomMemory.avoidUntill > Game.time) {
                return;
            }
            for (const roomName of remoteRoomMemory.route) {
                if (Rooms.model(roomName).hostilePower(ATTACK, RANGED_ATTACK) > 0) {
                    remoteRoomMemory.avoidUntill = Game.time + 100;
                    return;
                }
            }
        });
    }
    static updateMissingRemoteSkMinerals() {
        if (!Memory.remoteSkRooms) {
            return;
        }
        Object.values(Memory.remoteSkRooms).forEach(remoteRoomMemory => {
            if (remoteRoomMemory.minerals !== undefined) {
                return;
            }
            const room = Game.rooms[remoteRoomMemory.targetRoom];
            if (!room) {
                return;
            }
            remoteRoomMemory.minerals = room.find(FIND_MINERALS).map(mineral => ({
                id: mineral.id
            }));
        });
    }
    static updateMissingRemoteSkSources() {
        if (!Memory.remoteSkRooms) {
            return;
        }
        Object.values(Memory.remoteSkRooms).forEach(remoteRoomMemory => {
            if (remoteRoomMemory.sources !== undefined) {
                return;
            }
            const room = Game.rooms[remoteRoomMemory.targetRoom];
            if (!room) {
                return;
            }
            remoteRoomMemory.sources = room.find(FIND_SOURCES).map(source => ({
                id: source.id
            }));
        });
    }
    static updateMissingRemoteSources() {
        if (!Memory.remoteRooms) {
            return;
        }
        Object.values(Memory.remoteRooms).forEach(remoteRoomMemory => {
            if (remoteRoomMemory.sources !== undefined) {
                return;
            }
            const room = Game.rooms[remoteRoomMemory.targetRoom];
            if (!room) {
                return;
            }
            remoteRoomMemory.sources = room.find(FIND_SOURCES).map(source => ({
                id: source.id
            }));
        });
    }
    static recreate() {
        const allowedCpuPerRoom = Game.cpu.limit / Rooms.myRooms.length;
        const extraCpuRemainingPerRoom = allowedCpuPerRoom - CPU_HOME;
        const newSkRooms = {};
        const newRooms = {};
        Rooms.myRooms.forEach(homeRoom => {
            const roomRemainingResources = {
                cpu: extraCpuRemainingPerRoom,
                sourceCount: REMOTE_SOURCE_LIMIT
            };
            if (homeRoom.isGclFarm) {
                return;
            }
            if (homeRoom.isGclFarmMaster) {
                return;
            }
            const homeRoomExits = this.roomExits(homeRoom.name);
            this.addRemoteSk(homeRoom, homeRoomExits, newSkRooms, roomRemainingResources);
            if (homeRoom.level >= 7 || !General.expansionWithSupport()) {
                const remoteCloseAddedRooms = this.addRemoteClose(homeRoom, homeRoomExits, newRooms, roomRemainingResources);
                const secondTierRooms = Object.values(remoteCloseAddedRooms.reduce((rooms, roomName) => {
                    this.roomExits(roomName).forEach(exitName => {
                        rooms[exitName] = exitName;
                    });
                    return rooms;
                }, {}));
                this.addRemoteFar(homeRoom, secondTierRooms, newRooms, roomRemainingResources);
            }
            Memory.remoteSkRooms = newSkRooms;
            Memory.remoteRooms = newRooms;
            Object.values(newSkRooms).forEach(skRoom => {
                Game.map.visual.line(new RoomPosition(25, 25, skRoom.targetRoom), new RoomPosition(25, 25, skRoom.homeRoom), {
                    color: "red",
                    opacity: 1,
                    width: 4
                });
            });
            Object.values(newRooms).forEach(skRoom => {
                Game.map.visual.line(new RoomPosition(25, 25, skRoom.targetRoom), new RoomPosition(25, 25, skRoom.homeRoom), {
                    opacity: 1,
                    width: 4
                });
            });
        });
    }
    static roomExits(roomName) {
        return Object.values(Game.map.describeExits(roomName)).filter(Boolean);
    }
    static addRemoteClose(homeRoom, homeRoomExits, newRooms, roomRemainingResources) {
        const addedRooms = [];
        homeRoomExits
            .filter(Boolean)
            .map((exitRoomName) => Rooms.memory(exitRoomName))
            .filter(Boolean)
            .sort((a, b) => (b.sourceCount || 0) - (a.sourceCount || 0))
            .forEach(targetRoomMemory => {
            var _a;
            const roomName = targetRoomMemory.name;
            if (!roomName) {
                return;
            }
            if (newRooms[roomName]) {
                return;
            }
            const sourceCount = targetRoomMemory.sourceCount;
            if (!sourceCount) {
                return;
            }
            const cpu = CPU_STANDARD[sourceCount];
            if (!cpu) {
                return;
            }
            if (roomRemainingResources.cpu < cpu) {
                return;
            }
            if (roomRemainingResources.sourceCount < sourceCount) {
                return;
            }
            if (targetRoomMemory.type !== RoomTypeEnum.STANDART) {
                return;
            }
            if (targetRoomMemory.ownerUsername) {
                return;
            }
            const ownerUsername = targetRoomMemory.reservationUsername;
            if (ownerUsername && ownerUsername !== USERNAME.ME) {
                return;
            }
            if (Memory.remoteRooms &&
                Memory.remoteRooms[roomName] &&
                Memory.remoteRooms[roomName].homeRoom === homeRoom.name) {
                newRooms[roomName] = Memory.remoteRooms[roomName];
            }
            else {
                newRooms[roomName] = {
                    targetRoom: roomName,
                    homeRoom: homeRoom.name,
                    route: [homeRoom.name, roomName],
                    sources: (_a = Game.rooms[roomName]) === null || _a === void 0 ? void 0 : _a.find(FIND_SOURCES).map(source => ({
                        id: source.id
                    }))
                };
            }
            addedRooms.push(roomName);
            roomRemainingResources.cpu -= cpu;
            roomRemainingResources.sourceCount -= sourceCount;
        });
        return addedRooms;
    }
    static addRemoteSk(homeRoom, homeRoomExits, newSkRooms, roomRemainingResources) {
        homeRoomExits.forEach(exitRoomName => {
            var _a, _b;
            if (!exitRoomName) {
                return;
            }
            if (homeRoom.level < 8) {
                return;
            }
            if (newSkRooms[exitRoomName]) {
                return;
            }
            if (roomRemainingResources.cpu < CPU_SK) {
                return;
            }
            if (roomRemainingResources.sourceCount < 3) {
                return;
            }
            if (roomNameToType(exitRoomName) !== RoomTypeEnum.SK) {
                return;
            }
            if (Memory.remoteSkRooms &&
                Memory.remoteSkRooms[exitRoomName] &&
                Memory.remoteSkRooms[exitRoomName].homeRoom === homeRoom.name) {
                newSkRooms[exitRoomName] = Memory.remoteSkRooms[exitRoomName];
            }
            else {
                newSkRooms[exitRoomName] = {
                    targetRoom: exitRoomName,
                    homeRoom: homeRoom.name,
                    route: [homeRoom.name, exitRoomName],
                    sources: (_a = Game.rooms[exitRoomName]) === null || _a === void 0 ? void 0 : _a.find(FIND_SOURCES).map(source => ({
                        id: source.id
                    })),
                    minerals: (_b = Game.rooms[exitRoomName]) === null || _b === void 0 ? void 0 : _b.find(FIND_MINERALS).map(mineral => ({
                        id: mineral.id
                    })),
                    isCenter: false
                };
            }
            roomRemainingResources.cpu -= CPU_SK;
            roomRemainingResources.sourceCount -= 3;
            // const exitExits = Object.values(Game.map.describeExits(exitRoomName));
            // exitExits.forEach(exitExitRoomName => {
            //   if (!exitExitRoomName) {
            //     return;
            //   }
            //
            //   if (newSkRooms[exitExitRoomName]) {
            //     return;
            //   }
            //
            //   if (roomRemainingResources.cpu < CPU_SK) {
            //     return;
            //   }
            //
            //   if (roomRemainingResources.sourceCount < 3) {
            //     return;
            //   }
            //
            //   if (roomNameToType(exitExitRoomName) !== RoomTypeEnum.CENTER) {
            //     return;
            //   }
            //
            //   if (
            //     Memory.remoteSkRooms &&
            //     Memory.remoteSkRooms[exitExitRoomName] &&
            //     Memory.remoteSkRooms[exitExitRoomName].homeRoom === homeRoom.name
            //   ) {
            //     newSkRooms[exitExitRoomName] = Memory.remoteSkRooms[exitExitRoomName];
            //   } else {
            //     newSkRooms[exitExitRoomName] = {
            //       targetRoom: exitExitRoomName,
            //       homeRoom: homeRoom.name,
            //       route: [homeRoom.name, exitRoomName, exitExitRoomName],
            //       sources: Game.rooms[exitRoomName]?.find(FIND_SOURCES).map(source => ({
            //         id: source.id
            //       })),
            //       minerals: Game.rooms[exitRoomName]?.find(FIND_MINERALS).map(mineral => ({
            //         id: mineral.id
            //       })),
            //       isCenter: true
            //     };
            //   }
            //
            //   roomRemainingResources.cpu -= CPU_SK;
            //   roomRemainingResources.sourceCount -= 3;
            // });
        });
    }
    static addRemoteFar(homeRoom, targetRooms, newRooms, roomRemainingResources) {
        targetRooms
            .map((exitRoomName) => Rooms.memory(exitRoomName))
            .filter(Boolean)
            .sort((a, b) => (b.sourceCount || 0) - (a.sourceCount || 0))
            .forEach(targetRoomMemory => {
            var _a;
            const roomName = targetRoomMemory.name;
            if (!roomName) {
                return;
            }
            if (newRooms[roomName]) {
                return;
            }
            const sourceCount = targetRoomMemory.sourceCount;
            if (!sourceCount) {
                return;
            }
            const cpu = CPU_STANDARD[sourceCount];
            if (!cpu) {
                return;
            }
            if (roomRemainingResources.cpu < cpu) {
                return;
            }
            if (roomRemainingResources.sourceCount < sourceCount) {
                return;
            }
            if (targetRoomMemory.type !== RoomTypeEnum.STANDART) {
                return;
            }
            if (targetRoomMemory.ownerUsername) {
                return;
            }
            const ownerUsername = targetRoomMemory.reservationUsername;
            if (ownerUsername && ownerUsername !== USERNAME.ME) {
                return;
            }
            const route = Geo.findRouteCached(homeRoom.name, roomName);
            if (!route.length) {
                return;
            }
            const finalRoute = [...route, homeRoom.name, roomName].filter((value, index, array) => array.indexOf(value) === index);
            if (route.length > 3) {
                return;
            }
            if (Memory.remoteRooms &&
                Memory.remoteRooms[roomName] &&
                Memory.remoteRooms[roomName].homeRoom === homeRoom.name) {
                newRooms[roomName] = Memory.remoteRooms[roomName];
            }
            else {
                newRooms[roomName] = {
                    targetRoom: roomName,
                    homeRoom: homeRoom.name,
                    route: finalRoute,
                    sources: (_a = Game.rooms[roomName]) === null || _a === void 0 ? void 0 : _a.find(FIND_SOURCES).map(source => ({
                        id: source.id
                    }))
                };
            }
            roomRemainingResources.cpu -= cpu;
            roomRemainingResources.sourceCount -= sourceCount;
        });
    }
}

const CONFIG$1 = Config.RemoteSourceHarvester;
class RemoteSourceHarvester {
    static handle() {
        Creeps.getByRole(CONFIG$1.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG$1.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        this.createRoadConstructions(creep);
        this.suicide(creep);
        this.suicideWhenNoCarryParts(creep);
        this.moveHomeWhenAttacker(creep) ||
            this.moveOnToContainer(creep) ||
            this.buildContainer(creep) ||
            this.repairContainer(creep) ||
            this.mine(creep) ||
            this.build(creep);
    }
    static handleSpawn() {
        if (!Memory.remoteRooms) {
            return;
        }
        const que = Creeps.queByRole(CONFIG$1.roleName);
        const creeps = Creeps.getByRole(CONFIG$1.roleName).filter(c => !c.ticksToLive || c.ticksToLive > 200);
        Object.values(Memory.remoteRooms).forEach(remoteRoomMemory => {
            const homeRoom = Game.rooms[remoteRoomMemory.homeRoom];
            if (!homeRoom) {
                return;
            }
            if (homeRoom.isAbandoning) {
                return;
            }
            if (homeRoom.isSiegeBase) {
                return;
            }
            if (!remoteRoomMemory.sources) {
                return;
            }
            if (remoteRoomMemory.avoidUntill && remoteRoomMemory.avoidUntill > Game.time) {
                return;
            }
            const targetRoomModel = Rooms.model(remoteRoomMemory.targetRoom);
            if (targetRoomModel.isReservedNotByMe) {
                return;
            }
            if (targetRoomModel.pvpDeaths > 10) {
                return;
            }
            const targetRoomQue = que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === remoteRoomMemory.targetRoom; });
            const targetRoomCreeps = creeps.filter(c => c.memory.targetRoom === remoteRoomMemory.targetRoom);
            remoteRoomMemory.sources.forEach(sourceMemory => {
                if (targetRoomQue.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.sourceId) === sourceMemory.id; }).length > 0) {
                    return;
                }
                if (targetRoomCreeps.filter(c => c.memory.sourceId === sourceMemory.id).length > 0) {
                    return;
                }
                Spawns.addToQue(remoteRoomMemory.homeRoom, {
                    body: new BodyParts().addMultiple([MOVE, WORK, WORK]),
                    optionalBody: new BodyParts().addMultiple([MOVE, WORK, WORK], 3).carry(2),
                    priority: CONFIG$1.spawnPriority,
                    role: CONFIG$1.roleName,
                    memory: { sourceId: sourceMemory.id, targetRoom: remoteRoomMemory.targetRoom }
                });
            });
        });
    }
    static buildContainer(creep) {
        if (!creep.source) {
            return false;
        }
        if (!creep.source.containerConstruction) {
            return false;
        }
        if (creep.store.energy === 0) {
            return false;
        }
        if (creep.pos.getRangeTo(creep.source.containerConstruction) > 3) {
            return false;
        }
        if (creep.store.energy / creep.store.getCapacity() < 0.5) {
            return false;
        }
        creep.build(creep.source.containerConstruction);
        return true;
    }
    static repairContainer(creep) {
        if (!creep.source) {
            return false;
        }
        if (!creep.source.container) {
            return false;
        }
        if (creep.pos.getRangeTo(creep.source.container) > 3) {
            return false;
        }
        if (creep.source.container.hits > 200000) {
            return false;
        }
        if (creep.store.energy === 0) {
            return false;
        }
        if (creep.store.energy / creep.store.getCapacity() < 0.5) {
            return false;
        }
        creep.repair(creep.source.container);
        return true;
    }
    static moveHomeWhenAttacker(creep) {
        if (!creep.targetRoomModel) {
            return false;
        }
        if (creep.targetRoomModel.isMine) {
            return false;
        }
        if (!creep.memory.targetRoom) {
            return false;
        }
        if (!creep.homeRoom) {
            return false;
        }
        if (creep.memory.targetRoom === creep.memory.homeRoom) {
            return false;
        }
        if (creep.targetRoomModel.npcPower(ATTACK, RANGED_ATTACK) +
            creep.targetRoomModel.hostilePower(ATTACK, RANGED_ATTACK) ===
            0) {
            return false;
        }
        if (creep.store.energy) {
            creep.drop(RESOURCE_ENERGY);
        }
        creep.travel({ pos: new RoomPosition(25, 25, creep.homeRoom.name) }, { range: 10 });
        return true;
    }
    static createRoadConstructions(creep) {
        var _a;
        if (!creep.homeRoom) {
            return;
        }
        if (creep.homeRoom.isGclFarm) {
            return;
        }
        if (creep.homeRoom.level <= 1) {
            return;
        }
        if (!creep.source) {
            return;
        }
        if (creep.homeRoom.energyCapacityAvailable < 1300) {
            return;
        }
        if (creep.memory.constructionsCreated) {
            return;
        }
        if (!creep.homeRoom) {
            return;
        }
        const center = ((_a = creep.homeRoom.storage) === null || _a === void 0 ? void 0 : _a.pos) || creep.homeRoom.center;
        if (!center) {
            return;
        }
        if (creep.source.container) {
            creep.source.container.pos.createRoadConstructionsFrom(center, {
                structureType: STRUCTURE_CONTAINER,
                containerOnPos: true
            });
        }
        else {
            creep.source.pos.createRoadConstructionsFrom(center, {
                structureType: STRUCTURE_CONTAINER
            });
        }
        creep.memory.constructionsCreated = true;
    }
    static moveOnToContainer(creep) {
        if (!creep.source) {
            return false;
        }
        if (!creep.source.container) {
            return false;
        }
        if (creep.source.container.pos.hasCreep) {
            return false;
        }
        if (creep.pos.isEqualTo(creep.source.container.pos)) {
            return false;
        }
        creep.travel(creep.source.container, { range: 0 });
        return true;
    }
    static mine(creep) {
        if (!creep.source) {
            return false;
        }
        if (creep.source.container) {
            if (creep.source.container.store.getFreeCapacity() < creep.harvestPower) {
                return false;
            }
        }
        const distance = creep.pos.getRangeTo(creep.source);
        if (distance > 2) {
            creep.travel(creep.source, { range: 1 });
        }
        else if (distance === 2) {
            creep.travel(creep.source, {
                ignoreCreeps: false,
                maxOps: 200,
                freshPath: true,
                range: 1,
                logIncomplete: false
            });
        }
        else {
            creep.harvest(creep.source);
            creep.memory.stationary = true;
        }
        return true;
    }
    static build(creep) {
        if (!(creep.target instanceof ConstructionSite)) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.target);
        if (distance > 3) {
            creep.travel(creep.target, { ignoreCreeps: false });
        }
        else if (distance > 1) {
            creep.travel(creep.target, {
                ignoreCreeps: false,
                freshPath: true,
                maxOps: 200
            });
        }
        if (distance <= 3) {
            creep.build(creep.target);
        }
        return true;
    }
    static suicide(creep) {
        if (!creep.source) {
            return false;
        }
        if (!creep.homeRoom) {
            return false;
        }
        if (creep.homeRoom.level < 5) {
            return false;
        }
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > 1000) {
            return false;
        }
        const replacemenet = creep.pos.findInRange(FIND_MY_CREEPS, 2, {
            filter: c => c.memory.sourceId === creep.memory.sourceId && c.memory.role === CONFIG$1.roleName && c.id !== creep.id
        })[0];
        if (!replacemenet) {
            return false;
        }
        if (!replacemenet.ticksToLive) {
            return false;
        }
        if (replacemenet.ticksToLive < creep.ticksToLive) {
            return false;
        }
        creep.die();
        return true;
    }
    static suicideWhenNoCarryParts(creep) {
        if (!creep.room.my) {
            return false;
        }
        if (!creep.source) {
            return false;
        }
        if (creep.source.links.length === 0) {
            return false;
        }
        if (creep.store.getCapacity() > 0) {
            return false;
        }
        creep.die();
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], RemoteSourceHarvester, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], RemoteSourceHarvester, "handleSpawn", null);

const CONFIG = Config.RemoteSourceHauler;
var Action;
(function (Action) {
    Action["pick"] = "pick";
    Action["spend"] = "spend";
})(Action || (Action = {}));
class RemoteSourceHauler {
    static handle() {
        Creeps.getByRole(CONFIG.roleName)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(CONFIG.spawnInterval, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        this.setAction(creep);
        if (creep.recycleFinal(200)) {
            return;
        }
        if (this.moveHomeWhenAttacker(creep)) {
            return;
        }
        switch (creep.memory.action) {
            case Action.spend:
                this.repairAround(creep) || this.buildAround(creep);
                this.storeEnergyToStorage(creep) ||
                    this.storeToCenterContainer(creep) ||
                    this.storeEnergyToSpawn(creep) ||
                    this.moveToCenter(creep) ||
                    creep.idleAwayFrom([STRUCTURE_SPAWN], 3);
                break;
            case Action.pick:
                this.pickDroppedEnergy(creep) || this.withdrawEnergyFromContainer(creep) || this.moveNearSource(creep);
        }
    }
    static handleSpawn() {
        if (!Memory.remoteRooms) {
            return;
        }
        const que = Creeps.queByRole(CONFIG.roleName);
        const creeps = Creeps.getByRole(CONFIG.roleName).filter(c => !c.ticksToLive || c.ticksToLive > 300);
        Object.values(Memory.remoteRooms).forEach(remoteRoomMemory => {
            const homeRoom = Game.rooms[remoteRoomMemory.homeRoom];
            if (!homeRoom) {
                return;
            }
            if (homeRoom.isAbandoning) {
                return;
            }
            if (homeRoom.isSiegeBase) {
                return;
            }
            if (!remoteRoomMemory.sources) {
                return;
            }
            if (remoteRoomMemory.avoidUntill && remoteRoomMemory.avoidUntill > Game.time) {
                return;
            }
            const targetRoomModel = Rooms.model(remoteRoomMemory.targetRoom);
            if (targetRoomModel.pvpDeaths > 10) {
                return;
            }
            if (targetRoomModel.isReservedNotByMe) {
                return;
            }
            const targetRoomQue = que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === remoteRoomMemory.targetRoom; });
            const targetRoomCreeps = creeps.filter(c => c.memory.targetRoom === remoteRoomMemory.targetRoom);
            remoteRoomMemory.sources.forEach(sourceMemory => {
                var _a;
                if (targetRoomQue.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.sourceId) === sourceMemory.id; }).length > 0) {
                    return;
                }
                if (targetRoomCreeps.filter(c => c.memory.sourceId === sourceMemory.id).length > 0) {
                    return;
                }
                const targetRoomHasConstructions = ((_a = Game.rooms[remoteRoomMemory.targetRoom]) === null || _a === void 0 ? void 0 : _a.find(FIND_MY_CONSTRUCTION_SITES).length) > 0;
                const needWorkParts = targetRoomHasConstructions || Math.random() > 0.5;
                Spawns.addToQue(remoteRoomMemory.homeRoom, {
                    body: new BodyParts().move(2).carry(2),
                    optionalBody: BodyParts.new()
                        .move(needWorkParts ? 2 : 0)
                        .work(needWorkParts ? 2 : 0)
                        .addMultiple([MOVE, CARRY, CARRY, CARRY, CARRY], 25),
                    priority: CONFIG.spawnPriority,
                    role: CONFIG.roleName,
                    memory: { sourceId: sourceMemory.id, targetRoom: remoteRoomMemory.targetRoom }
                });
            });
        });
    }
    static moveHomeWhenAttacker(creep) {
        if (!creep.homeRoom) {
            return false;
        }
        if (!creep.targetRoomModel) {
            return false;
        }
        if (creep.targetRoomModel.npcPower(ATTACK, RANGED_ATTACK) +
            creep.targetRoomModel.hostilePower(ATTACK, RANGED_ATTACK) ===
            0) {
            return false;
        }
        creep.travel({ pos: new RoomPosition(25, 25, creep.homeRoom.name) }, { range: 10 });
        return true;
    }
    static moveToCenter(creep) {
        if (!creep.homeRoom) {
            return false;
        }
        if (!creep.homeRoom.center) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.homeRoom.center);
        if (distance <= 6) {
            return false;
        }
        creep.travel({ pos: creep.homeRoom.center }, { range: 2 });
        return true;
    }
    static setAction(creep) {
        if (!creep.memory.action) {
            creep.memory.action = Action.pick;
            return;
        }
        if (creep.store.getUsedCapacity() === 0) {
            creep.memory.action = Action.pick;
        }
        else if (creep.store.getFreeCapacity() === 0) {
            creep.memory.action = Action.spend;
        }
    }
    static moveNearSource(creep) {
        if (!creep.source) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.source);
        if (distance <= 3) {
            return false;
        }
        creep.travel(creep.source, { cache: true, costSwamp: 10, costPlain: 2 });
        return true;
    }
    static storeToCenterContainer(creep) {
        if (!creep.homeRoom) {
            return false;
        }
        const container = creep.homeRoom.centerContainers
            .filter(c => c.store.getFreeCapacity(RESOURCE_ENERGY) > 0)
            .sort((a, b) => creep.pos.getRangeTo(a) - creep.pos.getRangeTo(b))[0];
        if (!container) {
            return false;
        }
        const distance = creep.pos.getRangeTo(container);
        if (distance <= 4 && container.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {
            return false;
        }
        if (distance > 1) {
            creep.travel(container);
        }
        else {
            creep.transfer(container, RESOURCE_ENERGY);
        }
        return true;
    }
    static storeEnergyToSpawn(creep) {
        if (!creep.homeRoom) {
            return false;
        }
        const spawn = creep.homeRoom.myActiveSpawns.find(s => s.store.getFreeCapacity(RESOURCE_ENERGY) > 0);
        if (!spawn) {
            return false;
        }
        const distance = creep.pos.getRangeTo(spawn);
        if (distance <= 4 && spawn.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {
            return false;
        }
        if (distance > 1) {
            creep.travel(spawn);
        }
        else {
            creep.transfer(spawn, RESOURCE_ENERGY);
        }
        return true;
    }
    static buildAround(creep) {
        var _a, _b;
        if ((((_b = (_a = creep.homeRoom) === null || _a === void 0 ? void 0 : _a.storage) === null || _b === void 0 ? void 0 : _b.store.energy) || 0) > 50000) {
            if (creep.store.energy === 0) {
                return false;
            }
        }
        else {
            if (creep.store.energy / creep.store.getCapacity() < 0.5) {
                return false;
            }
        }
        if (!creep.body.find(b => b.type === WORK && b.hits > 0)) {
            return false;
        }
        const construction = creep.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 3, {
            filter: s => s.structureType === STRUCTURE_ROAD || s.structureType === STRUCTURE_CONTAINER
        })[0];
        if (!construction) {
            return false;
        }
        creep.build(construction);
        return true;
    }
    static repairAround(creep) {
        var _a, _b;
        if ((((_b = (_a = creep.homeRoom) === null || _a === void 0 ? void 0 : _a.storage) === null || _b === void 0 ? void 0 : _b.store.energy) || 0) > 50000) {
            if (creep.store.energy === 0) {
                return false;
            }
        }
        else {
            if (creep.store.energy / creep.store.getCapacity() < 0.5) {
                return false;
            }
        }
        if (!creep.body.find(b => b.type === WORK && b.hits > 0)) {
            return false;
        }
        const road = creep.pos
            .findInRange(FIND_STRUCTURES, 3, {
            filter: s => s.structureType === STRUCTURE_ROAD && s.hitsMax - s.hits >= 200
        })
            .sort((a, b) => a.hits / a.hitsMax - b.hits / b.hitsMax)[0];
        if (!road) {
            return false;
        }
        creep.repair(road);
        return true;
    }
    static storeEnergyToStorage(creep) {
        if (!creep.homeRoom) {
            return false;
        }
        if (!creep.homeRoom.storage || !creep.homeRoom.storage.cachedIsActive()) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.homeRoom.storage);
        if (distance > 1) {
            creep.travel(creep.homeRoom.storage, { cache: true, costSwamp: 10, costPlain: 2 });
        }
        else {
            creep.transfer(creep.homeRoom.storage, RESOURCE_ENERGY);
        }
        return true;
    }
    static withdrawEnergyFromContainer(creep) {
        if (!creep.source) {
            return false;
        }
        if (!creep.source.container) {
            return false;
        }
        if (!creep.ticksToLive) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.source.container);
        if (distance > 1) {
            creep.travel(creep.source.container, { cache: true, costSwamp: 10, costPlain: 2 });
        }
        else {
            if (creep.ticksToLive > 250 && creep.source.container.store.energy < creep.store.getFreeCapacity()) {
                return true;
            }
            creep.withdraw(creep.source.container, RESOURCE_ENERGY);
        }
        return true;
    }
    static pickDroppedEnergy(creep) {
        if (!creep.source) {
            return false;
        }
        const droppedEnergy = creep.source.pos.findInRange(FIND_DROPPED_RESOURCES, 1, {
            filter: r => r.resourceType === RESOURCE_ENERGY && r.amount >= 20
        })[0];
        if (!droppedEnergy) {
            return false;
        }
        const distance = creep.pos.getRangeTo(droppedEnergy);
        if (distance > 1) {
            creep.travel(droppedEnergy, { cache: true, costSwamp: 10, costPlain: 2 });
        }
        else {
            creep.pickup(droppedEnergy);
        }
        return true;
    }
}
__decorate([
    Profiler.subprofile("creep")
], RemoteSourceHauler, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], RemoteSourceHauler, "handleSpawn", null);

const ROLE_NAME$5 = roles.AttackerRangedQuad;
class AttackerRangedQuad {
    static handle() {
        Quads.allByrole(ROLE_NAME$5).forEach(quad => {
            try {
                this.workQuad(quad);
            }
            catch (e) {
                quad.stage = QuadGroupStage.RETREATING;
            }
        });
        General.interval(40, () => TickAction.add(() => this.spawnFlag()));
    }
    static workQuad(quadMemory) {
        const quad = new QuadModel(quadMemory);
        quad.getCreeps().forEach(creep => {
            if (creep.spawning) {
                return;
            }
            this.workCreep(creep);
        });
        const targetFlag = quad.memory.targetFlag ? Game.flags[quad.memory.targetFlag] : null;
        if (!targetFlag) {
            quad.setStage(QuadGroupStage.RETREATING);
            return;
        }
        quad
            .inStage(QuadGroupStage.SPAWNING, () => {
            quad.refresh() || quad.waitTillAllAlive() || quad.setStage(QuadGroupStage.BOOSTING);
        })
            .inStage(QuadGroupStage.BOOSTING, () => {
            quad.boost() || quad.setStage(QuadGroupStage.TRAVELING);
        })
            .inStage(QuadGroupStage.TRAVELING, () => {
            if (quad.anchorCreep.wpos.getRangeTo(targetFlag.wpos) <= 25) {
                quad.setStage(QuadGroupStage.ATTACKING);
            }
            else {
                quad.travelTo(targetFlag.pos, 2);
            }
        })
            .inStage(QuadGroupStage.ATTACKING, () => {
            this.kite(quad) ||
                quad.turnToDirection(BOTTOM) ||
                quad.retreatWhenNotFull() ||
                quad.formQuadIfPossible() ||
                // this.moveToHostiles(quad, targetFlag) ||
                this.moveToFlag(quad, targetFlag);
            // const targetRoom = Game.rooms[quad.memory.targetRoom];
            //
            // if (targetRoom) {
            //   if (stronghold.isAlive) {
            //     const possibleLocations = this.possibleActiveStrongholdStandingPositions(targetRoom)
            //       .filter(pos => quad.canFormQuadOn(pos))
            //       .sort((a, b) => quad.getRangeTo(a) - quad.getRangeTo(b));
            //
            //     // figure best position for shit and go there
            //
            //     if (possibleLocations.length === 0) {
            //       return;
            //     }
            //
            //     if (possibleLocations.find(p => p.isEqualTo(quad.anchorCreep.pos))) {
            //       return;
            //     }
            //
            //     const ramparts = quad.anchorCreep.room.find(FIND_HOSTILE_STRUCTURES, {
            //       filter: s => s.structureType === STRUCTURE_RAMPART
            //     });
            //
            //     const obstacles = Object.values(
            //       ramparts.reduce((obs, rampart) => {
            //         rampart.pos.quadCoordinatesAround(1).forEach(p => {
            //           obs[`${p.x}.${p.y}`] = { x: p.x, y: p.y };
            //         });
            //
            //         return obs;
            //       }, {} as Record<string, Pos>)
            //     );
            //
            //     quad.moveTo(possibleLocations, 0, { obstacles });
            //   } else {
            //     const possibleLocations = this.possibleDeadStrongholdStandingPositions(quad.anchorCreep.room)
            //       .filter(pos => quad.canFormQuadOn(pos))
            //       .sort((a, b) => quad.getRangeTo(a) - quad.getRangeTo(b));
            //
            //     // figure best position for shit and go there
            //
            //     if (possibleLocations.length === 0) {
            //       return;
            //     }
            //
            //     if (possibleLocations.find(p => p.isEqualTo(quad.anchorCreep.pos))) {
            //       return;
            //     }
            //
            //     quad.moveTo(possibleLocations[0], 0);
            //   }
            // } else {
            //   quad.moveTo(invaderPosition, 5);
            // }
        })
            .inStage(QuadGroupStage.RETREATING, () => {
            quad.retreat();
        });
    }
    static moveToHostiles(quad, flag) {
        if (flag.pos.roomName !== quad.anchorCreep.pos.roomName) {
            return false;
        }
        const hostiles = quad.anchorCreep.room.find(FIND_HOSTILE_CREEPS);
        if (hostiles.length === 0) {
            return false;
        }
        quad.moveToV2(hostiles.map(h => ({ pos: h.pos, range: 2 })));
        return true;
    }
    static moveToFlag(quad, flag) {
        if (quad.anchorCreep.pos.getRangeTo(flag.pos) <= 0) {
            return false;
        }
        quad.moveTo(flag.pos, 0) || quad.travelTo(flag.pos, 0);
        return false;
    }
    static kite(quad) {
        if (quad.hitsMax - quad.hits >= 2000) {
            quad.kite();
            return true;
        }
        const hostiles = quad.anchorCreep.pos.findInRange(FIND_HOSTILE_CREEPS, 5, { filter: c => c.attackPower > 1200 });
        if (hostiles.filter(c => quad.getRangeTo(c.pos) <= 2).length > 0) {
            quad.kite();
            return true;
        }
        if (hostiles.filter(c => quad.getRangeTo(c.pos) <= 3).length > 0) {
            return true;
        }
        return false;
    }
    static possibleActiveStrongholdStandingPositions(room) {
        return TickCache.cache({
            key: `${this.constructor.name}.${room.name}.possibleActiveStrongholdStandingPositions`,
            callback: () => {
                const ramparts = room.find(FIND_HOSTILE_STRUCTURES, { filter: s => s.structureType === STRUCTURE_RAMPART });
                const unique = {};
                ramparts.forEach(rampart => {
                    rampart.pos.quadCoordinatesAround(2).forEach(p => {
                        unique[`${p.x}.${p.y}`] = new RoomPosition(p.x, p.y, room.name);
                    });
                });
                ramparts.forEach(rampart => {
                    rampart.pos.quadCoordinatesAround(1).forEach(p => {
                        delete unique[`${p.x}.${p.y}`];
                    });
                    delete unique[`${rampart.pos.x}.${rampart.pos.y}`];
                });
                Object.values(unique).forEach(pos => {
                    room.visual.circle(pos.x, pos.y, { radius: 0.1 });
                });
                return Object.values(unique);
            }
        });
    }
    static possibleDeadStrongholdStandingPositions(room) {
        return TickCache.cache({
            key: `${this.constructor.name}.${room.name}.possibleDeadStrongholdStandingPositions`,
            callback: () => {
                const ramparts = room.find(FIND_HOSTILE_STRUCTURES, { filter: s => s.structureType === STRUCTURE_RAMPART });
                const unique = {};
                ramparts.forEach(rampart => {
                    rampart.pos.quadCoordinatesAround(1).forEach(p => {
                        unique[`${p.x}.${p.y}`] = new RoomPosition(p.x, p.y, room.name);
                    });
                });
                ramparts.forEach(rampart => {
                    delete unique[`${rampart.pos.x}.${rampart.pos.y}`];
                });
                Object.values(unique).forEach(pos => {
                    room.visual.circle(pos.x, pos.y, { radius: 0.1 });
                });
                return Object.values(unique);
            }
        });
    }
    static workCreep(creep) {
        creep.healMele() || this.healSelf(creep) || this.prehealAttacker(creep); // ||
        // this.prehealSelfAttacker(creep) ||
        // this.preheal(creep) ||
        // creep.prehealMele();
        this.attack(creep);
    }
    static healSelf(creep) {
        if (creep.hits >= creep.hitsMax - 200) {
            return false;
        }
        if (!creep.healPower) {
            return false;
        }
        creep.heal(creep);
        return true;
    }
    static spawnFlag() {
        if (!Memory.quads) {
            Memory.quads = {};
        }
        const quads = Object.values(Memory.quads).filter(g => g.role === ROLE_NAME$5);
        // blue - green - unboosted
        Flags.flags(FlagType.rangedAttackerQuadTier0).forEach(flag => {
            const flagRoom = Rooms.memory(flag.pos.roomName);
            if (flagRoom.safeModeEndsAt || 0 > Game.time) {
                return;
            }
            const flagQuads = quads.filter(g => g.targetFlag === flag.name);
            const quadsInAction = flagQuads.filter(q => q.stage !== QuadGroupStage.RETREATING && q.ticksToLive > 400).length;
            if (quadsInAction > 0) {
                return;
            }
            const spawnRoom = Geo.closestHomeRoomByRange(flag.pos.roomName, {
                maxDistance: MAX_EXPANSION_RANGE,
                room: r => r.level >= 8 && !Quads.isSpawningInRoom(r.name) && !Duos.isSpawningInRoom(r.name)
            });
            if (!spawnRoom) {
                return;
            }
            // spawn shit
            console.log("spawning in ", spawnRoom.name);
            const creeps = {
                [QuadPosition.BOTTOM_LEFT]: `biatch-${General.uniqueId()}`,
                [QuadPosition.BOTTOM_RIGHT]: `biatch-${General.uniqueId()}`,
                [QuadPosition.TOP_LEFT]: `biatch-${General.uniqueId()}`,
                [QuadPosition.TOP_RIGHT]: `biatch-${General.uniqueId()}`
            };
            const quadId = Quads.create({
                homeRoom: spawnRoom.name,
                role: ROLE_NAME$5,
                stage: QuadGroupStage.SPAWNING,
                targetFlag: flag.name,
                targetRoom: flag.pos.roomName,
                creeps
            });
            const creepNames = Object.values(creeps);
            for (let i = 0; i < 4; i++) {
                if (i % 2 === 0) {
                    Spawns.addToQue(spawnRoom, {
                        // body: BodyParts.new().tough(10).rangedAttack(2).heal(28).move(10),
                        body: BodyParts.new().tough(2).move(8).rangedAttack(28).move(2).heal(10),
                        priority: 0 /* Highest */,
                        role: ROLE_NAME$5,
                        boosts: [BOOST_ALIAS.TOUGH_3, BOOST_ALIAS.RANGED_ATTACK_3, BOOST_ALIAS.MOVE_3, BOOST_ALIAS.HEAL_3],
                        memory: {
                            quad: {
                                id: quadId,
                                attacker: true
                            }
                        },
                        maxQueTime: 1000,
                        name: creepNames[i]
                    });
                }
                else {
                    Spawns.addToQue(spawnRoom, {
                        // body: BodyParts.new().tough(10).move(8).heal(30).move(2),
                        body: BodyParts.new().tough(2).move(8).heal(38).move(2),
                        priority: 0 /* Highest */,
                        role: ROLE_NAME$5,
                        boosts: [BOOST_ALIAS.TOUGH_3, BOOST_ALIAS.MOVE_3, BOOST_ALIAS.HEAL_3],
                        memory: {
                            quad: {
                                id: quadId,
                                healer: true
                            }
                        },
                        maxQueTime: 1000,
                        name: creepNames[i]
                    });
                }
            }
            spawnRoom.mem.increasedSpawnUntil = Game.time + 1500;
        });
    }
    static prehealSelfAttacker(creep) {
        var _a;
        if (creep.room.my) {
            return false;
        }
        if ((_a = creep.memory.quad) === null || _a === void 0 ? void 0 : _a.attacker) {
            return false;
        }
        creep.heal(creep);
        return true;
    }
    // private preheal2(): boolean {
    //   if (this.creep.room.my) return false;
    //   if (this.creep.Misc.quad?.role !== "healer") return false;
    //
    //   const attackers = this.creep.pos.findInRange(FIND_MY_CREEPS, 1).find(c => c.Misc.quad?.role === "attacker");
    //
    //   return true;
    // }
    static prehealAttacker(creep) {
        if (creep.room.my) {
            return false;
        }
        if (!creep.healPower) {
            return false;
        }
        const attacker = creep.pos
            .findInRange(FIND_MY_CREEPS, 1, {
            filter: c => { var _a; return (_a = c.memory.quad) === null || _a === void 0 ? void 0 : _a.attacker; }
        })
            .sort((a, b) => a.preheal - b.preheal)[0];
        if (!attacker) {
            return false;
        }
        creep.heal(attacker);
        attacker.preheal += creep.healPower;
        return true;
    }
    static preheal(creep) {
        var _a;
        if (creep.room.my) {
            return false;
        }
        if (creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3).length === 0) {
            return false;
        }
        if (!creep.body.find(b => b.type === HEAL && b.hits > 0)) {
            return false;
        }
        const prehealee = ((_a = StrongholdUtils.focusMax2(creep.room)
            .filter(c => c.creep.pos.inRangeTo(creep, 1))
            .sort((a, b) => a.creep.preheal - b.creep.preheal)[0]) === null || _a === void 0 ? void 0 : _a.creep) ||
            creep.pos.findInRange(FIND_MY_CREEPS, 1).sort((a, b) => a.preheal - b.preheal)[0];
        if (!creep) {
            return false;
        }
        if (creep.heal(creep) === OK) {
            prehealee.preheal = prehealee.preheal + creep.healPower;
        }
        return true;
    }
    static attack(creep) {
        this.dismantle(creep);
        this.snipeCore(creep) || creep.rangedBestAttack();
    }
    static dismantle(creep) {
        if (!creep.dismantlePower) {
            return false;
        }
        const hostileStructure = creep.pos
            .findInRange(FIND_HOSTILE_STRUCTURES, 1, { filter: s => s.hits > 0 })
            .sort((a, b) => a.hits - b.hits)[0];
        if (!hostileStructure) {
            return false;
        }
        creep.dismantle(hostileStructure);
        return true;
    }
    static snipeCore(creep) {
        if (!creep.room.invaderCore) {
            return false;
        }
        if (creep.pos.getRangeTo(creep.room.invaderCore) > 3) {
            return false;
        }
        const rampart = creep.room.invaderCore.pos
            .lookFor(LOOK_STRUCTURES)
            .find(s => s.structureType === STRUCTURE_RAMPART);
        creep.rangedAttack(rampart || creep.room.invaderCore);
        return true;
    }
}

const ROLE_NAME$4 = roles.SafeModeBlockClaimer;
const MAX_SAFE_MODE_REMAINING = 15000;
class SafeModeBlockClaimer {
    static handle() {
        Creeps.getByRole(ROLE_NAME$4)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        // General.interval(50, () => TickAction.add(() => this.handleSpawn()));
        General.interval(100, () => TickAction.add(() => this.handleSafeModeSpawn()));
        General.interval(100, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        this.drawTicksRemaining(creep);
        this.goToTargetRoom(creep) ||
            this.attackController(creep) ||
            this.claimController(creep) ||
            this.signController(creep) ||
            this.suicide(creep);
    }
    static drawTicksRemaining(creep) {
        Game.map.visual.text(String(creep.ticksToLive), creep.pos);
    }
    static signController(creep) {
        if (creep.room.name !== creep.memory.targetRoom) {
            return false;
        }
        if (!creep.room.controller) {
            return false;
        }
        if (creep.room.controller.signUsername === USERNAME.SCREEPS) {
            return false;
        }
        if (creep.room.controller.signText === SIGNATURE) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.controller);
        if (distance > 1) {
            creep.travel(creep.room.controller);
        }
        else {
            creep.signController(creep.room.controller, SIGNATURE);
        }
        return true;
    }
    static attackController(creep) {
        var _a;
        if (!creep.room.controller) {
            return false;
        }
        if (creep.room.controller.my) {
            return false;
        }
        if (((_a = creep.room.controller.reservation) === null || _a === void 0 ? void 0 : _a.username) === USERNAME.ME) {
            return false;
        }
        if (creep.attackController(creep.room.controller) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.room.controller);
        }
        return true;
    }
    static claimController(creep) {
        if (!creep.room.controller) {
            return false;
        }
        if ((creep.room.controller.safeModeCooldown || 0) > SAFE_MODE_COOLDOWN - 1000) {
            creep.say("naha");
            return false;
        }
        if (creep.room.controller.my) {
            return false;
        }
        if (creep.room.name !== creep.memory.targetRoom) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.controller);
        if (distance > 1) {
            creep.travel(creep.room.controller);
        }
        else {
            creep.claimController(creep.room.controller);
        }
        return true;
    }
    static goToTargetRoom(creep) {
        if (!creep.targetRoomModel) {
            return false;
        }
        return creep.travelToRoom(creep.targetRoomModel.roomName, { ignoreHostiles: false });
    }
    static suicide(creep) {
        if (creep.room.name !== creep.memory.targetRoom) {
            return false;
        }
        if (!creep.room.my) {
            return false;
        }
        creep.die();
        return true;
    }
    static handleSafeModeSpawn() {
        if (Rooms.myRooms.length >= Game.gcl.level) {
            return;
        }
        const creeps = Creeps.getByRole(ROLE_NAME$4);
        const que = Creeps.queByRole(ROLE_NAME$4);
        Rooms.memoryObjectRoomValues.forEach(room => {
            if (Game.cpu.bucket < 1000) {
                return;
            }
            if (room.isMine) {
                return;
            }
            if (!room.isInSafeMode()) {
                return;
            }
            Object.values(Game.map.describeExits(room.roomName)).forEach(exitRoomName => {
                if (!exitRoomName) {
                    return;
                }
                const exitRoom = Rooms.memory(exitRoomName);
                if (exitRoom.type !== RoomTypeEnum.STANDART) {
                    return;
                }
                if (exitRoom.isInSafeMode()) {
                    return;
                }
                if ((exitRoom.safeModeCooldownEndsAt || 0) > Game.time + MAX_SAFE_MODE_REMAINING) {
                    return;
                }
                if (exitRoom.ownerUsername) {
                    return;
                }
                if (exitRoom.reservationUsername) {
                    return;
                }
                if (exitRoom.status === "closed" || exitRoom.status === "respawn") {
                    return;
                }
                if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === exitRoom.roomName; }).length > 0) {
                    return;
                }
                if (creeps.filter(c => c.memory.targetRoom === exitRoom.roomName).length > 0) {
                    return;
                }
                const spawnRooms = Geo.closestHomeRoomsByRange(exitRoom.roomName, 2, {
                    minLevel: 8,
                    maxDistance: MAX_EXPANSION_RANGE,
                    room: r => !r.isAbandoning
                });
                if (spawnRooms.length === 0) {
                    return;
                }
                Spawns.addToQue(spawnRooms, {
                    body: BodyParts.new().move(5).claim(),
                    priority: 4 /* Low */,
                    role: ROLE_NAME$4,
                    memory: {
                        targetRoom: exitRoom.roomName
                    }
                });
                Rooms.addUnclaimRoomIntent(exitRoom.roomName, 10000);
            });
        });
    }
    static handleSpawn() {
        const que = Creeps.queByRole(ROLE_NAME$4);
        const creeps = Creeps.getByRole(ROLE_NAME$4).filter(c => !c.ticksToLive || c.ticksToLive > 50);
        Rooms.memoryObjectRoomValues.forEach(room => {
            if (Game.cpu.bucket < 1000) {
                return;
            }
            if (room.isMine) {
                return;
            }
            if (room.isInSafeMode()) {
                return;
            }
            // if (roomModel.level >= 7) {
            //   return;
            // }
            if (!room.ownerUsername) {
                return;
            }
            // if (FRIENDLIES.includes(roomModel.ownerUsername)) {
            //   return;
            // }
            if (!room.hostileCreepCount) {
                return;
            }
            if ((room.towerCount || 0) > 0) {
                return;
            }
            if (room.status === "closed" || room.status === "respawn") {
                return;
            }
            // if ((room.safeModeCooldownEndsAt || 0) > Game.time + CREEP_CLAIM_LIFE_TIME + 6 * CREEP_SPAWN_TIME) {
            //   return;
            // }
            const creepsCount = que.filter(c => { var _a; return ((_a = c.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === room.roomName; }).length +
                creeps.filter(c => c.memory.targetRoom === room.roomName).length;
            if (creepsCount >= 1) {
                return;
            }
            const spawnRooms = Geo.closestHomeRoomsByRange(room.roomName, 2, {
                minLevel: 8,
                maxDistance: MAX_EXPANSION_RANGE
            });
            Spawns.addToQue(spawnRooms, {
                body: BodyParts.new().move(5).claim(),
                priority: 4 /* Low */,
                role: ROLE_NAME$4,
                memory: { targetRoom: room.roomName }
            });
        });
    }
}
__decorate([
    Profiler.subprofile("creep")
], SafeModeBlockClaimer, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], SafeModeBlockClaimer, "handleSafeModeSpawn", null);
__decorate([
    Profiler.subprofile("spawn")
], SafeModeBlockClaimer, "handleSpawn", null);

class NotifyStorageFull {
    static handle() {
        General.interval(500, () => this.checkFullStorages());
    }
    static checkFullStorages() {
        Rooms.myRooms.forEach(room => {
            if (room.storage && room.storage.store.getFreeCapacity() === 0) {
                Game.notify(`Storage in room ${room.name} is full.`);
            }
            if (room.terminal && room.terminal.store.getFreeCapacity() === 0) {
                Game.notify(`Terminal in room ${room.name} is full.`);
            }
        });
    }
}

const ROLE_NAME$3 = roles.ScoutSignSpreader;
class ScoutSignSpreader {
    static handle() {
        Creeps.getByRole(ROLE_NAME$3)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(1000, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        this.travelToRoom(creep) || this.nameController(creep) || this.die(creep);
    }
    static die(creep) {
        return creep.suicide() === OK;
    }
    static nameController(creep) {
        if (!creep.room.controller) {
            return false;
        }
        if (creep.room.controller.signUsername === USERNAME.ME) {
            return false;
        }
        if (creep.room.controller.pos.openSpots.length === 0) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.controller);
        if (distance > 1) {
            creep.travel(creep.room.controller);
        }
        else {
            if (creep.signController(creep.room.controller, SIGNATURE) === OK) {
                creep.room.mem.signatureOwner = USERNAME.ME;
            }
        }
        return true;
    }
    static travelToRoom(creep) {
        if (!creep.memory.targetRoom) {
            return false;
        }
        return creep.travelToRoom(creep.memory.targetRoom, { ignoreHostiles: false });
    }
    static handleSpawn() {
        if (Game.cpu.bucket < 1000) {
            return;
        }
        const creeps = Creeps.getByRole(ROLE_NAME$3);
        const que = Creeps.queByRole(ROLE_NAME$3);
        this.spawnerNaming(creeps, que);
    }
    static spawnerNaming(creeps, que) {
        const MAX_SPAWNS = 10;
        const currentlyActive = creeps.length + que.length;
        if (MAX_SPAWNS < currentlyActive) {
            return;
        }
        const rooms = Rooms.memoryObjectRoomValues.filter(mem => mem.type === RoomTypeEnum.STANDART &&
            mem.signatureOwner !== USERNAME.ME &&
            !mem.hitsDefenceBuildingCount &&
            !mem.ownerUsername &&
            !mem.reservationUsername);
        // if (rooms.length > 20) {
        //   console.log("many rooms need naming", rooms.length, rooms.map(r => r.name).join(", "));
        // }
        for (const targetRoomMemory of rooms) {
            if (MAX_SPAWNS < currentlyActive) {
                return;
            }
            const roomName = targetRoomMemory.name;
            if (!roomName) {
                continue;
            }
            if (que.filter(c => { var _a; return ((_a = c.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === roomName; }).length > 0) {
                continue;
            }
            if (creeps.filter(c => c.memory.targetRoom === roomName).length > 0) {
                continue;
            }
            const exits = Object.values(Game.map.describeExits(roomName)).filter(exitRoomName => {
                if (!exitRoomName) {
                    return false;
                }
                const mem = Rooms.memory(exitRoomName);
                return mem.isMine || !mem.towerCount;
            });
            if (exits.length === 0) {
                continue;
            }
            const spawnRoom = Geo.closestHomeRoomByRange(roomName, {
                minLevel: 3,
                maxDistance: MAX_EXPANSION_RANGE,
                room: room => room.myActiveSpawns.length > 0
            });
            if (!spawnRoom) {
                continue;
            }
            Spawns.addToQue(spawnRoom.name, {
                body: BodyParts.new().move(1),
                priority: 4 /* Low */,
                role: ROLE_NAME$3,
                memory: { targetRoom: roomName }
            });
            Log.room(roomName, "spawning sign scout", spawnRoom.name);
        }
    }
    static spawnerFlag(creeps, que) {
        Flags.flags(FlagType.scouter).forEach(flag => {
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetFlag) === flag.name; }).length > 0) {
                return;
            }
            if (creeps.filter(c => c.memory.targetFlag === flag.name && (!c.ticksToLive || c.ticksToLive > 700)).length > 0) {
                return;
            }
            const spawnRoom = Geo.closestHomeRoomByRange(flag.pos.roomName, {
                maxDistance: 20,
                minLevel: 4
            });
            if (!spawnRoom) {
                Log.room(flag.pos.roomName, "BaseNeighbourScouter", "spawnerFlag", "Cant find closest room to spawn");
                return;
            }
            Spawns.addToQue(spawnRoom, {
                body: new BodyParts().add(MOVE).get(),
                priority: 0 /* Highest */,
                role: ROLE_NAME$3,
                memory: {
                    targetFlag: flag.name
                }
            });
        });
    }
}
__decorate([
    Profiler.subprofile("creep")
], ScoutSignSpreader, "handleCreep", null);

const ROLE_NAME$2 = roles.DismantlerQuad;
class DismantlerQuad {
    static handle() {
        Quads.allByrole(ROLE_NAME$2).forEach(quad => {
            try {
                this.workQuad(quad);
            }
            catch (e) {
                quad.stage = QuadGroupStage.RETREATING;
            }
        });
        General.interval(40, () => TickAction.add(() => this.spawnFlag()));
        this.suicideQuadless();
    }
    static suicideQuadless() {
        Creeps.getByRole(ROLE_NAME$2).forEach(c => {
            var _a;
            if (!c.ticksToLive) {
                return;
            }
            if (!((_a = c.memory.quad) === null || _a === void 0 ? void 0 : _a.id) || !Memory.quads || !Memory.quads[c.memory.quad.id]) {
                Log.object(c, "missing quad id - suiciding");
                c.recycleFinal(1500);
                return;
            }
        });
    }
    static workQuad(quadMemory) {
        var _a, _b;
        const quad = new QuadModel(quadMemory);
        quad.getCreeps().forEach(creep => {
            if (creep.spawning) {
                return;
            }
            this.workCreep(creep);
        });
        const targetFlag = quad.memory.targetFlag ? Game.flags[quad.memory.targetFlag] : null;
        if (!targetFlag) {
            quad.setStage(QuadGroupStage.RETREATING);
            return;
        }
        if (targetFlag.roomMem.safeModeEndsAt || ((_b = (_a = targetFlag.room) === null || _a === void 0 ? void 0 : _a.controller) === null || _b === void 0 ? void 0 : _b.safeMode)) {
            quad.setStage(QuadGroupStage.RETREATING);
        }
        quad
            .inStage(QuadGroupStage.SPAWNING, () => {
            quad.refresh() || quad.waitTillAllAlive() || quad.setStage(QuadGroupStage.BOOSTING);
        })
            .inStage(QuadGroupStage.BOOSTING, () => {
            quad.boost() || quad.setStage(QuadGroupStage.TRAVELING);
        })
            .inStage(QuadGroupStage.TRAVELING, () => {
            quad.setStage(QuadGroupStage.ATTACKING);
        })
            .inStage(QuadGroupStage.ATTACKING, () => {
            if (quad.anchorCreep.pos.roomName === targetFlag.pos.roomName) {
                // if (quad.getRangeTo(targetFlag.pos) <= 50) {
                this.kite(quad) ||
                    quad.retreatWhenNotFull() ||
                    quad.formQuadIfPossible() ||
                    quad.turnToDirection(LEFT) ||
                    // this.moveToHostiles(quad, targetFlag) ||
                    this.moveToFlag(quad, targetFlag);
            }
            else {
                quad.travelTo(new RoomPosition(25, 25, targetFlag.pos.roomName), 25);
            }
            // const targetRoom = Game.rooms[quad.memory.targetRoom];
            //
            // if (targetRoom) {
            //   if (stronghold.isAlive) {
            //     const possibleLocations = this.possibleActiveStrongholdStandingPositions(targetRoom)
            //       .filter(pos => quad.canFormQuadOn(pos))
            //       .sort((a, b) => quad.getRangeTo(a) - quad.getRangeTo(b));
            //
            //     // figure best position for shit and go there
            //
            //     if (possibleLocations.length === 0) {
            //       return;
            //     }
            //
            //     if (possibleLocations.find(p => p.isEqualTo(quad.anchorCreep.pos))) {
            //       return;
            //     }
            //
            //     const ramparts = quad.anchorCreep.room.find(FIND_HOSTILE_STRUCTURES, {
            //       filter: s => s.structureType === STRUCTURE_RAMPART
            //     });
            //
            //     const obstacles = Object.values(
            //       ramparts.reduce((obs, rampart) => {
            //         rampart.pos.quadCoordinatesAround(1).forEach(p => {
            //           obs[`${p.x}.${p.y}`] = { x: p.x, y: p.y };
            //         });
            //
            //         return obs;
            //       }, {} as Record<string, Pos>)
            //     );
            //
            //     quad.moveTo(possibleLocations, 0, { obstacles });
            //   } else {
            //     const possibleLocations = this.possibleDeadStrongholdStandingPositions(quad.anchorCreep.room)
            //       .filter(pos => quad.canFormQuadOn(pos))
            //       .sort((a, b) => quad.getRangeTo(a) - quad.getRangeTo(b));
            //
            //     // figure best position for shit and go there
            //
            //     if (possibleLocations.length === 0) {
            //       return;
            //     }
            //
            //     if (possibleLocations.find(p => p.isEqualTo(quad.anchorCreep.pos))) {
            //       return;
            //     }
            //
            //     quad.moveTo(possibleLocations[0], 0);
            //   }
            // } else {
            //   quad.moveTo(invaderPosition, 5);
            // }
        })
            .inStage(QuadGroupStage.RETREATING, () => {
            quad.retreat();
        });
    }
    static moveToHostiles(quad, flag) {
        if (flag.pos.roomName !== quad.anchorCreep.pos.roomName) {
            return false;
        }
        const hostiles = quad.anchorCreep.room.find(FIND_HOSTILE_CREEPS);
        if (hostiles.length === 0) {
            return false;
        }
        quad.moveToV2(hostiles.map(h => ({ pos: h.pos, range: 2 })));
        return true;
    }
    static moveToFlag(quad, flag) {
        if (quad.anchorCreep.pos.isEqualTo(flag.pos)) {
            return false;
        }
        quad.moveTo(flag.pos, 0);
        return false;
    }
    static kite(quad) {
        if (quad.hitsMax - quad.hits >= 2000) {
            quad.kite();
            return true;
        }
        return false;
    }
    static possibleActiveStrongholdStandingPositions(room) {
        return TickCache.cache({
            key: `${this.constructor.name}.${room.name}.possibleActiveStrongholdStandingPositions`,
            callback: () => {
                const ramparts = room.find(FIND_HOSTILE_STRUCTURES, { filter: s => s.structureType === STRUCTURE_RAMPART });
                const unique = {};
                ramparts.forEach(rampart => {
                    rampart.pos.quadCoordinatesAround(2).forEach(p => {
                        unique[`${p.x}.${p.y}`] = new RoomPosition(p.x, p.y, room.name);
                    });
                });
                ramparts.forEach(rampart => {
                    rampart.pos.quadCoordinatesAround(1).forEach(p => {
                        delete unique[`${p.x}.${p.y}`];
                    });
                    delete unique[`${rampart.pos.x}.${rampart.pos.y}`];
                });
                Object.values(unique).forEach(pos => {
                    room.visual.circle(pos.x, pos.y, { radius: 0.1 });
                });
                return Object.values(unique);
            }
        });
    }
    static possibleDeadStrongholdStandingPositions(room) {
        return TickCache.cache({
            key: `${this.constructor.name}.${room.name}.possibleDeadStrongholdStandingPositions`,
            callback: () => {
                const ramparts = room.find(FIND_HOSTILE_STRUCTURES, { filter: s => s.structureType === STRUCTURE_RAMPART });
                const unique = {};
                ramparts.forEach(rampart => {
                    rampart.pos.quadCoordinatesAround(1).forEach(p => {
                        unique[`${p.x}.${p.y}`] = new RoomPosition(p.x, p.y, room.name);
                    });
                });
                ramparts.forEach(rampart => {
                    delete unique[`${rampart.pos.x}.${rampart.pos.y}`];
                });
                Object.values(unique).forEach(pos => {
                    room.visual.circle(pos.x, pos.y, { radius: 0.1 });
                });
                return Object.values(unique);
            }
        });
    }
    static workCreep(creep) {
        creep.healMele() || this.healSelf(creep) || this.prehealHighestPotential(creep) || this.prehealAttacker(creep); // ||
        // this.prehealSelfAttacker(creep) ||
        // this.preheal(creep) ||
        // creep.prehealMele();
        this.attack(creep);
    }
    static healSelf(creep) {
        if (creep.hits >= creep.hitsMax - 200) {
            return false;
        }
        if (!creep.healPower) {
            return false;
        }
        creep.heal(creep);
        return true;
    }
    static spawnFlag() {
        if (!Memory.quads) {
            Memory.quads = {};
        }
        const quads = Object.values(Memory.quads).filter(g => g.role === ROLE_NAME$2);
        // blue - green - unboosted
        Flags.flags(FlagType.dismantlerQuad).forEach(flag => {
            const flagRoom = Rooms.memory(flag.pos.roomName);
            if (flagRoom.safeModeEndsAt || 0 > Game.time) {
                return;
            }
            const flagQuads = quads.filter(g => g.targetFlag === flag.name);
            const quadsInAction = flagQuads.filter(q => q.stage !== QuadGroupStage.RETREATING && q.ticksToLive > 300).length;
            if (quadsInAction > 0) {
                return;
            }
            const spawnRoom = Geo.closestHomeRoomByRange(flag.pos.roomName, {
                maxDistance: MAX_EXPANSION_RANGE,
                room: r => r.level >= 8 && !Quads.isSpawningInRoom(r.name) && !Duos.isSpawningInRoom(r.name)
            });
            if (!spawnRoom) {
                return;
            }
            // spawn shit
            console.log("spawning in ", spawnRoom.name);
            const creeps = {
                [QuadPosition.BOTTOM_LEFT]: `biatch-${General.uniqueId()}`,
                [QuadPosition.BOTTOM_RIGHT]: `biatch-${General.uniqueId()}`,
                [QuadPosition.TOP_LEFT]: `biatch-${General.uniqueId()}`,
                [QuadPosition.TOP_RIGHT]: `biatch-${General.uniqueId()}`
            };
            const quadId = Quads.create({
                homeRoom: spawnRoom.name,
                role: ROLE_NAME$2,
                stage: QuadGroupStage.SPAWNING,
                targetFlag: flag.name,
                targetRoom: flag.pos.roomName,
                creeps
            });
            const creepNames = Object.values(creeps);
            for (let i = 0; i < 4; i++) {
                if (i % 2 === 0) {
                    Spawns.addToQue(spawnRoom, {
                        // body: BodyParts.new().tough(5).move(8).work(35).move(2),
                        body: BodyParts.new().tough(10).move(8).work(30).move(2),
                        priority: 0 /* Highest */,
                        role: ROLE_NAME$2,
                        boosts: [BOOST_ALIAS.TOUGH_3, BOOST_ALIAS.MOVE_3, BOOST_ALIAS.DISMANTLE_3],
                        memory: {
                            quad: {
                                id: quadId,
                                attacker: true
                            }
                        },
                        maxQueTime: 1000,
                        name: creepNames[i]
                    });
                }
                else {
                    Spawns.addToQue(spawnRoom, {
                        // body: BodyParts.new().tough(10).move(8).heal(30).move(2),
                        body: BodyParts.new().tough(5).move(8).heal(35).move(2),
                        priority: 0 /* Highest */,
                        role: ROLE_NAME$2,
                        boosts: [BOOST_ALIAS.TOUGH_3, BOOST_ALIAS.MOVE_3, BOOST_ALIAS.HEAL_3],
                        memory: {
                            quad: {
                                id: quadId,
                                healer: true
                            }
                        },
                        maxQueTime: 1000,
                        name: creepNames[i]
                    });
                }
            }
            spawnRoom.mem.increasedSpawnUntil = Game.time + 1500;
        });
    }
    static prehealSelfAttacker(creep) {
        var _a;
        if (creep.room.my) {
            return false;
        }
        if ((_a = creep.memory.quad) === null || _a === void 0 ? void 0 : _a.attacker) {
            return false;
        }
        creep.heal(creep);
        return true;
    }
    // private preheal2(): boolean {
    //   if (this.creep.room.my) return false;
    //   if (this.creep.Misc.quad?.role !== "healer") return false;
    //
    //   const attackers = this.creep.pos.findInRange(FIND_MY_CREEPS, 1).find(c => c.Misc.quad?.role === "attacker");
    //
    //   return true;
    // }
    static prehealHighestPotential(creep) {
        if (creep.room.my) {
            return false;
        }
        if (!creep.healPower) {
            return false;
        }
        const expectedHighestDamageCreeps = creep.pos
            .findInRange(FIND_MY_CREEPS, 1)
            .sort((a, b) => b.expectedDamageTakenV2(1, c => !c.my) - a.expectedDamageTakenV2(1, c => !c.my));
        const lowestCreep = expectedHighestDamageCreeps[0];
        const lowestCreepDamageExpected = (lowestCreep === null || lowestCreep === void 0 ? void 0 : lowestCreep.expectedDamageTakenV2(1, c => !c.my)) || 0;
        if (!lowestCreep) {
            return false;
        }
        if (lowestCreepDamageExpected === 0) {
            return false;
        }
        const secondPotentialCreep = expectedHighestDamageCreeps[1];
        const secondPotentialCreepDamageExpected = (secondPotentialCreep === null || secondPotentialCreep === void 0 ? void 0 : secondPotentialCreep.expectedDamageTakenV2(1, c => !c.my)) || 0;
        if (secondPotentialCreep && secondPotentialCreepDamageExpected / lowestCreepDamageExpected > 0.9) {
            // secondPotentialCreep.say(String(secondPotentialCreepDamageExpected));
            // lowestCreep.say(String(lowestCreepDamageExpected));
            return false;
        }
        creep.heal(expectedHighestDamageCreeps[0]);
        expectedHighestDamageCreeps[0].preheal += creep.healPower;
        return true;
    }
    static prehealAttacker(creep) {
        if (creep.room.my) {
            return false;
        }
        if (!creep.healPower) {
            return false;
        }
        const attacker = creep.pos
            .findInRange(FIND_MY_CREEPS, 1, {
            filter: c => { var _a; return (_a = c.memory.quad) === null || _a === void 0 ? void 0 : _a.attacker; }
        })
            .sort((a, b) => a.preheal - b.preheal)[0];
        if (!attacker) {
            return false;
        }
        creep.heal(attacker);
        attacker.preheal += creep.healPower;
        return true;
    }
    static preheal(creep) {
        var _a;
        if (creep.room.my) {
            return false;
        }
        if (creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3).length === 0) {
            return false;
        }
        if (!creep.body.find(b => b.type === HEAL && b.hits > 0)) {
            return false;
        }
        const prehealee = ((_a = StrongholdUtils.focusMax2(creep.room)
            .filter(c => c.creep.pos.inRangeTo(creep, 1))
            .sort((a, b) => a.creep.preheal - b.creep.preheal)[0]) === null || _a === void 0 ? void 0 : _a.creep) ||
            creep.pos.findInRange(FIND_MY_CREEPS, 1).sort((a, b) => a.preheal - b.preheal)[0];
        if (!creep) {
            return false;
        }
        if (creep.heal(creep) === OK) {
            prehealee.preheal = prehealee.preheal + creep.healPower;
        }
        return true;
    }
    static attack(creep) {
        this.dismantle(creep);
    }
    static dismantle(creep) {
        if (!creep.dismantlePower) {
            return false;
        }
        const structures = creep.pos.findInRange(FIND_HOSTILE_STRUCTURES, 1, { filter: s => s.hits > 0 });
        const hostileStructure = structures
            .filter(s => s.structureType !== STRUCTURE_RAMPART && !s.pos.rampart)
            .sort((a, b) => a.hits - b.hits)[0] ||
            structures
                .filter(s => s.structureType === STRUCTURE_RAMPART &&
                s.pos.lookFor(LOOK_FLAGS).filter(f => f.color === COLOR_YELLOW && f.secondaryColor === COLOR_GREY).length >
                    0)
                .sort((a, b) => a.hits - b.hits)[0] ||
            structures.filter(s => s.structureType === STRUCTURE_RAMPART).sort((a, b) => a.hits - b.hits)[0];
        if (!hostileStructure) {
            return false;
        }
        creep.dismantle(hostileStructure);
        return true;
    }
    static snipeCore(creep) {
        if (!creep.room.invaderCore) {
            return false;
        }
        if (creep.pos.getRangeTo(creep.room.invaderCore) > 3) {
            return false;
        }
        const rampart = creep.room.invaderCore.pos
            .lookFor(LOOK_STRUCTURES)
            .find(s => s.structureType === STRUCTURE_RAMPART);
        creep.rangedAttack(rampart || creep.room.invaderCore);
        return true;
    }
}

const ROLE_NAME$1 = roles.StructureCleanerClaimer;
class StructureCleanerClaimer {
    static handle() {
        Creeps.getByRole(ROLE_NAME$1)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(1500, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        this.drawTicksRemaining(creep);
        this.goToTargetPos(creep) ||
            this.goToTargetRoom(creep) ||
            this.signController(creep) ||
            this.attackController(creep) ||
            this.claimController(creep) ||
            this.suicide(creep);
    }
    static drawTicksRemaining(creep) {
        Game.map.visual.text(String(creep.ticksToLive), creep.pos);
    }
    static signController(creep) {
        if (creep.room.name !== creep.memory.targetRoom) {
            return false;
        }
        if (!creep.room.controller) {
            return false;
        }
        if (creep.room.controller.signUsername === USERNAME.SCREEPS) {
            return false;
        }
        if (creep.room.controller.signText === SIGNATURE) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.controller);
        if (distance > 1) {
            creep.travel(creep.room.controller);
        }
        else {
            creep.signController(creep.room.controller, SIGNATURE);
        }
        return true;
    }
    static attackController(creep) {
        if (!creep.room.controller) {
            return false;
        }
        if (creep.room.controller.my) {
            return false;
        }
        if (!creep.room.controller.reservation) {
            return false;
        }
        if (creep.room.controller.reservation.username === USERNAME.ME) {
            return false;
        }
        if (creep.attackController(creep.room.controller) === ERR_NOT_IN_RANGE) {
            creep.travel(creep.room.controller);
        }
        return true;
    }
    static claimController(creep) {
        if (!creep.room.controller) {
            return false;
        }
        if (creep.room.controller.my) {
            return false;
        }
        if (creep.room.name !== creep.memory.targetRoom) {
            return false;
        }
        const distance = creep.pos.getRangeTo(creep.room.controller);
        if (distance > 1) {
            creep.travel(creep.room.controller);
        }
        else {
            creep.claimController(creep.room.controller);
        }
        return true;
    }
    static goToTargetPos(creep) {
        if (!creep.memory.targetPos) {
            return false;
        }
        if (!creep.memory.targetRoom) {
            return false;
        }
        return creep.travel({ pos: new RoomPosition(creep.memory.targetPos.x, creep.memory.targetPos.y, creep.memory.targetRoom) }, { ignoreHostiles: false, range: 1 });
    }
    static goToTargetRoom(creep) {
        if (!creep.targetRoomModel) {
            return false;
        }
        return creep.travelToRoom(creep.targetRoomModel.roomName, { ignoreHostiles: false });
    }
    static suicide(creep) {
        if (creep.room.name !== creep.memory.targetRoom) {
            return false;
        }
        if (!creep.room.my) {
            return false;
        }
        creep.die();
        return true;
    }
    static handleSpawn() {
        if (Rooms.myRooms.length >= Game.gcl.level) {
            return;
        }
        const creeps = Creeps.getByRole(ROLE_NAME$1);
        const que = Creeps.queByRole(ROLE_NAME$1);
        Rooms.memoryObjectRoomValues
            .filter(mem => (mem.updatedAt || 0) > Game.time - 2000 &&
            mem.type === RoomTypeEnum.STANDART &&
            !mem.ownerUsername &&
            (!mem.reservationUsername || mem.reservationUsername === USERNAME.ME) &&
            mem.hitsDefenceBuildingCount)
            .forEach(room => {
            var _a;
            if (que.filter(c => { var _a; return ((_a = c.memory) === null || _a === void 0 ? void 0 : _a.targetRoom) === room.roomName; }).length > 0) {
                return;
            }
            if (creeps.filter(c => c.memory.targetRoom === room.roomName).length > 0) {
                return;
            }
            const spawnRoom = Geo.closestHomeRoomByRange(room.roomName, {
                minLevel: 3,
                maxDistance: MAX_EXPANSION_RANGE,
                room: r => r.myActiveSpawns.length > 0
            });
            if (!spawnRoom) {
                return;
            }
            const center = ((_a = spawnRoom.storage) === null || _a === void 0 ? void 0 : _a.pos) || spawnRoom.center;
            if (!center) {
                return;
            }
            Rooms.whenVisible(room.roomName, (r) => {
                if (!r.controller) {
                    return;
                }
                const route = Geo.findRouteCached(spawnRoom.name, room.roomName);
                if (route.length === 0) {
                    return;
                }
                const ret = PathFinder.search(center, { pos: r.controller.pos, range: 1 }, {
                    maxRooms: 64,
                    maxOps: 10000,
                    roomCallback(roomName) {
                        if (!route.includes(roomName)) {
                            return false;
                        }
                        return Rooms.matrix(roomName);
                    }
                });
                if (ret.incomplete) {
                    if (ret.path[ret.path.length - 1].roomName === r.name) {
                        this.spawnDismantler(spawnRoom, room);
                    }
                    return;
                }
                Spawns.addToQue(spawnRoom.name, {
                    body: BodyParts.new().move(5).claim(),
                    priority: 4 /* Low */,
                    role: ROLE_NAME$1,
                    memory: { targetRoom: room.roomName, targetPos: { x: r.controller.pos.x, y: r.controller.pos.y } }
                });
                Log.room(room.roomName, "spawning room cleaning claimer from", spawnRoom.name);
                Rooms.addUnclaimRoomIntent(room.roomName, 10000);
            });
        });
    }
    static spawnDismantler(spawnRoom, targetRoom) {
        Spawns.addToQue(spawnRoom.name, {
            body: BodyParts.new().move(25).work(25),
            priority: 4 /* Low */,
            role: roles.Dismantler,
            memory: { targetRoom: targetRoom.roomName }
        });
        Log.room(spawnRoom.name, "spawning room cleaning dismantler", targetRoom.roomName);
    }
}
__decorate([
    Profiler.subprofile("creep")
], StructureCleanerClaimer, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], StructureCleanerClaimer, "handleSpawn", null);

class RoomEvents {
    static handle() {
        Rooms.visible.forEach(room => {
            room.getEventLog().forEach(event => {
                switch (event.event) {
                    case EVENT_ATTACK:
                        break;
                    case EVENT_OBJECT_DESTROYED:
                        this.handleObjectDestroyed(room);
                        break;
                    case EVENT_ATTACK_CONTROLLER:
                        break;
                    case EVENT_BUILD:
                        break;
                    case EVENT_HARVEST:
                        break;
                    case EVENT_HEAL:
                        break;
                    case EVENT_REPAIR:
                        break;
                    case EVENT_RESERVE_CONTROLLER:
                        break;
                    case EVENT_UPGRADE_CONTROLLER:
                        break;
                    case EVENT_EXIT:
                        break;
                    case EVENT_POWER:
                        break;
                    case EVENT_TRANSFER:
                        break;
                }
            });
        });
    }
    static handleObjectDestroyed(room) {
        Rooms.matrixReset(room.name);
    }
}

const ROLE_NAME = "BaseTerminalDumper";
// const TERMINAL_STRUCTURE_CONFIG = Config.TerminalStructureWorker;
class BaseTerminalDumper {
    static handle() {
        Creeps.getByRole(ROLE_NAME)
            .filter(c => !c.spawning)
            .forEach(creep => {
            this.handleCreep(creep);
        });
        General.interval(20, () => TickAction.add(() => this.handleSpawn()));
    }
    static handleCreep(creep) {
        if (creep.store.getUsedCapacity() === 0) {
            this.withdrawFullTerminal(creep) || this.withdrawFullStorage(creep);
        }
        else {
            this.dropResources(creep);
        }
    }
    static handleSpawn() {
        const creeps = Creeps.getByRole(ROLE_NAME);
        const que = Creeps.queByRole(ROLE_NAME);
        Flags.flags(FlagType.baseTerminalDumper).forEach(flag => {
            if (!flag.room) {
                return;
            }
            if (!flag.room.my) {
                return;
            }
            if (que.filter(q => { var _a; return ((_a = q.memory) === null || _a === void 0 ? void 0 : _a.targetFlag) === flag.name; }).length > 0) {
                return;
            }
            if (creeps.filter(c => c.memory.targetFlag === flag.name).length > 0) {
                return;
            }
            Spawns.addToQue(flag.room, {
                body: BodyParts.new().move(1).carry(4),
                optionalBody: flag.room.level >= 6 ? BodyParts.new().carry(16) : BodyParts.new().carry(2),
                priority: 3 /* Medium */,
                role: ROLE_NAME,
                memory: { stationary: true, targetFlag: flag.name }
            });
        });
    }
    static terminalOwerflowAmount(creep, resource) {
        if (!creep.room.terminal) {
            return 0;
        }
        const config = CONFIG_BALANCE[resource];
        return Math.max(0, creep.room.terminal.store[resource] - config.terminalMinAmount);
    }
    static storageHasFreeSpace(creep) {
        var _a;
        return (((_a = creep.room.storage) === null || _a === void 0 ? void 0 : _a.store.getFreeCapacity()) || 0) >= 20000;
    }
    static terminalHasFreeSpace(creep) {
        var _a;
        return (((_a = creep.room.terminal) === null || _a === void 0 ? void 0 : _a.store.getFreeCapacity()) || 0) >= 5000;
    }
    static dropResources(creep) {
        const resource = Resources.firstStoreResource(creep.store);
        if (!resource) {
            return false;
        }
        creep.drop(resource);
        return true;
    }
    static withdrawFullTerminal(creep) {
        if (!creep.room.terminal) {
            return false;
        }
        if (this.terminalHasFreeSpace(creep)) {
            return false;
        }
        const resources = Object.entries(Resources.resourceValues)
            .sort((a, b) => a[1] - b[1])
            .map(r => r[0]);
        for (const resource of resources) {
            const overflowingAmount = this.terminalOwerflowAmount(creep, resource);
            if (!overflowingAmount) {
                continue;
            }
            if (creep.room.terminal.store.getUsedCapacity(resource) < overflowingAmount) {
                continue;
            }
            if (creep.withdraw(creep.room.terminal, resource) === ERR_NOT_IN_RANGE) {
                creep.travel(creep.room.terminal);
            }
            return true;
        }
        return false;
    }
    static withdrawFullStorage(creep) {
        if (!creep.room.storage) {
            return false;
        }
        if (this.storageHasFreeSpace(creep)) {
            return false;
        }
        const resources = Object.entries(Resources.resourceValues)
            .sort((a, b) => a[1] - b[1])
            .map(r => r[0]);
        for (const resource of resources) {
            const overflowingAmount = this.terminalOwerflowAmount(creep, resource);
            if (!overflowingAmount) {
                continue;
            }
            if (creep.room.storage.store.getUsedCapacity(resource) < overflowingAmount) {
                continue;
            }
            if (creep.withdraw(creep.room.storage, resource) === ERR_NOT_IN_RANGE) {
                creep.travel(creep.room.storage);
            }
            return true;
        }
        return false;
    }
    static moveToCenter(creep) {
        const center = General.expansionWithSupport() && creep.room.level < 7
            ? creep.room.centerLeveling || creep.room.center
            : creep.room.center;
        if (!center) {
            return false;
        }
        if (creep.pos.isEqualTo(center)) {
            return false;
        }
        const blockingCreep = center.lookFor(LOOK_CREEPS)[0];
        if (blockingCreep) {
            blockingCreep.moveTo(creep);
        }
        creep.moveTo(center, { ignoreCreeps: true });
        return true;
    }
    static renewCreep(creep) {
        if (!creep.ticksToLive) {
            return false;
        }
        if (creep.ticksToLive > 1300) {
            return false;
        }
        if (creep.store.getCapacity() < 1000) {
            return false;
        }
        const spawns = creep.room
            .find(FIND_MY_SPAWNS)
            .filter(s => s.spawning === null && !s.actionPending && s.store.energy >= 100 && s.cachedIsActive());
        if (spawns.length === 0) {
            return false;
        }
        for (const spawn of spawns) {
            if (spawn.renewCreepV2(creep)) {
                return true;
            }
        }
        return false;
    }
}
__decorate([
    Profiler.subprofile("creep")
], BaseTerminalDumper, "handleCreep", null);
__decorate([
    Profiler.subprofile("spawn")
], BaseTerminalDumper, "handleSpawn", null);

const modules = [WarManual, WarDowngrade];
const gen3 = [
    // MEMORY
    CleanupMemory,
    MemoryRoom,
    MemoryRoomRemotes,
    RoomHostilityMemory,
    RoomLabOutputMemory,
    CleanupConstructions,
    ClearExpiredFlags,
    DisableCreepNotifications,
    SectorMemory,
    NotifyStorageFull,
    RoomEvents,
    // RoomLayoutMemory,
    // DISMANTLER
    Dismantler,
    DismantlerDuo,
    DismantlerQuad,
    // STRONGHOLD
    Stronghold1Attacker,
    Stronghold2Attacker,
    Stronghold3Attacker,
    Stronghold4Attacker,
    // Stronghold5Attacker,
    // Stronghold4Attacker,
    StrongholdHauler,
    StrongholdDismantler,
    StrongholdProtector,
    // ATTACKER
    Attacker,
    AttackerDuo,
    AttackerRanged,
    AttackerRangedQuad,
    // BASE
    BaseCenterBalancer,
    BaseTerminalDumper,
    BaseEnergyBalancer,
    BaseLabBalancer,
    BaseBuilder,
    BaseNeighbourScouter,
    BaseMineralHauler,
    BaseMineralMiner,
    BaseNewbie,
    BaseNewbieHauler,
    BaseNukerGhodiumFiller,
    BasePowerCreep,
    BaseRoadRepairer,
    BaseTowerFiller,
    BaseUpgrader,
    BaseUpgradeHauler,
    BaseWallRepairer,
    BaseRampartDefender,
    BaseRampartRangedDefender,
    BaseEnergyHarvester,
    BaseEnergyHarvesterHauler,
    // BaseFactoryBalancer,
    PowerBankMinerDuo,
    PowerBankHauler,
    // GCL FARM
    GclFarmHauler,
    GclFarmUpgrader,
    GclFarmCenterBalancer,
    GclFarmResetter,
    // EXPANSION
    ExpansionClaimer,
    SafeModeBlockClaimer,
    StructureCleanerClaimer,
    // SK
    SKDefender,
    SKDefenderRanged,
    SKEnergyHauler,
    SKEnergyMiner,
    SKLooter,
    SKMaintainer,
    SKMineralHauler,
    SKMineralMiner,
    // REMOTE
    // RemoteMineMiner,
    // RemoteMineHauler,
    RemoteSourceHauler,
    RemoteSourceHarvester,
    RemoteMineReserver,
    RemoteMineDefender,
    RemoteMineInvaderCoreKiller,
    // STRUCTURES
    ControllerStructureWorker,
    LabStructureWorker,
    LinkStructureWorker,
    ObserverStructureWorker,
    PowerSpawnStructureWorker,
    SpawnStructureWorker,
    TerminalStructureWorker,
    FactoryStructureWorker,
    TowerStructureWorker,
    ScoutSignSpreader,
    // BASE CONSTRUCTIONS, (maybe implement cycling)
    BaseCenterLabConstruction,
    BaseCenterLinkConstruction,
    BaseCenterPowerSpawnConstruction,
    BaseCenterNewbieContainerConstruction,
    BaseCenterRoadConstruction,
    BaseCenterSpawnConstruction,
    BaseCenterStorageConstruction,
    BaseCenterTerminalConstruction,
    BaseControllerStorageConstruction,
    BaseExtensionConstruction,
    BaseExtractorConstruction,
    BaseLabConstruction,
    BaseLinkSourceConstruction,
    BaseFactoryConstruction,
    BaseNukerConstruction,
    BaseObserverConstruction,
    BaseRampartConstruction,
    BaseTowerConstruction,
    // VISUALS
    // ControllerUpgradeEtaVisuals,
    DamageVisuals,
    DeathVisuals,
    ReactionVisuals,
    SpawnQueueVisuals,
    SpawnSpawningVisuals,
    TerminalTransactions
];
function Modules() {
    modules.forEach(module => {
        try {
            ProfilerLegacy2.profile(module.name, () => new module().handle());
        }
        catch (e) {
            console.log(module.name, e);
        }
    });
    gen3.forEach(module => {
        try {
            Profiler.profileModule(module.name, () => module.handle());
        }
        catch (e) {
            console.log(module.name, e);
        }
    });
}

const roomResources = function () {
    console.log(`<strong>${"room".padEnd(7)}</strong>`, ...RESOURCES_ALL.map(r => r.padEnd(7)));
    Object.values(Game.rooms)
        .filter(room => { var _a; return (_a = room.controller) === null || _a === void 0 ? void 0 : _a.my; })
        .forEach(room => {
        // new RoomVisual(room).text(terminal.room.name, 3.5 * (index + 1), 0, { align: "left" });
        console.log(`<strong>${room.name.padEnd(7)}</strong>`, ...RESOURCES_ALL.map(r => room.store[r].toLocaleString("en-US").padEnd(7)));
    });
};
global.roomResources = roomResources;

function INJECT_SCRIPT() {
    window.addEventListener("hashchange", function () {
        window._injectedCreepMovements = false;
    });
    if (window._injectedCreepMovements) {
        console.info("[injectedCreepMovements]: Already ran injection script, reload page first");
        return;
    }
    window._injectedCreepMovements = true;
    const DIRECTIONS = [
        {
            "&#8598;": 8,
            "&#8593;": 1,
            "&#8599;": 2
        },
        {
            "&#8592;": 7,
            "&#8594;": 3
        },
        {
            "&#8601;": 6,
            "&#8595;": 5,
            "&#8600;": 4
        }
    ];
    if (!window._userId) {
        window._userId = angular.element(document.body).scope().Me()._id;
    }
    const sidebar = document.getElementsByClassName("aside-content")[0];
    const wrapper = document.createElement("div");
    wrapper.style.display = "flex";
    wrapper.style.flexWrap = "wrap";
    wrapper.id = "creepMovements";
    sidebar.appendChild(wrapper);
    angular.element($(".room.ng-scope")).scope().$watch("Room.selectedObject", onSelectedObjectChange);
    function onSelectedObjectChange(selectedObject) {
        wrapper.innerHTML = "";
        if ((selectedObject === null || selectedObject === void 0 ? void 0 : selectedObject.type) !== "creep") {
            return;
        }
        if ((selectedObject === null || selectedObject === void 0 ? void 0 : selectedObject.user) !== window._userId) {
            return;
        }
        DIRECTIONS.forEach(group => {
            Object.entries(group)
                .map(([name, v]) => {
                const onClick = () => {
                    angular
                        .element(document.body)
                        .injector()
                        .get("Connection")
                        .sendConsoleCommand(`Game.getObjectById('${selectedObject._id}').move(${v})`);
                    console.info(`<span>Game.getObjectById('${selectedObject._id}').move(${v})</span>`);
                };
                const button = document.createElement("button");
                button.type = "button";
                button.classList.add("md-primary", "md-hue-1", "md-button", "ng-scope", "md-ink-ripple");
                button.style.width = `${100 / Object.keys(group).length}%`;
                button.style.display = "block";
                button.onclick = onClick;
                button.innerHTML = `<span>${name}</span>`;
                return button;
            })
                .forEach(button => {
                wrapper.appendChild(button);
            });
        });
    }
}
function inject() {
    if (!global._injectedCreepMovements) {
        global._injectedCreepMovements = true;
        console.log(`<script>${INJECT_SCRIPT.toString().replace(/(\r\n|\n|\r)\t+|(\r\n|\n|\r) +|(\r\n|\n|\r)/gm, "")}; INJECT_SCRIPT();</script>`);
    }
}
global.i = () => {
    global._injectedCreepMovements = false;
    inject();
};
inject();

class HeapMemory {
    static load() {
        const start = Game.cpu.getUsed();
        this._memory = Memory;
        const end = Game.cpu.getUsed();
        console.log("parsing memory used", end - start, "cpu");
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this._memory = RawMemory._parsed;
        if (!this._memory.strongholds) {
            this._memory.strongholds = {};
        }
        if (!this._memory.powerBanks) {
            this._memory.powerBanks = {};
        }
    }
    static init() {
        delete global.Memory;
        global.Memory = this._memory;
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        RawMemory._parsed = this._memory;
    }
    static exit() {
        // todo set timeout every 10 ticks maybe
        // RawMemory.set(JSON.stringify(this._memory));
    }
}

// sources count
class roomClaimScore {
    static exit() {
        const mineralScores = calculateMineralScores();
        calculateSkMineralScores();
        const scores = [];
        getRoomsInRange()
            .map(roomName => Rooms.memory(roomName))
            .filter(room => isRoomValidForExpansion(room))
            .forEach(room => {
            let score = 0;
            const roomName = room.name;
            if (!roomName) {
                return;
            }
            const exits = scoreExits(room);
            score += exits * 0.5;
            const mineral = scoreMineral(room, mineralScores);
            score += mineral.score * 2;
            let sk;
            if (General.focusingOnSkRooms()) {
                sk = scoreSkNearby(roomName);
                score += sk;
            }
            const closestRoom = scoreNotNextToEachOtherOfMyRooms(roomName);
            score += closestRoom * 2;
            const scoreSector = scoreThreePerSector(roomName);
            score += scoreSector * 2;
            const walls = scoreWalls(roomName, room);
            score += walls * 2;
            // source too close to edge
            // mineral tooo close to edge
            // controller to close to edge
            Game.map.visual.text(`${score.toFixed(1)}`, new RoomPosition(25, 40, roomName));
            this.checkForBitchCave(roomName, room);
            scores.push({
                roomName,
                score,
                sk: sk === 1,
                exits: exits * 4,
                mineralType: mineral.mineral,
                mineralScore: mineral.score,
                owner: room.ownerUsername
            });
        });
        scores
            .sort((a, b) => b.score - a.score)
            .slice(0, 20)
            .forEach(i => {
            Log.room(i.roomName, i.score.toFixed(2), String(i.mineralType), i.mineralScore, i.owner || "-");
        });
    }
    static checkForBitchCave(roomName, mem) {
        if (mem.sourceCount !== 2) {
            return;
        }
        const exits = Object.values(Game.map.describeExits(roomName));
        if (exits.length !== 1) {
            return;
        }
        const exit = exits[0];
        if (!exit) {
            return;
        }
        const exitMem = Rooms.memory(exit);
        if (exitMem.sourceCount !== 2) {
            return;
        }
        Game.map.visual.rect(new RoomPosition(0, 0, roomName), 50, 50);
        Game.map.visual.rect(new RoomPosition(0, 0, exit), 50, 50);
        Log.room(exit, `bitch cave for ${roomName}`);
    }
}
function calculateSkMineralScores() {
    const idealMineralRatios = Minerals.idealMineralRatios();
    const currentMineralRatios = calculateCurrentMineralRatios();
    return RESOURCE_MINERALS.reduce((obj, mineral) => {
        if (!currentMineralRatios[mineral]) {
            obj[mineral] = 10;
        }
        else {
            obj[mineral] = (idealMineralRatios[mineral] / currentMineralRatios[mineral]) * 0.5;
        }
        return obj;
    }, {});
}
function calculateMineralScores() {
    const idealMineralRatios = Minerals.idealMineralRatios();
    const currentMineralRatios = calculateCurrentMineralRatios();
    let highest = 10;
    const totals = RESOURCE_MINERALS.reduce((obj, mineral) => {
        if (!currentMineralRatios[mineral]) {
            obj[mineral] = 10;
        }
        else {
            obj[mineral] = idealMineralRatios[mineral] / currentMineralRatios[mineral];
        }
        if (obj[mineral] > highest) {
            highest = obj[mineral];
        }
        return obj;
    }, {});
    for (const mineral in totals) {
        totals[mineral] = totals[mineral] / highest;
    }
    return totals;
}
function scoreWalls(roomName, mem) {
    const walls = mem.terrainWallsCount || 50 * 50;
    return 1 - walls / (50 * 50);
}
function scoreThreePerSector(roomName) {
    const sectorName = roomNameToSector(roomName);
    const myRoomsInSector = Rooms.myRooms.filter(r => r.mem.sectorName === sectorName);
    if (myRoomsInSector.length >= 3) {
        return 0;
    }
    if (myRoomsInSector.length > 1) {
        return 2;
    }
    return 1;
}
function scoreNotNextToEachOtherOfMyRooms(roomName) {
    var _a;
    const distances = Rooms.myRooms
        .map(room => Game.map.getRoomLinearDistance(roomName, room.name))
        .sort((a, b) => a - b);
    const closest = (_a = distances[0]) !== null && _a !== void 0 ? _a : 0;
    if (closest >= 5) {
        return 1;
    }
    return closest / 5;
}
// function scoreSkMineral(
//   roomName: string,
//   mineralScores: Record<MineralConstant, number>
// ): {
//   mineral?: string;
//   score: number;
// } {
//   const memory = Memory.rooms[roomName];
//
//   if (!memory) {
//     return { score: 0 };
//   }
//
//   const skRoomName = memory[ROOM_MEMORY_KEY_SK_ROOM];
//
//   if (!skRoomName) {
//     return { score: 0 };
//   }
//
//   const skMemory = Memory.rooms[skRoomName];
//
//   if (!skMemory) {
//     return { score: 0 };
//   }
//
//   const mineralType = skMemory[ROOM_MEMORY_KEY_MINERAL_TYPE];
//
//   if (!mineralType) {
//     return { score: 0 };
//   }
//
//   return {
//     mineral: mineralType,
//     score: mineralScores[mineralType] || 0
//   };
// }
function scoreMineral(room, mineralScores) {
    const mineralType = room.mineralType;
    if (!mineralType) {
        return { score: 0 };
    }
    return {
        mineral: mineralType,
        score: mineralScores[mineralType] || 0
    };
}
function scoreExits(room) {
    return room.name ? Object.values(Game.map.describeExits(room.name)).length / 4 : 0;
}
function scoreSkNearby(roomName) {
    return Object.values(Game.map.describeExits(roomName)).filter(r => r && roomNameToType(r) === RoomTypeEnum.SK)
        .length > 0
        ? 1
        : 0;
}
function calculateCurrentMineralRatios() {
    const myMinerals = RESOURCE_MINERALS.reduce((t, mineral) => {
        t[mineral] = 0;
        return t;
    }, {});
    Rooms.myRooms.forEach(room => {
        const mineral = room.mem.mineralType;
        if (!mineral) {
            return;
        }
        myMinerals[mineral] += 1;
    });
    const total = Object.values(myMinerals).reduce((t, amount) => t + amount, 0);
    for (const mineral in myMinerals) {
        myMinerals[mineral] = myMinerals[mineral] / total;
    }
    return myMinerals;
}
function isRoomValidForExpansion(mem) {
    if (mem.type !== RoomTypeEnum.STANDART) {
        return false;
    }
    if ((mem.sourceCount || 0) < 2) {
        return false;
    }
    // if (memory.recentDeaths && memory.recentDeaths > 1) {
    //   return false;
    // }
    return true;
}
function getRoomsInRange() {
    const rooms = {};
    Rooms.myRooms.forEach(room => {
        const [centerX, centerY] = Geo.roomNameToXY(room.name);
        for (let x = centerX - MAX_EXPANSION_RANGE; x <= centerX + MAX_EXPANSION_RANGE; x++) {
            for (let y = centerY - MAX_EXPANSION_RANGE; y <= centerY + MAX_EXPANSION_RANGE; y++) {
                const roomName = Geo.roomXYToName(x, y);
                rooms[roomName] = roomName;
            }
        }
    });
    return Object.keys(rooms);
}

global.roomClaimScore = () => roomClaimScore.exit();

console.log("LOADED NEW SHIT", Game.time);
const INITS = [HeapMemory, TickCache, Profiler, RoomModel, Creeps, Cache, Rooms, Duos, Traveler, VisualizeRoomStats];
const EXITS = [
    TickAction,
    Log,
    VisualizeRoomStats,
    Geo,
    // Profiler.visualize();
    // roomClaimScore, // E36S53
    Quads,
    Profiler,
    Duos,
    HeapMemory
];
HeapMemory.load();
Geo.resetRoutesContainingBlacklisted();
const loop = ErrorMapper.wrapLoop(() => {
    INITS.forEach(init => {
        try {
            Profiler.profileModule(`init - ${init.name}`, () => init.init());
        }
        catch (e) {
            console.log(init.name, e);
        }
    });
    Modules();
    EXITS.forEach(exit => {
        try {
            Profiler.profileModule(`exit - ${exit.name}`, () => exit.exit());
        }
        catch (e) {
            console.log(exit.name, e);
        }
    });
    Object.values(Game.constructionSites).forEach(c => {
        Game.map.visual.circle(c.pos, { radius: 3 });
    });
    // Object.values(Game.flags)
    //   .filter(f => f.color === COLOR_GREY && f.secondaryColor === COLOR_GREY)
    //   .forEach(f => {
    //     f.pos
    //       .lookFor(LOOK_STRUCTURES)
    //       .filter(s => s.structureType === STRUCTURE_ROAD)
    //       .forEach(s => s.destroy());
    //     f.remove();
    //   });
    // Object.values(Memory.rooms)
    //   .sort(
    //     (a, b) =>
    //       RoomMemoryReader.creditValue(b[ROOM_MEMORY_KEY_NAME]) - RoomMemoryReader.creditValue(a[ROOM_MEMORY_KEY_NAME])
    //   )
    //   .slice(0, 10)
    //   .forEach(roomMemory => {
    //     Log.room(
    //       roomMemory[ROOM_MEMORY_KEY_NAME],
    //       RoomMemoryReader.creditValue(roomMemory[ROOM_MEMORY_KEY_NAME]).toLocaleString(),
    //       String(RoomMemoryReader.ownerUsername(roomMemory[ROOM_MEMORY_KEY_NAME]))
    //     );
    //   });
    // if (Game.cpu.generatePixel) {
    //   if (Game.cpu.bucket >= 10000) {
    //     Game.cpu.generatePixel();
    //   }
    // }
    // Rooms.myRooms.forEach(r => {
    //   if (!r.nuker) {
    //     return;
    //   }
    //
    //   if (r.nuker.cooldown) {
    //     return;
    //   }
    //
    //   Game.map.visual.circle(new RoomPosition(25, 25, r.name), { radius: 10 });
    // });
    // Object.values(Game.rooms).forEach(room => {
    //   const log = room.getEventLog();
    //
    //   log.forEach(l => {
    //     if (l.event !== EVENT_OBJECT_DESTROYED) {
    //       return;
    //     }
    //
    //     if (l.data.type !== STRUCTURE_RAMPART && l.data.type !== STRUCTURE_WALL) {
    //       return;
    //     }
    //
    //     Log.room(room, "rampart gone!");
    //   });
    // });
});

exports.loop = loop;
//# sourceMappingURL=main.js.map
